"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ip-address";
exports.ids = ["vendor-chunks/ip-address"];
exports.modules = {

/***/ "(ssr)/./node_modules/ip-address/dist/address-error.js":
/*!*******************************************************!*\
  !*** ./node_modules/ip-address/dist/address-error.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AddressError = void 0;\nclass AddressError extends Error {\n    constructor(message, parseMessage) {\n        super(message);\n        this.name = 'AddressError';\n        this.parseMessage = parseMessage;\n    }\n}\nexports.AddressError = AddressError;\n//# sourceMappingURL=address-error.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaXAtYWRkcmVzcy9kaXN0L2FkZHJlc3MtZXJyb3IuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXFNpbXBsZVxcRG93bmxvYWRzXFxQcm95ZWN0b0V4dHJhY3RvckRlRmlsYW1lbnRvXFxleHRyYWN0b3Itc2VydmVyXFxub2RlX21vZHVsZXNcXGlwLWFkZHJlc3NcXGRpc3RcXGFkZHJlc3MtZXJyb3IuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkFkZHJlc3NFcnJvciA9IHZvaWQgMDtcbmNsYXNzIEFkZHJlc3NFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBwYXJzZU1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIHRoaXMubmFtZSA9ICdBZGRyZXNzRXJyb3InO1xuICAgICAgICB0aGlzLnBhcnNlTWVzc2FnZSA9IHBhcnNlTWVzc2FnZTtcbiAgICB9XG59XG5leHBvcnRzLkFkZHJlc3NFcnJvciA9IEFkZHJlc3NFcnJvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFkZHJlc3MtZXJyb3IuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ip-address/dist/address-error.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ip-address/dist/common.js":
/*!************************************************!*\
  !*** ./node_modules/ip-address/dist/common.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isInSubnet = isInSubnet;\nexports.isCorrect = isCorrect;\nexports.numberToPaddedHex = numberToPaddedHex;\nexports.stringToPaddedHex = stringToPaddedHex;\nexports.testBit = testBit;\nfunction isInSubnet(address) {\n    if (this.subnetMask < address.subnetMask) {\n        return false;\n    }\n    if (this.mask(address.subnetMask) === address.mask()) {\n        return true;\n    }\n    return false;\n}\nfunction isCorrect(defaultBits) {\n    return function () {\n        if (this.addressMinusSuffix !== this.correctForm()) {\n            return false;\n        }\n        if (this.subnetMask === defaultBits && !this.parsedSubnet) {\n            return true;\n        }\n        return this.parsedSubnet === String(this.subnetMask);\n    };\n}\nfunction numberToPaddedHex(number) {\n    return number.toString(16).padStart(2, '0');\n}\nfunction stringToPaddedHex(numberString) {\n    return numberToPaddedHex(parseInt(numberString, 10));\n}\n/**\n * @param binaryValue Binary representation of a value (e.g. `10`)\n * @param position Byte position, where 0 is the least significant bit\n */\nfunction testBit(binaryValue, position) {\n    const { length } = binaryValue;\n    if (position > length) {\n        return false;\n    }\n    const positionInString = length - position;\n    return binaryValue.substring(positionInString, positionInString + 1) === '1';\n}\n//# sourceMappingURL=common.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaXAtYWRkcmVzcy9kaXN0L2NvbW1vbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxrQkFBa0I7QUFDbEIsaUJBQWlCO0FBQ2pCLHlCQUF5QjtBQUN6Qix5QkFBeUI7QUFDekIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXFNpbXBsZVxcRG93bmxvYWRzXFxQcm95ZWN0b0V4dHJhY3RvckRlRmlsYW1lbnRvXFxleHRyYWN0b3Itc2VydmVyXFxub2RlX21vZHVsZXNcXGlwLWFkZHJlc3NcXGRpc3RcXGNvbW1vbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaXNJblN1Ym5ldCA9IGlzSW5TdWJuZXQ7XG5leHBvcnRzLmlzQ29ycmVjdCA9IGlzQ29ycmVjdDtcbmV4cG9ydHMubnVtYmVyVG9QYWRkZWRIZXggPSBudW1iZXJUb1BhZGRlZEhleDtcbmV4cG9ydHMuc3RyaW5nVG9QYWRkZWRIZXggPSBzdHJpbmdUb1BhZGRlZEhleDtcbmV4cG9ydHMudGVzdEJpdCA9IHRlc3RCaXQ7XG5mdW5jdGlvbiBpc0luU3VibmV0KGFkZHJlc3MpIHtcbiAgICBpZiAodGhpcy5zdWJuZXRNYXNrIDwgYWRkcmVzcy5zdWJuZXRNYXNrKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHRoaXMubWFzayhhZGRyZXNzLnN1Ym5ldE1hc2spID09PSBhZGRyZXNzLm1hc2soKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaXNDb3JyZWN0KGRlZmF1bHRCaXRzKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuYWRkcmVzc01pbnVzU3VmZml4ICE9PSB0aGlzLmNvcnJlY3RGb3JtKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zdWJuZXRNYXNrID09PSBkZWZhdWx0Qml0cyAmJiAhdGhpcy5wYXJzZWRTdWJuZXQpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlZFN1Ym5ldCA9PT0gU3RyaW5nKHRoaXMuc3VibmV0TWFzayk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIG51bWJlclRvUGFkZGVkSGV4KG51bWJlcikge1xuICAgIHJldHVybiBudW1iZXIudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJyk7XG59XG5mdW5jdGlvbiBzdHJpbmdUb1BhZGRlZEhleChudW1iZXJTdHJpbmcpIHtcbiAgICByZXR1cm4gbnVtYmVyVG9QYWRkZWRIZXgocGFyc2VJbnQobnVtYmVyU3RyaW5nLCAxMCkpO1xufVxuLyoqXG4gKiBAcGFyYW0gYmluYXJ5VmFsdWUgQmluYXJ5IHJlcHJlc2VudGF0aW9uIG9mIGEgdmFsdWUgKGUuZy4gYDEwYClcbiAqIEBwYXJhbSBwb3NpdGlvbiBCeXRlIHBvc2l0aW9uLCB3aGVyZSAwIGlzIHRoZSBsZWFzdCBzaWduaWZpY2FudCBiaXRcbiAqL1xuZnVuY3Rpb24gdGVzdEJpdChiaW5hcnlWYWx1ZSwgcG9zaXRpb24pIHtcbiAgICBjb25zdCB7IGxlbmd0aCB9ID0gYmluYXJ5VmFsdWU7XG4gICAgaWYgKHBvc2l0aW9uID4gbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgcG9zaXRpb25JblN0cmluZyA9IGxlbmd0aCAtIHBvc2l0aW9uO1xuICAgIHJldHVybiBiaW5hcnlWYWx1ZS5zdWJzdHJpbmcocG9zaXRpb25JblN0cmluZywgcG9zaXRpb25JblN0cmluZyArIDEpID09PSAnMSc7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb21tb24uanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ip-address/dist/common.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ip-address/dist/ip-address.js":
/*!****************************************************!*\
  !*** ./node_modules/ip-address/dist/ip-address.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.v6 = exports.AddressError = exports.Address6 = exports.Address4 = void 0;\nvar ipv4_1 = __webpack_require__(/*! ./ipv4 */ \"(ssr)/./node_modules/ip-address/dist/ipv4.js\");\nObject.defineProperty(exports, \"Address4\", ({ enumerable: true, get: function () { return ipv4_1.Address4; } }));\nvar ipv6_1 = __webpack_require__(/*! ./ipv6 */ \"(ssr)/./node_modules/ip-address/dist/ipv6.js\");\nObject.defineProperty(exports, \"Address6\", ({ enumerable: true, get: function () { return ipv6_1.Address6; } }));\nvar address_error_1 = __webpack_require__(/*! ./address-error */ \"(ssr)/./node_modules/ip-address/dist/address-error.js\");\nObject.defineProperty(exports, \"AddressError\", ({ enumerable: true, get: function () { return address_error_1.AddressError; } }));\nconst helpers = __importStar(__webpack_require__(/*! ./v6/helpers */ \"(ssr)/./node_modules/ip-address/dist/v6/helpers.js\"));\nexports.v6 = { helpers };\n//# sourceMappingURL=ip-address.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaXAtYWRkcmVzcy9kaXN0L2lwLWFkZHJlc3MuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDBDQUEwQyw0QkFBNEI7QUFDdEUsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELFVBQVUsR0FBRyxvQkFBb0IsR0FBRyxnQkFBZ0IsR0FBRyxnQkFBZ0I7QUFDdkUsYUFBYSxtQkFBTyxDQUFDLDREQUFRO0FBQzdCLDRDQUEyQyxFQUFFLHFDQUFxQywyQkFBMkIsRUFBQztBQUM5RyxhQUFhLG1CQUFPLENBQUMsNERBQVE7QUFDN0IsNENBQTJDLEVBQUUscUNBQXFDLDJCQUEyQixFQUFDO0FBQzlHLHNCQUFzQixtQkFBTyxDQUFDLDhFQUFpQjtBQUMvQyxnREFBK0MsRUFBRSxxQ0FBcUMsd0NBQXdDLEVBQUM7QUFDL0gsNkJBQTZCLG1CQUFPLENBQUMsd0VBQWM7QUFDbkQsVUFBVSxLQUFLO0FBQ2YiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcU2ltcGxlXFxEb3dubG9hZHNcXFByb3llY3RvRXh0cmFjdG9yRGVGaWxhbWVudG9cXGV4dHJhY3Rvci1zZXJ2ZXJcXG5vZGVfbW9kdWxlc1xcaXAtYWRkcmVzc1xcZGlzdFxcaXAtYWRkcmVzcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy52NiA9IGV4cG9ydHMuQWRkcmVzc0Vycm9yID0gZXhwb3J0cy5BZGRyZXNzNiA9IGV4cG9ydHMuQWRkcmVzczQgPSB2b2lkIDA7XG52YXIgaXB2NF8xID0gcmVxdWlyZShcIi4vaXB2NFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkFkZHJlc3M0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpcHY0XzEuQWRkcmVzczQ7IH0gfSk7XG52YXIgaXB2Nl8xID0gcmVxdWlyZShcIi4vaXB2NlwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkFkZHJlc3M2XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpcHY2XzEuQWRkcmVzczY7IH0gfSk7XG52YXIgYWRkcmVzc19lcnJvcl8xID0gcmVxdWlyZShcIi4vYWRkcmVzcy1lcnJvclwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkFkZHJlc3NFcnJvclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYWRkcmVzc19lcnJvcl8xLkFkZHJlc3NFcnJvcjsgfSB9KTtcbmNvbnN0IGhlbHBlcnMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vdjYvaGVscGVyc1wiKSk7XG5leHBvcnRzLnY2ID0geyBoZWxwZXJzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pcC1hZGRyZXNzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ip-address/dist/ip-address.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ip-address/dist/ipv4.js":
/*!**********************************************!*\
  !*** ./node_modules/ip-address/dist/ipv4.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/* eslint-disable no-param-reassign */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Address4 = void 0;\nconst common = __importStar(__webpack_require__(/*! ./common */ \"(ssr)/./node_modules/ip-address/dist/common.js\"));\nconst constants = __importStar(__webpack_require__(/*! ./v4/constants */ \"(ssr)/./node_modules/ip-address/dist/v4/constants.js\"));\nconst address_error_1 = __webpack_require__(/*! ./address-error */ \"(ssr)/./node_modules/ip-address/dist/address-error.js\");\n/**\n * Represents an IPv4 address\n * @class Address4\n * @param {string} address - An IPv4 address string\n */\nclass Address4 {\n    constructor(address) {\n        this.groups = constants.GROUPS;\n        this.parsedAddress = [];\n        this.parsedSubnet = '';\n        this.subnet = '/32';\n        this.subnetMask = 32;\n        this.v4 = true;\n        /**\n         * Returns true if the address is correct, false otherwise\n         * @memberof Address4\n         * @instance\n         * @returns {Boolean}\n         */\n        this.isCorrect = common.isCorrect(constants.BITS);\n        /**\n         * Returns true if the given address is in the subnet of the current address\n         * @memberof Address4\n         * @instance\n         * @returns {boolean}\n         */\n        this.isInSubnet = common.isInSubnet;\n        this.address = address;\n        const subnet = constants.RE_SUBNET_STRING.exec(address);\n        if (subnet) {\n            this.parsedSubnet = subnet[0].replace('/', '');\n            this.subnetMask = parseInt(this.parsedSubnet, 10);\n            this.subnet = `/${this.subnetMask}`;\n            if (this.subnetMask < 0 || this.subnetMask > constants.BITS) {\n                throw new address_error_1.AddressError('Invalid subnet mask.');\n            }\n            address = address.replace(constants.RE_SUBNET_STRING, '');\n        }\n        this.addressMinusSuffix = address;\n        this.parsedAddress = this.parse(address);\n    }\n    static isValid(address) {\n        try {\n            // eslint-disable-next-line no-new\n            new Address4(address);\n            return true;\n        }\n        catch (e) {\n            return false;\n        }\n    }\n    /*\n     * Parses a v4 address\n     */\n    parse(address) {\n        const groups = address.split('.');\n        if (!address.match(constants.RE_ADDRESS)) {\n            throw new address_error_1.AddressError('Invalid IPv4 address.');\n        }\n        return groups;\n    }\n    /**\n     * Returns the correct form of an address\n     * @memberof Address4\n     * @instance\n     * @returns {String}\n     */\n    correctForm() {\n        return this.parsedAddress.map((part) => parseInt(part, 10)).join('.');\n    }\n    /**\n     * Converts a hex string to an IPv4 address object\n     * @memberof Address4\n     * @static\n     * @param {string} hex - a hex string to convert\n     * @returns {Address4}\n     */\n    static fromHex(hex) {\n        const padded = hex.replace(/:/g, '').padStart(8, '0');\n        const groups = [];\n        let i;\n        for (i = 0; i < 8; i += 2) {\n            const h = padded.slice(i, i + 2);\n            groups.push(parseInt(h, 16));\n        }\n        return new Address4(groups.join('.'));\n    }\n    /**\n     * Converts an integer into a IPv4 address object\n     * @memberof Address4\n     * @static\n     * @param {integer} integer - a number to convert\n     * @returns {Address4}\n     */\n    static fromInteger(integer) {\n        return Address4.fromHex(integer.toString(16));\n    }\n    /**\n     * Return an address from in-addr.arpa form\n     * @memberof Address4\n     * @static\n     * @param {string} arpaFormAddress - an 'in-addr.arpa' form ipv4 address\n     * @returns {Adress4}\n     * @example\n     * var address = Address4.fromArpa(42.2.0.192.in-addr.arpa.)\n     * address.correctForm(); // '192.0.2.42'\n     */\n    static fromArpa(arpaFormAddress) {\n        // remove ending \".in-addr.arpa.\" or just \".\"\n        const leader = arpaFormAddress.replace(/(\\.in-addr\\.arpa)?\\.$/, '');\n        const address = leader.split('.').reverse().join('.');\n        return new Address4(address);\n    }\n    /**\n     * Converts an IPv4 address object to a hex string\n     * @memberof Address4\n     * @instance\n     * @returns {String}\n     */\n    toHex() {\n        return this.parsedAddress.map((part) => common.stringToPaddedHex(part)).join(':');\n    }\n    /**\n     * Converts an IPv4 address object to an array of bytes\n     * @memberof Address4\n     * @instance\n     * @returns {Array}\n     */\n    toArray() {\n        return this.parsedAddress.map((part) => parseInt(part, 10));\n    }\n    /**\n     * Converts an IPv4 address object to an IPv6 address group\n     * @memberof Address4\n     * @instance\n     * @returns {String}\n     */\n    toGroup6() {\n        const output = [];\n        let i;\n        for (i = 0; i < constants.GROUPS; i += 2) {\n            output.push(`${common.stringToPaddedHex(this.parsedAddress[i])}${common.stringToPaddedHex(this.parsedAddress[i + 1])}`);\n        }\n        return output.join(':');\n    }\n    /**\n     * Returns the address as a `bigint`\n     * @memberof Address4\n     * @instance\n     * @returns {bigint}\n     */\n    bigInt() {\n        return BigInt(`0x${this.parsedAddress.map((n) => common.stringToPaddedHex(n)).join('')}`);\n    }\n    /**\n     * Helper function getting start address.\n     * @memberof Address4\n     * @instance\n     * @returns {bigint}\n     */\n    _startAddress() {\n        return BigInt(`0b${this.mask() + '0'.repeat(constants.BITS - this.subnetMask)}`);\n    }\n    /**\n     * The first address in the range given by this address' subnet.\n     * Often referred to as the Network Address.\n     * @memberof Address4\n     * @instance\n     * @returns {Address4}\n     */\n    startAddress() {\n        return Address4.fromBigInt(this._startAddress());\n    }\n    /**\n     * The first host address in the range given by this address's subnet ie\n     * the first address after the Network Address\n     * @memberof Address4\n     * @instance\n     * @returns {Address4}\n     */\n    startAddressExclusive() {\n        const adjust = BigInt('1');\n        return Address4.fromBigInt(this._startAddress() + adjust);\n    }\n    /**\n     * Helper function getting end address.\n     * @memberof Address4\n     * @instance\n     * @returns {bigint}\n     */\n    _endAddress() {\n        return BigInt(`0b${this.mask() + '1'.repeat(constants.BITS - this.subnetMask)}`);\n    }\n    /**\n     * The last address in the range given by this address' subnet\n     * Often referred to as the Broadcast\n     * @memberof Address4\n     * @instance\n     * @returns {Address4}\n     */\n    endAddress() {\n        return Address4.fromBigInt(this._endAddress());\n    }\n    /**\n     * The last host address in the range given by this address's subnet ie\n     * the last address prior to the Broadcast Address\n     * @memberof Address4\n     * @instance\n     * @returns {Address4}\n     */\n    endAddressExclusive() {\n        const adjust = BigInt('1');\n        return Address4.fromBigInt(this._endAddress() - adjust);\n    }\n    /**\n     * Converts a BigInt to a v4 address object\n     * @memberof Address4\n     * @static\n     * @param {bigint} bigInt - a BigInt to convert\n     * @returns {Address4}\n     */\n    static fromBigInt(bigInt) {\n        return Address4.fromHex(bigInt.toString(16));\n    }\n    /**\n     * Returns the first n bits of the address, defaulting to the\n     * subnet mask\n     * @memberof Address4\n     * @instance\n     * @returns {String}\n     */\n    mask(mask) {\n        if (mask === undefined) {\n            mask = this.subnetMask;\n        }\n        return this.getBitsBase2(0, mask);\n    }\n    /**\n     * Returns the bits in the given range as a base-2 string\n     * @memberof Address4\n     * @instance\n     * @returns {string}\n     */\n    getBitsBase2(start, end) {\n        return this.binaryZeroPad().slice(start, end);\n    }\n    /**\n     * Return the reversed ip6.arpa form of the address\n     * @memberof Address4\n     * @param {Object} options\n     * @param {boolean} options.omitSuffix - omit the \"in-addr.arpa\" suffix\n     * @instance\n     * @returns {String}\n     */\n    reverseForm(options) {\n        if (!options) {\n            options = {};\n        }\n        const reversed = this.correctForm().split('.').reverse().join('.');\n        if (options.omitSuffix) {\n            return reversed;\n        }\n        return `${reversed}.in-addr.arpa.`;\n    }\n    /**\n     * Returns true if the given address is a multicast address\n     * @memberof Address4\n     * @instance\n     * @returns {boolean}\n     */\n    isMulticast() {\n        return this.isInSubnet(new Address4('224.0.0.0/4'));\n    }\n    /**\n     * Returns a zero-padded base-2 string representation of the address\n     * @memberof Address4\n     * @instance\n     * @returns {string}\n     */\n    binaryZeroPad() {\n        return this.bigInt().toString(2).padStart(constants.BITS, '0');\n    }\n    /**\n     * Groups an IPv4 address for inclusion at the end of an IPv6 address\n     * @returns {String}\n     */\n    groupForV6() {\n        const segments = this.parsedAddress;\n        return this.address.replace(constants.RE_ADDRESS, `<span class=\"hover-group group-v4 group-6\">${segments\n            .slice(0, 2)\n            .join('.')}</span>.<span class=\"hover-group group-v4 group-7\">${segments\n            .slice(2, 4)\n            .join('.')}</span>`);\n    }\n}\nexports.Address4 = Address4;\n//# sourceMappingURL=ipv4.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaXAtYWRkcmVzcy9kaXN0L2lwdjQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsMENBQTBDLDRCQUE0QjtBQUN0RSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZ0JBQWdCO0FBQ2hCLDRCQUE0QixtQkFBTyxDQUFDLGdFQUFVO0FBQzlDLCtCQUErQixtQkFBTyxDQUFDLDRFQUFnQjtBQUN2RCx3QkFBd0IsbUJBQU8sQ0FBQyw4RUFBaUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixnQkFBZ0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQywyQkFBMkIsZ0RBQWdELEVBQUUsb0RBQW9EO0FBQ2pJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSwyQkFBMkIsb0VBQW9FO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLDJCQUEyQiwyREFBMkQ7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLDJCQUEyQiwyREFBMkQ7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsU0FBUztBQUN4QjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLHdHQUF3RztBQUN4RztBQUNBLHVCQUF1QixxREFBcUQ7QUFDNUU7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxTaW1wbGVcXERvd25sb2Fkc1xcUHJveWVjdG9FeHRyYWN0b3JEZUZpbGFtZW50b1xcZXh0cmFjdG9yLXNlcnZlclxcbm9kZV9tb2R1bGVzXFxpcC1hZGRyZXNzXFxkaXN0XFxpcHY0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyogZXNsaW50LWRpc2FibGUgbm8tcGFyYW0tcmVhc3NpZ24gKi9cbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5BZGRyZXNzNCA9IHZvaWQgMDtcbmNvbnN0IGNvbW1vbiA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9jb21tb25cIikpO1xuY29uc3QgY29uc3RhbnRzID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL3Y0L2NvbnN0YW50c1wiKSk7XG5jb25zdCBhZGRyZXNzX2Vycm9yXzEgPSByZXF1aXJlKFwiLi9hZGRyZXNzLWVycm9yXCIpO1xuLyoqXG4gKiBSZXByZXNlbnRzIGFuIElQdjQgYWRkcmVzc1xuICogQGNsYXNzIEFkZHJlc3M0XG4gKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzcyAtIEFuIElQdjQgYWRkcmVzcyBzdHJpbmdcbiAqL1xuY2xhc3MgQWRkcmVzczQge1xuICAgIGNvbnN0cnVjdG9yKGFkZHJlc3MpIHtcbiAgICAgICAgdGhpcy5ncm91cHMgPSBjb25zdGFudHMuR1JPVVBTO1xuICAgICAgICB0aGlzLnBhcnNlZEFkZHJlc3MgPSBbXTtcbiAgICAgICAgdGhpcy5wYXJzZWRTdWJuZXQgPSAnJztcbiAgICAgICAgdGhpcy5zdWJuZXQgPSAnLzMyJztcbiAgICAgICAgdGhpcy5zdWJuZXRNYXNrID0gMzI7XG4gICAgICAgIHRoaXMudjQgPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBhZGRyZXNzIGlzIGNvcnJlY3QsIGZhbHNlIG90aGVyd2lzZVxuICAgICAgICAgKiBAbWVtYmVyb2YgQWRkcmVzczRcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pc0NvcnJlY3QgPSBjb21tb24uaXNDb3JyZWN0KGNvbnN0YW50cy5CSVRTKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gYWRkcmVzcyBpcyBpbiB0aGUgc3VibmV0IG9mIHRoZSBjdXJyZW50IGFkZHJlc3NcbiAgICAgICAgICogQG1lbWJlcm9mIEFkZHJlc3M0XG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaXNJblN1Ym5ldCA9IGNvbW1vbi5pc0luU3VibmV0O1xuICAgICAgICB0aGlzLmFkZHJlc3MgPSBhZGRyZXNzO1xuICAgICAgICBjb25zdCBzdWJuZXQgPSBjb25zdGFudHMuUkVfU1VCTkVUX1NUUklORy5leGVjKGFkZHJlc3MpO1xuICAgICAgICBpZiAoc3VibmV0KSB7XG4gICAgICAgICAgICB0aGlzLnBhcnNlZFN1Ym5ldCA9IHN1Ym5ldFswXS5yZXBsYWNlKCcvJywgJycpO1xuICAgICAgICAgICAgdGhpcy5zdWJuZXRNYXNrID0gcGFyc2VJbnQodGhpcy5wYXJzZWRTdWJuZXQsIDEwKTtcbiAgICAgICAgICAgIHRoaXMuc3VibmV0ID0gYC8ke3RoaXMuc3VibmV0TWFza31gO1xuICAgICAgICAgICAgaWYgKHRoaXMuc3VibmV0TWFzayA8IDAgfHwgdGhpcy5zdWJuZXRNYXNrID4gY29uc3RhbnRzLkJJVFMpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgYWRkcmVzc19lcnJvcl8xLkFkZHJlc3NFcnJvcignSW52YWxpZCBzdWJuZXQgbWFzay4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFkZHJlc3MgPSBhZGRyZXNzLnJlcGxhY2UoY29uc3RhbnRzLlJFX1NVQk5FVF9TVFJJTkcsICcnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFkZHJlc3NNaW51c1N1ZmZpeCA9IGFkZHJlc3M7XG4gICAgICAgIHRoaXMucGFyc2VkQWRkcmVzcyA9IHRoaXMucGFyc2UoYWRkcmVzcyk7XG4gICAgfVxuICAgIHN0YXRpYyBpc1ZhbGlkKGFkZHJlc3MpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXdcbiAgICAgICAgICAgIG5ldyBBZGRyZXNzNChhZGRyZXNzKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLypcbiAgICAgKiBQYXJzZXMgYSB2NCBhZGRyZXNzXG4gICAgICovXG4gICAgcGFyc2UoYWRkcmVzcykge1xuICAgICAgICBjb25zdCBncm91cHMgPSBhZGRyZXNzLnNwbGl0KCcuJyk7XG4gICAgICAgIGlmICghYWRkcmVzcy5tYXRjaChjb25zdGFudHMuUkVfQUREUkVTUykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBhZGRyZXNzX2Vycm9yXzEuQWRkcmVzc0Vycm9yKCdJbnZhbGlkIElQdjQgYWRkcmVzcy4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ3JvdXBzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjb3JyZWN0IGZvcm0gb2YgYW4gYWRkcmVzc1xuICAgICAqIEBtZW1iZXJvZiBBZGRyZXNzNFxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgY29ycmVjdEZvcm0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlZEFkZHJlc3MubWFwKChwYXJ0KSA9PiBwYXJzZUludChwYXJ0LCAxMCkpLmpvaW4oJy4nKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYSBoZXggc3RyaW5nIHRvIGFuIElQdjQgYWRkcmVzcyBvYmplY3RcbiAgICAgKiBAbWVtYmVyb2YgQWRkcmVzczRcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGhleCAtIGEgaGV4IHN0cmluZyB0byBjb252ZXJ0XG4gICAgICogQHJldHVybnMge0FkZHJlc3M0fVxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tSGV4KGhleCkge1xuICAgICAgICBjb25zdCBwYWRkZWQgPSBoZXgucmVwbGFjZSgvOi9nLCAnJykucGFkU3RhcnQoOCwgJzAnKTtcbiAgICAgICAgY29uc3QgZ3JvdXBzID0gW107XG4gICAgICAgIGxldCBpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgODsgaSArPSAyKSB7XG4gICAgICAgICAgICBjb25zdCBoID0gcGFkZGVkLnNsaWNlKGksIGkgKyAyKTtcbiAgICAgICAgICAgIGdyb3Vwcy5wdXNoKHBhcnNlSW50KGgsIDE2KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBBZGRyZXNzNChncm91cHMuam9pbignLicpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYW4gaW50ZWdlciBpbnRvIGEgSVB2NCBhZGRyZXNzIG9iamVjdFxuICAgICAqIEBtZW1iZXJvZiBBZGRyZXNzNFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge2ludGVnZXJ9IGludGVnZXIgLSBhIG51bWJlciB0byBjb252ZXJ0XG4gICAgICogQHJldHVybnMge0FkZHJlc3M0fVxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tSW50ZWdlcihpbnRlZ2VyKSB7XG4gICAgICAgIHJldHVybiBBZGRyZXNzNC5mcm9tSGV4KGludGVnZXIudG9TdHJpbmcoMTYpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGFuIGFkZHJlc3MgZnJvbSBpbi1hZGRyLmFycGEgZm9ybVxuICAgICAqIEBtZW1iZXJvZiBBZGRyZXNzNFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXJwYUZvcm1BZGRyZXNzIC0gYW4gJ2luLWFkZHIuYXJwYScgZm9ybSBpcHY0IGFkZHJlc3NcbiAgICAgKiBAcmV0dXJucyB7QWRyZXNzNH1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHZhciBhZGRyZXNzID0gQWRkcmVzczQuZnJvbUFycGEoNDIuMi4wLjE5Mi5pbi1hZGRyLmFycGEuKVxuICAgICAqIGFkZHJlc3MuY29ycmVjdEZvcm0oKTsgLy8gJzE5Mi4wLjIuNDInXG4gICAgICovXG4gICAgc3RhdGljIGZyb21BcnBhKGFycGFGb3JtQWRkcmVzcykge1xuICAgICAgICAvLyByZW1vdmUgZW5kaW5nIFwiLmluLWFkZHIuYXJwYS5cIiBvciBqdXN0IFwiLlwiXG4gICAgICAgIGNvbnN0IGxlYWRlciA9IGFycGFGb3JtQWRkcmVzcy5yZXBsYWNlKC8oXFwuaW4tYWRkclxcLmFycGEpP1xcLiQvLCAnJyk7XG4gICAgICAgIGNvbnN0IGFkZHJlc3MgPSBsZWFkZXIuc3BsaXQoJy4nKS5yZXZlcnNlKCkuam9pbignLicpO1xuICAgICAgICByZXR1cm4gbmV3IEFkZHJlc3M0KGFkZHJlc3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhbiBJUHY0IGFkZHJlc3Mgb2JqZWN0IHRvIGEgaGV4IHN0cmluZ1xuICAgICAqIEBtZW1iZXJvZiBBZGRyZXNzNFxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgdG9IZXgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlZEFkZHJlc3MubWFwKChwYXJ0KSA9PiBjb21tb24uc3RyaW5nVG9QYWRkZWRIZXgocGFydCkpLmpvaW4oJzonKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYW4gSVB2NCBhZGRyZXNzIG9iamVjdCB0byBhbiBhcnJheSBvZiBieXRlc1xuICAgICAqIEBtZW1iZXJvZiBBZGRyZXNzNFxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgKi9cbiAgICB0b0FycmF5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZWRBZGRyZXNzLm1hcCgocGFydCkgPT4gcGFyc2VJbnQocGFydCwgMTApKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYW4gSVB2NCBhZGRyZXNzIG9iamVjdCB0byBhbiBJUHY2IGFkZHJlc3MgZ3JvdXBcbiAgICAgKiBAbWVtYmVyb2YgQWRkcmVzczRcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIHRvR3JvdXA2KCkge1xuICAgICAgICBjb25zdCBvdXRwdXQgPSBbXTtcbiAgICAgICAgbGV0IGk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb25zdGFudHMuR1JPVVBTOyBpICs9IDIpIHtcbiAgICAgICAgICAgIG91dHB1dC5wdXNoKGAke2NvbW1vbi5zdHJpbmdUb1BhZGRlZEhleCh0aGlzLnBhcnNlZEFkZHJlc3NbaV0pfSR7Y29tbW9uLnN0cmluZ1RvUGFkZGVkSGV4KHRoaXMucGFyc2VkQWRkcmVzc1tpICsgMV0pfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXRwdXQuam9pbignOicpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBhZGRyZXNzIGFzIGEgYGJpZ2ludGBcbiAgICAgKiBAbWVtYmVyb2YgQWRkcmVzczRcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJucyB7YmlnaW50fVxuICAgICAqL1xuICAgIGJpZ0ludCgpIHtcbiAgICAgICAgcmV0dXJuIEJpZ0ludChgMHgke3RoaXMucGFyc2VkQWRkcmVzcy5tYXAoKG4pID0+IGNvbW1vbi5zdHJpbmdUb1BhZGRlZEhleChuKSkuam9pbignJyl9YCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhlbHBlciBmdW5jdGlvbiBnZXR0aW5nIHN0YXJ0IGFkZHJlc3MuXG4gICAgICogQG1lbWJlcm9mIEFkZHJlc3M0XG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHJldHVybnMge2JpZ2ludH1cbiAgICAgKi9cbiAgICBfc3RhcnRBZGRyZXNzKCkge1xuICAgICAgICByZXR1cm4gQmlnSW50KGAwYiR7dGhpcy5tYXNrKCkgKyAnMCcucmVwZWF0KGNvbnN0YW50cy5CSVRTIC0gdGhpcy5zdWJuZXRNYXNrKX1gKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGZpcnN0IGFkZHJlc3MgaW4gdGhlIHJhbmdlIGdpdmVuIGJ5IHRoaXMgYWRkcmVzcycgc3VibmV0LlxuICAgICAqIE9mdGVuIHJlZmVycmVkIHRvIGFzIHRoZSBOZXR3b3JrIEFkZHJlc3MuXG4gICAgICogQG1lbWJlcm9mIEFkZHJlc3M0XG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHJldHVybnMge0FkZHJlc3M0fVxuICAgICAqL1xuICAgIHN0YXJ0QWRkcmVzcygpIHtcbiAgICAgICAgcmV0dXJuIEFkZHJlc3M0LmZyb21CaWdJbnQodGhpcy5fc3RhcnRBZGRyZXNzKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgZmlyc3QgaG9zdCBhZGRyZXNzIGluIHRoZSByYW5nZSBnaXZlbiBieSB0aGlzIGFkZHJlc3MncyBzdWJuZXQgaWVcbiAgICAgKiB0aGUgZmlyc3QgYWRkcmVzcyBhZnRlciB0aGUgTmV0d29yayBBZGRyZXNzXG4gICAgICogQG1lbWJlcm9mIEFkZHJlc3M0XG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHJldHVybnMge0FkZHJlc3M0fVxuICAgICAqL1xuICAgIHN0YXJ0QWRkcmVzc0V4Y2x1c2l2ZSgpIHtcbiAgICAgICAgY29uc3QgYWRqdXN0ID0gQmlnSW50KCcxJyk7XG4gICAgICAgIHJldHVybiBBZGRyZXNzNC5mcm9tQmlnSW50KHRoaXMuX3N0YXJ0QWRkcmVzcygpICsgYWRqdXN0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGVscGVyIGZ1bmN0aW9uIGdldHRpbmcgZW5kIGFkZHJlc3MuXG4gICAgICogQG1lbWJlcm9mIEFkZHJlc3M0XG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHJldHVybnMge2JpZ2ludH1cbiAgICAgKi9cbiAgICBfZW5kQWRkcmVzcygpIHtcbiAgICAgICAgcmV0dXJuIEJpZ0ludChgMGIke3RoaXMubWFzaygpICsgJzEnLnJlcGVhdChjb25zdGFudHMuQklUUyAtIHRoaXMuc3VibmV0TWFzayl9YCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBsYXN0IGFkZHJlc3MgaW4gdGhlIHJhbmdlIGdpdmVuIGJ5IHRoaXMgYWRkcmVzcycgc3VibmV0XG4gICAgICogT2Z0ZW4gcmVmZXJyZWQgdG8gYXMgdGhlIEJyb2FkY2FzdFxuICAgICAqIEBtZW1iZXJvZiBBZGRyZXNzNFxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEByZXR1cm5zIHtBZGRyZXNzNH1cbiAgICAgKi9cbiAgICBlbmRBZGRyZXNzKCkge1xuICAgICAgICByZXR1cm4gQWRkcmVzczQuZnJvbUJpZ0ludCh0aGlzLl9lbmRBZGRyZXNzKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgbGFzdCBob3N0IGFkZHJlc3MgaW4gdGhlIHJhbmdlIGdpdmVuIGJ5IHRoaXMgYWRkcmVzcydzIHN1Ym5ldCBpZVxuICAgICAqIHRoZSBsYXN0IGFkZHJlc3MgcHJpb3IgdG8gdGhlIEJyb2FkY2FzdCBBZGRyZXNzXG4gICAgICogQG1lbWJlcm9mIEFkZHJlc3M0XG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHJldHVybnMge0FkZHJlc3M0fVxuICAgICAqL1xuICAgIGVuZEFkZHJlc3NFeGNsdXNpdmUoKSB7XG4gICAgICAgIGNvbnN0IGFkanVzdCA9IEJpZ0ludCgnMScpO1xuICAgICAgICByZXR1cm4gQWRkcmVzczQuZnJvbUJpZ0ludCh0aGlzLl9lbmRBZGRyZXNzKCkgLSBhZGp1c3QpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhIEJpZ0ludCB0byBhIHY0IGFkZHJlc3Mgb2JqZWN0XG4gICAgICogQG1lbWJlcm9mIEFkZHJlc3M0XG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7YmlnaW50fSBiaWdJbnQgLSBhIEJpZ0ludCB0byBjb252ZXJ0XG4gICAgICogQHJldHVybnMge0FkZHJlc3M0fVxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tQmlnSW50KGJpZ0ludCkge1xuICAgICAgICByZXR1cm4gQWRkcmVzczQuZnJvbUhleChiaWdJbnQudG9TdHJpbmcoMTYpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZmlyc3QgbiBiaXRzIG9mIHRoZSBhZGRyZXNzLCBkZWZhdWx0aW5nIHRvIHRoZVxuICAgICAqIHN1Ym5ldCBtYXNrXG4gICAgICogQG1lbWJlcm9mIEFkZHJlc3M0XG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBtYXNrKG1hc2spIHtcbiAgICAgICAgaWYgKG1hc2sgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbWFzayA9IHRoaXMuc3VibmV0TWFzaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5nZXRCaXRzQmFzZTIoMCwgbWFzayk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGJpdHMgaW4gdGhlIGdpdmVuIHJhbmdlIGFzIGEgYmFzZS0yIHN0cmluZ1xuICAgICAqIEBtZW1iZXJvZiBBZGRyZXNzNFxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgZ2V0Qml0c0Jhc2UyKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmluYXJ5WmVyb1BhZCgpLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIHJldmVyc2VkIGlwNi5hcnBhIGZvcm0gb2YgdGhlIGFkZHJlc3NcbiAgICAgKiBAbWVtYmVyb2YgQWRkcmVzczRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5vbWl0U3VmZml4IC0gb21pdCB0aGUgXCJpbi1hZGRyLmFycGFcIiBzdWZmaXhcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIHJldmVyc2VGb3JtKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmV2ZXJzZWQgPSB0aGlzLmNvcnJlY3RGb3JtKCkuc3BsaXQoJy4nKS5yZXZlcnNlKCkuam9pbignLicpO1xuICAgICAgICBpZiAob3B0aW9ucy5vbWl0U3VmZml4KSB7XG4gICAgICAgICAgICByZXR1cm4gcmV2ZXJzZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGAke3JldmVyc2VkfS5pbi1hZGRyLmFycGEuYDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBhZGRyZXNzIGlzIGEgbXVsdGljYXN0IGFkZHJlc3NcbiAgICAgKiBAbWVtYmVyb2YgQWRkcmVzczRcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBpc011bHRpY2FzdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNJblN1Ym5ldChuZXcgQWRkcmVzczQoJzIyNC4wLjAuMC80JykpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgemVyby1wYWRkZWQgYmFzZS0yIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgYWRkcmVzc1xuICAgICAqIEBtZW1iZXJvZiBBZGRyZXNzNFxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgYmluYXJ5WmVyb1BhZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmlnSW50KCkudG9TdHJpbmcoMikucGFkU3RhcnQoY29uc3RhbnRzLkJJVFMsICcwJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdyb3VwcyBhbiBJUHY0IGFkZHJlc3MgZm9yIGluY2x1c2lvbiBhdCB0aGUgZW5kIG9mIGFuIElQdjYgYWRkcmVzc1xuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ3JvdXBGb3JWNigpIHtcbiAgICAgICAgY29uc3Qgc2VnbWVudHMgPSB0aGlzLnBhcnNlZEFkZHJlc3M7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZHJlc3MucmVwbGFjZShjb25zdGFudHMuUkVfQUREUkVTUywgYDxzcGFuIGNsYXNzPVwiaG92ZXItZ3JvdXAgZ3JvdXAtdjQgZ3JvdXAtNlwiPiR7c2VnbWVudHNcbiAgICAgICAgICAgIC5zbGljZSgwLCAyKVxuICAgICAgICAgICAgLmpvaW4oJy4nKX08L3NwYW4+LjxzcGFuIGNsYXNzPVwiaG92ZXItZ3JvdXAgZ3JvdXAtdjQgZ3JvdXAtN1wiPiR7c2VnbWVudHNcbiAgICAgICAgICAgIC5zbGljZSgyLCA0KVxuICAgICAgICAgICAgLmpvaW4oJy4nKX08L3NwYW4+YCk7XG4gICAgfVxufVxuZXhwb3J0cy5BZGRyZXNzNCA9IEFkZHJlc3M0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXB2NC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ip-address/dist/ipv4.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ip-address/dist/ipv6.js":
/*!**********************************************!*\
  !*** ./node_modules/ip-address/dist/ipv6.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/* eslint-disable prefer-destructuring */\n/* eslint-disable no-param-reassign */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Address6 = void 0;\nconst common = __importStar(__webpack_require__(/*! ./common */ \"(ssr)/./node_modules/ip-address/dist/common.js\"));\nconst constants4 = __importStar(__webpack_require__(/*! ./v4/constants */ \"(ssr)/./node_modules/ip-address/dist/v4/constants.js\"));\nconst constants6 = __importStar(__webpack_require__(/*! ./v6/constants */ \"(ssr)/./node_modules/ip-address/dist/v6/constants.js\"));\nconst helpers = __importStar(__webpack_require__(/*! ./v6/helpers */ \"(ssr)/./node_modules/ip-address/dist/v6/helpers.js\"));\nconst ipv4_1 = __webpack_require__(/*! ./ipv4 */ \"(ssr)/./node_modules/ip-address/dist/ipv4.js\");\nconst regular_expressions_1 = __webpack_require__(/*! ./v6/regular-expressions */ \"(ssr)/./node_modules/ip-address/dist/v6/regular-expressions.js\");\nconst address_error_1 = __webpack_require__(/*! ./address-error */ \"(ssr)/./node_modules/ip-address/dist/address-error.js\");\nconst common_1 = __webpack_require__(/*! ./common */ \"(ssr)/./node_modules/ip-address/dist/common.js\");\nfunction assert(condition) {\n    if (!condition) {\n        throw new Error('Assertion failed.');\n    }\n}\nfunction addCommas(number) {\n    const r = /(\\d+)(\\d{3})/;\n    while (r.test(number)) {\n        number = number.replace(r, '$1,$2');\n    }\n    return number;\n}\nfunction spanLeadingZeroes4(n) {\n    n = n.replace(/^(0{1,})([1-9]+)$/, '<span class=\"parse-error\">$1</span>$2');\n    n = n.replace(/^(0{1,})(0)$/, '<span class=\"parse-error\">$1</span>$2');\n    return n;\n}\n/*\n * A helper function to compact an array\n */\nfunction compact(address, slice) {\n    const s1 = [];\n    const s2 = [];\n    let i;\n    for (i = 0; i < address.length; i++) {\n        if (i < slice[0]) {\n            s1.push(address[i]);\n        }\n        else if (i > slice[1]) {\n            s2.push(address[i]);\n        }\n    }\n    return s1.concat(['compact']).concat(s2);\n}\nfunction paddedHex(octet) {\n    return parseInt(octet, 16).toString(16).padStart(4, '0');\n}\nfunction unsignByte(b) {\n    // eslint-disable-next-line no-bitwise\n    return b & 0xff;\n}\n/**\n * Represents an IPv6 address\n * @class Address6\n * @param {string} address - An IPv6 address string\n * @param {number} [groups=8] - How many octets to parse\n * @example\n * var address = new Address6('2001::/32');\n */\nclass Address6 {\n    constructor(address, optionalGroups) {\n        this.addressMinusSuffix = '';\n        this.parsedSubnet = '';\n        this.subnet = '/128';\n        this.subnetMask = 128;\n        this.v4 = false;\n        this.zone = '';\n        // #region Attributes\n        /**\n         * Returns true if the given address is in the subnet of the current address\n         * @memberof Address6\n         * @instance\n         * @returns {boolean}\n         */\n        this.isInSubnet = common.isInSubnet;\n        /**\n         * Returns true if the address is correct, false otherwise\n         * @memberof Address6\n         * @instance\n         * @returns {boolean}\n         */\n        this.isCorrect = common.isCorrect(constants6.BITS);\n        if (optionalGroups === undefined) {\n            this.groups = constants6.GROUPS;\n        }\n        else {\n            this.groups = optionalGroups;\n        }\n        this.address = address;\n        const subnet = constants6.RE_SUBNET_STRING.exec(address);\n        if (subnet) {\n            this.parsedSubnet = subnet[0].replace('/', '');\n            this.subnetMask = parseInt(this.parsedSubnet, 10);\n            this.subnet = `/${this.subnetMask}`;\n            if (Number.isNaN(this.subnetMask) ||\n                this.subnetMask < 0 ||\n                this.subnetMask > constants6.BITS) {\n                throw new address_error_1.AddressError('Invalid subnet mask.');\n            }\n            address = address.replace(constants6.RE_SUBNET_STRING, '');\n        }\n        else if (/\\//.test(address)) {\n            throw new address_error_1.AddressError('Invalid subnet mask.');\n        }\n        const zone = constants6.RE_ZONE_STRING.exec(address);\n        if (zone) {\n            this.zone = zone[0];\n            address = address.replace(constants6.RE_ZONE_STRING, '');\n        }\n        this.addressMinusSuffix = address;\n        this.parsedAddress = this.parse(this.addressMinusSuffix);\n    }\n    static isValid(address) {\n        try {\n            // eslint-disable-next-line no-new\n            new Address6(address);\n            return true;\n        }\n        catch (e) {\n            return false;\n        }\n    }\n    /**\n     * Convert a BigInt to a v6 address object\n     * @memberof Address6\n     * @static\n     * @param {bigint} bigInt - a BigInt to convert\n     * @returns {Address6}\n     * @example\n     * var bigInt = BigInt('1000000000000');\n     * var address = Address6.fromBigInt(bigInt);\n     * address.correctForm(); // '::e8:d4a5:1000'\n     */\n    static fromBigInt(bigInt) {\n        const hex = bigInt.toString(16).padStart(32, '0');\n        const groups = [];\n        let i;\n        for (i = 0; i < constants6.GROUPS; i++) {\n            groups.push(hex.slice(i * 4, (i + 1) * 4));\n        }\n        return new Address6(groups.join(':'));\n    }\n    /**\n     * Convert a URL (with optional port number) to an address object\n     * @memberof Address6\n     * @static\n     * @param {string} url - a URL with optional port number\n     * @example\n     * var addressAndPort = Address6.fromURL('http://[ffff::]:8080/foo/');\n     * addressAndPort.address.correctForm(); // 'ffff::'\n     * addressAndPort.port; // 8080\n     */\n    static fromURL(url) {\n        let host;\n        let port = null;\n        let result;\n        // If we have brackets parse them and find a port\n        if (url.indexOf('[') !== -1 && url.indexOf(']:') !== -1) {\n            result = constants6.RE_URL_WITH_PORT.exec(url);\n            if (result === null) {\n                return {\n                    error: 'failed to parse address with port',\n                    address: null,\n                    port: null,\n                };\n            }\n            host = result[1];\n            port = result[2];\n            // If there's a URL extract the address\n        }\n        else if (url.indexOf('/') !== -1) {\n            // Remove the protocol prefix\n            url = url.replace(/^[a-z0-9]+:\\/\\//, '');\n            // Parse the address\n            result = constants6.RE_URL.exec(url);\n            if (result === null) {\n                return {\n                    error: 'failed to parse address from URL',\n                    address: null,\n                    port: null,\n                };\n            }\n            host = result[1];\n            // Otherwise just assign the URL to the host and let the library parse it\n        }\n        else {\n            host = url;\n        }\n        // If there's a port convert it to an integer\n        if (port) {\n            port = parseInt(port, 10);\n            // squelch out of range ports\n            if (port < 0 || port > 65536) {\n                port = null;\n            }\n        }\n        else {\n            // Standardize `undefined` to `null`\n            port = null;\n        }\n        return {\n            address: new Address6(host),\n            port,\n        };\n    }\n    /**\n     * Create an IPv6-mapped address given an IPv4 address\n     * @memberof Address6\n     * @static\n     * @param {string} address - An IPv4 address string\n     * @returns {Address6}\n     * @example\n     * var address = Address6.fromAddress4('192.168.0.1');\n     * address.correctForm(); // '::ffff:c0a8:1'\n     * address.to4in6(); // '::ffff:192.168.0.1'\n     */\n    static fromAddress4(address) {\n        const address4 = new ipv4_1.Address4(address);\n        const mask6 = constants6.BITS - (constants4.BITS - address4.subnetMask);\n        return new Address6(`::ffff:${address4.correctForm()}/${mask6}`);\n    }\n    /**\n     * Return an address from ip6.arpa form\n     * @memberof Address6\n     * @static\n     * @param {string} arpaFormAddress - an 'ip6.arpa' form address\n     * @returns {Adress6}\n     * @example\n     * var address = Address6.fromArpa(e.f.f.f.3.c.2.6.f.f.f.e.6.6.8.e.1.0.6.7.9.4.e.c.0.0.0.0.1.0.0.2.ip6.arpa.)\n     * address.correctForm(); // '2001:0:ce49:7601:e866:efff:62c3:fffe'\n     */\n    static fromArpa(arpaFormAddress) {\n        // remove ending \".ip6.arpa.\" or just \".\"\n        let address = arpaFormAddress.replace(/(\\.ip6\\.arpa)?\\.$/, '');\n        const semicolonAmount = 7;\n        // correct ip6.arpa form with ending removed will be 63 characters\n        if (address.length !== 63) {\n            throw new address_error_1.AddressError(\"Invalid 'ip6.arpa' form.\");\n        }\n        const parts = address.split('.').reverse();\n        for (let i = semicolonAmount; i > 0; i--) {\n            const insertIndex = i * 4;\n            parts.splice(insertIndex, 0, ':');\n        }\n        address = parts.join('');\n        return new Address6(address);\n    }\n    /**\n     * Return the Microsoft UNC transcription of the address\n     * @memberof Address6\n     * @instance\n     * @returns {String} the Microsoft UNC transcription of the address\n     */\n    microsoftTranscription() {\n        return `${this.correctForm().replace(/:/g, '-')}.ipv6-literal.net`;\n    }\n    /**\n     * Return the first n bits of the address, defaulting to the subnet mask\n     * @memberof Address6\n     * @instance\n     * @param {number} [mask=subnet] - the number of bits to mask\n     * @returns {String} the first n bits of the address as a string\n     */\n    mask(mask = this.subnetMask) {\n        return this.getBitsBase2(0, mask);\n    }\n    /**\n     * Return the number of possible subnets of a given size in the address\n     * @memberof Address6\n     * @instance\n     * @param {number} [subnetSize=128] - the subnet size\n     * @returns {String}\n     */\n    // TODO: probably useful to have a numeric version of this too\n    possibleSubnets(subnetSize = 128) {\n        const availableBits = constants6.BITS - this.subnetMask;\n        const subnetBits = Math.abs(subnetSize - constants6.BITS);\n        const subnetPowers = availableBits - subnetBits;\n        if (subnetPowers < 0) {\n            return '0';\n        }\n        return addCommas((BigInt('2') ** BigInt(subnetPowers)).toString(10));\n    }\n    /**\n     * Helper function getting start address.\n     * @memberof Address6\n     * @instance\n     * @returns {bigint}\n     */\n    _startAddress() {\n        return BigInt(`0b${this.mask() + '0'.repeat(constants6.BITS - this.subnetMask)}`);\n    }\n    /**\n     * The first address in the range given by this address' subnet\n     * Often referred to as the Network Address.\n     * @memberof Address6\n     * @instance\n     * @returns {Address6}\n     */\n    startAddress() {\n        return Address6.fromBigInt(this._startAddress());\n    }\n    /**\n     * The first host address in the range given by this address's subnet ie\n     * the first address after the Network Address\n     * @memberof Address6\n     * @instance\n     * @returns {Address6}\n     */\n    startAddressExclusive() {\n        const adjust = BigInt('1');\n        return Address6.fromBigInt(this._startAddress() + adjust);\n    }\n    /**\n     * Helper function getting end address.\n     * @memberof Address6\n     * @instance\n     * @returns {bigint}\n     */\n    _endAddress() {\n        return BigInt(`0b${this.mask() + '1'.repeat(constants6.BITS - this.subnetMask)}`);\n    }\n    /**\n     * The last address in the range given by this address' subnet\n     * Often referred to as the Broadcast\n     * @memberof Address6\n     * @instance\n     * @returns {Address6}\n     */\n    endAddress() {\n        return Address6.fromBigInt(this._endAddress());\n    }\n    /**\n     * The last host address in the range given by this address's subnet ie\n     * the last address prior to the Broadcast Address\n     * @memberof Address6\n     * @instance\n     * @returns {Address6}\n     */\n    endAddressExclusive() {\n        const adjust = BigInt('1');\n        return Address6.fromBigInt(this._endAddress() - adjust);\n    }\n    /**\n     * Return the scope of the address\n     * @memberof Address6\n     * @instance\n     * @returns {String}\n     */\n    getScope() {\n        let scope = constants6.SCOPES[parseInt(this.getBits(12, 16).toString(10), 10)];\n        if (this.getType() === 'Global unicast' && scope !== 'Link local') {\n            scope = 'Global';\n        }\n        return scope || 'Unknown';\n    }\n    /**\n     * Return the type of the address\n     * @memberof Address6\n     * @instance\n     * @returns {String}\n     */\n    getType() {\n        for (const subnet of Object.keys(constants6.TYPES)) {\n            if (this.isInSubnet(new Address6(subnet))) {\n                return constants6.TYPES[subnet];\n            }\n        }\n        return 'Global unicast';\n    }\n    /**\n     * Return the bits in the given range as a BigInt\n     * @memberof Address6\n     * @instance\n     * @returns {bigint}\n     */\n    getBits(start, end) {\n        return BigInt(`0b${this.getBitsBase2(start, end)}`);\n    }\n    /**\n     * Return the bits in the given range as a base-2 string\n     * @memberof Address6\n     * @instance\n     * @returns {String}\n     */\n    getBitsBase2(start, end) {\n        return this.binaryZeroPad().slice(start, end);\n    }\n    /**\n     * Return the bits in the given range as a base-16 string\n     * @memberof Address6\n     * @instance\n     * @returns {String}\n     */\n    getBitsBase16(start, end) {\n        const length = end - start;\n        if (length % 4 !== 0) {\n            throw new Error('Length of bits to retrieve must be divisible by four');\n        }\n        return this.getBits(start, end)\n            .toString(16)\n            .padStart(length / 4, '0');\n    }\n    /**\n     * Return the bits that are set past the subnet mask length\n     * @memberof Address6\n     * @instance\n     * @returns {String}\n     */\n    getBitsPastSubnet() {\n        return this.getBitsBase2(this.subnetMask, constants6.BITS);\n    }\n    /**\n     * Return the reversed ip6.arpa form of the address\n     * @memberof Address6\n     * @param {Object} options\n     * @param {boolean} options.omitSuffix - omit the \"ip6.arpa\" suffix\n     * @instance\n     * @returns {String}\n     */\n    reverseForm(options) {\n        if (!options) {\n            options = {};\n        }\n        const characters = Math.floor(this.subnetMask / 4);\n        const reversed = this.canonicalForm()\n            .replace(/:/g, '')\n            .split('')\n            .slice(0, characters)\n            .reverse()\n            .join('.');\n        if (characters > 0) {\n            if (options.omitSuffix) {\n                return reversed;\n            }\n            return `${reversed}.ip6.arpa.`;\n        }\n        if (options.omitSuffix) {\n            return '';\n        }\n        return 'ip6.arpa.';\n    }\n    /**\n     * Return the correct form of the address\n     * @memberof Address6\n     * @instance\n     * @returns {String}\n     */\n    correctForm() {\n        let i;\n        let groups = [];\n        let zeroCounter = 0;\n        const zeroes = [];\n        for (i = 0; i < this.parsedAddress.length; i++) {\n            const value = parseInt(this.parsedAddress[i], 16);\n            if (value === 0) {\n                zeroCounter++;\n            }\n            if (value !== 0 && zeroCounter > 0) {\n                if (zeroCounter > 1) {\n                    zeroes.push([i - zeroCounter, i - 1]);\n                }\n                zeroCounter = 0;\n            }\n        }\n        // Do we end with a string of zeroes?\n        if (zeroCounter > 1) {\n            zeroes.push([this.parsedAddress.length - zeroCounter, this.parsedAddress.length - 1]);\n        }\n        const zeroLengths = zeroes.map((n) => n[1] - n[0] + 1);\n        if (zeroes.length > 0) {\n            const index = zeroLengths.indexOf(Math.max(...zeroLengths));\n            groups = compact(this.parsedAddress, zeroes[index]);\n        }\n        else {\n            groups = this.parsedAddress;\n        }\n        for (i = 0; i < groups.length; i++) {\n            if (groups[i] !== 'compact') {\n                groups[i] = parseInt(groups[i], 16).toString(16);\n            }\n        }\n        let correct = groups.join(':');\n        correct = correct.replace(/^compact$/, '::');\n        correct = correct.replace(/(^compact)|(compact$)/, ':');\n        correct = correct.replace(/compact/, '');\n        return correct;\n    }\n    /**\n     * Return a zero-padded base-2 string representation of the address\n     * @memberof Address6\n     * @instance\n     * @returns {String}\n     * @example\n     * var address = new Address6('2001:4860:4001:803::1011');\n     * address.binaryZeroPad();\n     * // '0010000000000001010010000110000001000000000000010000100000000011\n     * //  0000000000000000000000000000000000000000000000000001000000010001'\n     */\n    binaryZeroPad() {\n        return this.bigInt().toString(2).padStart(constants6.BITS, '0');\n    }\n    // TODO: Improve the semantics of this helper function\n    parse4in6(address) {\n        const groups = address.split(':');\n        const lastGroup = groups.slice(-1)[0];\n        const address4 = lastGroup.match(constants4.RE_ADDRESS);\n        if (address4) {\n            this.parsedAddress4 = address4[0];\n            this.address4 = new ipv4_1.Address4(this.parsedAddress4);\n            for (let i = 0; i < this.address4.groups; i++) {\n                if (/^0[0-9]+/.test(this.address4.parsedAddress[i])) {\n                    throw new address_error_1.AddressError(\"IPv4 addresses can't have leading zeroes.\", address.replace(constants4.RE_ADDRESS, this.address4.parsedAddress.map(spanLeadingZeroes4).join('.')));\n                }\n            }\n            this.v4 = true;\n            groups[groups.length - 1] = this.address4.toGroup6();\n            address = groups.join(':');\n        }\n        return address;\n    }\n    // TODO: Make private?\n    parse(address) {\n        address = this.parse4in6(address);\n        const badCharacters = address.match(constants6.RE_BAD_CHARACTERS);\n        if (badCharacters) {\n            throw new address_error_1.AddressError(`Bad character${badCharacters.length > 1 ? 's' : ''} detected in address: ${badCharacters.join('')}`, address.replace(constants6.RE_BAD_CHARACTERS, '<span class=\"parse-error\">$1</span>'));\n        }\n        const badAddress = address.match(constants6.RE_BAD_ADDRESS);\n        if (badAddress) {\n            throw new address_error_1.AddressError(`Address failed regex: ${badAddress.join('')}`, address.replace(constants6.RE_BAD_ADDRESS, '<span class=\"parse-error\">$1</span>'));\n        }\n        let groups = [];\n        const halves = address.split('::');\n        if (halves.length === 2) {\n            let first = halves[0].split(':');\n            let last = halves[1].split(':');\n            if (first.length === 1 && first[0] === '') {\n                first = [];\n            }\n            if (last.length === 1 && last[0] === '') {\n                last = [];\n            }\n            const remaining = this.groups - (first.length + last.length);\n            if (!remaining) {\n                throw new address_error_1.AddressError('Error parsing groups');\n            }\n            this.elidedGroups = remaining;\n            this.elisionBegin = first.length;\n            this.elisionEnd = first.length + this.elidedGroups;\n            groups = groups.concat(first);\n            for (let i = 0; i < remaining; i++) {\n                groups.push('0');\n            }\n            groups = groups.concat(last);\n        }\n        else if (halves.length === 1) {\n            groups = address.split(':');\n            this.elidedGroups = 0;\n        }\n        else {\n            throw new address_error_1.AddressError('Too many :: groups found');\n        }\n        groups = groups.map((group) => parseInt(group, 16).toString(16));\n        if (groups.length !== this.groups) {\n            throw new address_error_1.AddressError('Incorrect number of groups found');\n        }\n        return groups;\n    }\n    /**\n     * Return the canonical form of the address\n     * @memberof Address6\n     * @instance\n     * @returns {String}\n     */\n    canonicalForm() {\n        return this.parsedAddress.map(paddedHex).join(':');\n    }\n    /**\n     * Return the decimal form of the address\n     * @memberof Address6\n     * @instance\n     * @returns {String}\n     */\n    decimal() {\n        return this.parsedAddress.map((n) => parseInt(n, 16).toString(10).padStart(5, '0')).join(':');\n    }\n    /**\n     * Return the address as a BigInt\n     * @memberof Address6\n     * @instance\n     * @returns {bigint}\n     */\n    bigInt() {\n        return BigInt(`0x${this.parsedAddress.map(paddedHex).join('')}`);\n    }\n    /**\n     * Return the last two groups of this address as an IPv4 address string\n     * @memberof Address6\n     * @instance\n     * @returns {Address4}\n     * @example\n     * var address = new Address6('2001:4860:4001::1825:bf11');\n     * address.to4().correctForm(); // '24.37.191.17'\n     */\n    to4() {\n        const binary = this.binaryZeroPad().split('');\n        return ipv4_1.Address4.fromHex(BigInt(`0b${binary.slice(96, 128).join('')}`).toString(16));\n    }\n    /**\n     * Return the v4-in-v6 form of the address\n     * @memberof Address6\n     * @instance\n     * @returns {String}\n     */\n    to4in6() {\n        const address4 = this.to4();\n        const address6 = new Address6(this.parsedAddress.slice(0, 6).join(':'), 6);\n        const correct = address6.correctForm();\n        let infix = '';\n        if (!/:$/.test(correct)) {\n            infix = ':';\n        }\n        return correct + infix + address4.address;\n    }\n    /**\n     * Return an object containing the Teredo properties of the address\n     * @memberof Address6\n     * @instance\n     * @returns {Object}\n     */\n    inspectTeredo() {\n        /*\n        - Bits 0 to 31 are set to the Teredo prefix (normally 2001:0000::/32).\n        - Bits 32 to 63 embed the primary IPv4 address of the Teredo server that\n          is used.\n        - Bits 64 to 79 can be used to define some flags. Currently only the\n          higher order bit is used; it is set to 1 if the Teredo client is\n          located behind a cone NAT, 0 otherwise. For Microsoft's Windows Vista\n          and Windows Server 2008 implementations, more bits are used. In those\n          implementations, the format for these 16 bits is \"CRAAAAUG AAAAAAAA\",\n          where \"C\" remains the \"Cone\" flag. The \"R\" bit is reserved for future\n          use. The \"U\" bit is for the Universal/Local flag (set to 0). The \"G\" bit\n          is Individual/Group flag (set to 0). The A bits are set to a 12-bit\n          randomly generated number chosen by the Teredo client to introduce\n          additional protection for the Teredo node against IPv6-based scanning\n          attacks.\n        - Bits 80 to 95 contains the obfuscated UDP port number. This is the\n          port number that is mapped by the NAT to the Teredo client with all\n          bits inverted.\n        - Bits 96 to 127 contains the obfuscated IPv4 address. This is the\n          public IPv4 address of the NAT with all bits inverted.\n        */\n        const prefix = this.getBitsBase16(0, 32);\n        const bitsForUdpPort = this.getBits(80, 96);\n        // eslint-disable-next-line no-bitwise\n        const udpPort = (bitsForUdpPort ^ BigInt('0xffff')).toString();\n        const server4 = ipv4_1.Address4.fromHex(this.getBitsBase16(32, 64));\n        const bitsForClient4 = this.getBits(96, 128);\n        // eslint-disable-next-line no-bitwise\n        const client4 = ipv4_1.Address4.fromHex((bitsForClient4 ^ BigInt('0xffffffff')).toString(16));\n        const flagsBase2 = this.getBitsBase2(64, 80);\n        const coneNat = (0, common_1.testBit)(flagsBase2, 15);\n        const reserved = (0, common_1.testBit)(flagsBase2, 14);\n        const groupIndividual = (0, common_1.testBit)(flagsBase2, 8);\n        const universalLocal = (0, common_1.testBit)(flagsBase2, 9);\n        const nonce = BigInt(`0b${flagsBase2.slice(2, 6) + flagsBase2.slice(8, 16)}`).toString(10);\n        return {\n            prefix: `${prefix.slice(0, 4)}:${prefix.slice(4, 8)}`,\n            server4: server4.address,\n            client4: client4.address,\n            flags: flagsBase2,\n            coneNat,\n            microsoft: {\n                reserved,\n                universalLocal,\n                groupIndividual,\n                nonce,\n            },\n            udpPort,\n        };\n    }\n    /**\n     * Return an object containing the 6to4 properties of the address\n     * @memberof Address6\n     * @instance\n     * @returns {Object}\n     */\n    inspect6to4() {\n        /*\n        - Bits 0 to 15 are set to the 6to4 prefix (2002::/16).\n        - Bits 16 to 48 embed the IPv4 address of the 6to4 gateway that is used.\n        */\n        const prefix = this.getBitsBase16(0, 16);\n        const gateway = ipv4_1.Address4.fromHex(this.getBitsBase16(16, 48));\n        return {\n            prefix: prefix.slice(0, 4),\n            gateway: gateway.address,\n        };\n    }\n    /**\n     * Return a v6 6to4 address from a v6 v4inv6 address\n     * @memberof Address6\n     * @instance\n     * @returns {Address6}\n     */\n    to6to4() {\n        if (!this.is4()) {\n            return null;\n        }\n        const addr6to4 = [\n            '2002',\n            this.getBitsBase16(96, 112),\n            this.getBitsBase16(112, 128),\n            '',\n            '/16',\n        ].join(':');\n        return new Address6(addr6to4);\n    }\n    /**\n     * Return a byte array\n     * @memberof Address6\n     * @instance\n     * @returns {Array}\n     */\n    toByteArray() {\n        const valueWithoutPadding = this.bigInt().toString(16);\n        const leadingPad = '0'.repeat(valueWithoutPadding.length % 2);\n        const value = `${leadingPad}${valueWithoutPadding}`;\n        const bytes = [];\n        for (let i = 0, length = value.length; i < length; i += 2) {\n            bytes.push(parseInt(value.substring(i, i + 2), 16));\n        }\n        return bytes;\n    }\n    /**\n     * Return an unsigned byte array\n     * @memberof Address6\n     * @instance\n     * @returns {Array}\n     */\n    toUnsignedByteArray() {\n        return this.toByteArray().map(unsignByte);\n    }\n    /**\n     * Convert a byte array to an Address6 object\n     * @memberof Address6\n     * @static\n     * @returns {Address6}\n     */\n    static fromByteArray(bytes) {\n        return this.fromUnsignedByteArray(bytes.map(unsignByte));\n    }\n    /**\n     * Convert an unsigned byte array to an Address6 object\n     * @memberof Address6\n     * @static\n     * @returns {Address6}\n     */\n    static fromUnsignedByteArray(bytes) {\n        const BYTE_MAX = BigInt('256');\n        let result = BigInt('0');\n        let multiplier = BigInt('1');\n        for (let i = bytes.length - 1; i >= 0; i--) {\n            result += multiplier * BigInt(bytes[i].toString(10));\n            multiplier *= BYTE_MAX;\n        }\n        return Address6.fromBigInt(result);\n    }\n    /**\n     * Returns true if the address is in the canonical form, false otherwise\n     * @memberof Address6\n     * @instance\n     * @returns {boolean}\n     */\n    isCanonical() {\n        return this.addressMinusSuffix === this.canonicalForm();\n    }\n    /**\n     * Returns true if the address is a link local address, false otherwise\n     * @memberof Address6\n     * @instance\n     * @returns {boolean}\n     */\n    isLinkLocal() {\n        // Zeroes are required, i.e. we can't check isInSubnet with 'fe80::/10'\n        if (this.getBitsBase2(0, 64) ===\n            '1111111010000000000000000000000000000000000000000000000000000000') {\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Returns true if the address is a multicast address, false otherwise\n     * @memberof Address6\n     * @instance\n     * @returns {boolean}\n     */\n    isMulticast() {\n        return this.getType() === 'Multicast';\n    }\n    /**\n     * Returns true if the address is a v4-in-v6 address, false otherwise\n     * @memberof Address6\n     * @instance\n     * @returns {boolean}\n     */\n    is4() {\n        return this.v4;\n    }\n    /**\n     * Returns true if the address is a Teredo address, false otherwise\n     * @memberof Address6\n     * @instance\n     * @returns {boolean}\n     */\n    isTeredo() {\n        return this.isInSubnet(new Address6('2001::/32'));\n    }\n    /**\n     * Returns true if the address is a 6to4 address, false otherwise\n     * @memberof Address6\n     * @instance\n     * @returns {boolean}\n     */\n    is6to4() {\n        return this.isInSubnet(new Address6('2002::/16'));\n    }\n    /**\n     * Returns true if the address is a loopback address, false otherwise\n     * @memberof Address6\n     * @instance\n     * @returns {boolean}\n     */\n    isLoopback() {\n        return this.getType() === 'Loopback';\n    }\n    // #endregion\n    // #region HTML\n    /**\n     * @returns {String} the address in link form with a default port of 80\n     */\n    href(optionalPort) {\n        if (optionalPort === undefined) {\n            optionalPort = '';\n        }\n        else {\n            optionalPort = `:${optionalPort}`;\n        }\n        return `http://[${this.correctForm()}]${optionalPort}/`;\n    }\n    /**\n     * @returns {String} a link suitable for conveying the address via a URL hash\n     */\n    link(options) {\n        if (!options) {\n            options = {};\n        }\n        if (options.className === undefined) {\n            options.className = '';\n        }\n        if (options.prefix === undefined) {\n            options.prefix = '/#address=';\n        }\n        if (options.v4 === undefined) {\n            options.v4 = false;\n        }\n        let formFunction = this.correctForm;\n        if (options.v4) {\n            formFunction = this.to4in6;\n        }\n        const form = formFunction.call(this);\n        if (options.className) {\n            return `<a href=\"${options.prefix}${form}\" class=\"${options.className}\">${form}</a>`;\n        }\n        return `<a href=\"${options.prefix}${form}\">${form}</a>`;\n    }\n    /**\n     * Groups an address\n     * @returns {String}\n     */\n    group() {\n        if (this.elidedGroups === 0) {\n            // The simple case\n            return helpers.simpleGroup(this.address).join(':');\n        }\n        assert(typeof this.elidedGroups === 'number');\n        assert(typeof this.elisionBegin === 'number');\n        // The elided case\n        const output = [];\n        const [left, right] = this.address.split('::');\n        if (left.length) {\n            output.push(...helpers.simpleGroup(left));\n        }\n        else {\n            output.push('');\n        }\n        const classes = ['hover-group'];\n        for (let i = this.elisionBegin; i < this.elisionBegin + this.elidedGroups; i++) {\n            classes.push(`group-${i}`);\n        }\n        output.push(`<span class=\"${classes.join(' ')}\"></span>`);\n        if (right.length) {\n            output.push(...helpers.simpleGroup(right, this.elisionEnd));\n        }\n        else {\n            output.push('');\n        }\n        if (this.is4()) {\n            assert(this.address4 instanceof ipv4_1.Address4);\n            output.pop();\n            output.push(this.address4.groupForV6());\n        }\n        return output.join(':');\n    }\n    // #endregion\n    // #region Regular expressions\n    /**\n     * Generate a regular expression string that can be used to find or validate\n     * all variations of this address\n     * @memberof Address6\n     * @instance\n     * @param {boolean} substringSearch\n     * @returns {string}\n     */\n    regularExpressionString(substringSearch = false) {\n        let output = [];\n        // TODO: revisit why this is necessary\n        const address6 = new Address6(this.correctForm());\n        if (address6.elidedGroups === 0) {\n            // The simple case\n            output.push((0, regular_expressions_1.simpleRegularExpression)(address6.parsedAddress));\n        }\n        else if (address6.elidedGroups === constants6.GROUPS) {\n            // A completely elided address\n            output.push((0, regular_expressions_1.possibleElisions)(constants6.GROUPS));\n        }\n        else {\n            // A partially elided address\n            const halves = address6.address.split('::');\n            if (halves[0].length) {\n                output.push((0, regular_expressions_1.simpleRegularExpression)(halves[0].split(':')));\n            }\n            assert(typeof address6.elidedGroups === 'number');\n            output.push((0, regular_expressions_1.possibleElisions)(address6.elidedGroups, halves[0].length !== 0, halves[1].length !== 0));\n            if (halves[1].length) {\n                output.push((0, regular_expressions_1.simpleRegularExpression)(halves[1].split(':')));\n            }\n            output = [output.join(':')];\n        }\n        if (!substringSearch) {\n            output = [\n                '(?=^|',\n                regular_expressions_1.ADDRESS_BOUNDARY,\n                '|[^\\\\w\\\\:])(',\n                ...output,\n                ')(?=[^\\\\w\\\\:]|',\n                regular_expressions_1.ADDRESS_BOUNDARY,\n                '|$)',\n            ];\n        }\n        return output.join('');\n    }\n    /**\n     * Generate a regular expression that can be used to find or validate all\n     * variations of this address.\n     * @memberof Address6\n     * @instance\n     * @param {boolean} substringSearch\n     * @returns {RegExp}\n     */\n    regularExpression(substringSearch = false) {\n        return new RegExp(this.regularExpressionString(substringSearch), 'i');\n    }\n}\nexports.Address6 = Address6;\n//# sourceMappingURL=ipv6.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaXAtYWRkcmVzcy9kaXN0L2lwdjYuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSwwQ0FBMEMsNEJBQTRCO0FBQ3RFLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQkFBZ0I7QUFDaEIsNEJBQTRCLG1CQUFPLENBQUMsZ0VBQVU7QUFDOUMsZ0NBQWdDLG1CQUFPLENBQUMsNEVBQWdCO0FBQ3hELGdDQUFnQyxtQkFBTyxDQUFDLDRFQUFnQjtBQUN4RCw2QkFBNkIsbUJBQU8sQ0FBQyx3RUFBYztBQUNuRCxlQUFlLG1CQUFPLENBQUMsNERBQVE7QUFDL0IsOEJBQThCLG1CQUFPLENBQUMsZ0dBQTBCO0FBQ2hFLHdCQUF3QixtQkFBTyxDQUFDLDhFQUFpQjtBQUNqRCxpQkFBaUIsbUJBQU8sQ0FBQyxnRUFBVTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsRUFBRTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsR0FBRztBQUMxQix1QkFBdUIsR0FBRztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isb0JBQW9CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXFNpbXBsZVxcRG93bmxvYWRzXFxQcm95ZWN0b0V4dHJhY3RvckRlRmlsYW1lbnRvXFxleHRyYWN0b3Itc2VydmVyXFxub2RlX21vZHVsZXNcXGlwLWFkZHJlc3NcXGRpc3RcXGlwdjYuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKiBlc2xpbnQtZGlzYWJsZSBwcmVmZXItZGVzdHJ1Y3R1cmluZyAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tcGFyYW0tcmVhc3NpZ24gKi9cbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5BZGRyZXNzNiA9IHZvaWQgMDtcbmNvbnN0IGNvbW1vbiA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9jb21tb25cIikpO1xuY29uc3QgY29uc3RhbnRzNCA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi92NC9jb25zdGFudHNcIikpO1xuY29uc3QgY29uc3RhbnRzNiA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi92Ni9jb25zdGFudHNcIikpO1xuY29uc3QgaGVscGVycyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi92Ni9oZWxwZXJzXCIpKTtcbmNvbnN0IGlwdjRfMSA9IHJlcXVpcmUoXCIuL2lwdjRcIik7XG5jb25zdCByZWd1bGFyX2V4cHJlc3Npb25zXzEgPSByZXF1aXJlKFwiLi92Ni9yZWd1bGFyLWV4cHJlc3Npb25zXCIpO1xuY29uc3QgYWRkcmVzc19lcnJvcl8xID0gcmVxdWlyZShcIi4vYWRkcmVzcy1lcnJvclwiKTtcbmNvbnN0IGNvbW1vbl8xID0gcmVxdWlyZShcIi4vY29tbW9uXCIpO1xuZnVuY3Rpb24gYXNzZXJ0KGNvbmRpdGlvbikge1xuICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQXNzZXJ0aW9uIGZhaWxlZC4nKTtcbiAgICB9XG59XG5mdW5jdGlvbiBhZGRDb21tYXMobnVtYmVyKSB7XG4gICAgY29uc3QgciA9IC8oXFxkKykoXFxkezN9KS87XG4gICAgd2hpbGUgKHIudGVzdChudW1iZXIpKSB7XG4gICAgICAgIG51bWJlciA9IG51bWJlci5yZXBsYWNlKHIsICckMSwkMicpO1xuICAgIH1cbiAgICByZXR1cm4gbnVtYmVyO1xufVxuZnVuY3Rpb24gc3BhbkxlYWRpbmdaZXJvZXM0KG4pIHtcbiAgICBuID0gbi5yZXBsYWNlKC9eKDB7MSx9KShbMS05XSspJC8sICc8c3BhbiBjbGFzcz1cInBhcnNlLWVycm9yXCI+JDE8L3NwYW4+JDInKTtcbiAgICBuID0gbi5yZXBsYWNlKC9eKDB7MSx9KSgwKSQvLCAnPHNwYW4gY2xhc3M9XCJwYXJzZS1lcnJvclwiPiQxPC9zcGFuPiQyJyk7XG4gICAgcmV0dXJuIG47XG59XG4vKlxuICogQSBoZWxwZXIgZnVuY3Rpb24gdG8gY29tcGFjdCBhbiBhcnJheVxuICovXG5mdW5jdGlvbiBjb21wYWN0KGFkZHJlc3MsIHNsaWNlKSB7XG4gICAgY29uc3QgczEgPSBbXTtcbiAgICBjb25zdCBzMiA9IFtdO1xuICAgIGxldCBpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBhZGRyZXNzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpIDwgc2xpY2VbMF0pIHtcbiAgICAgICAgICAgIHMxLnB1c2goYWRkcmVzc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaSA+IHNsaWNlWzFdKSB7XG4gICAgICAgICAgICBzMi5wdXNoKGFkZHJlc3NbaV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzMS5jb25jYXQoWydjb21wYWN0J10pLmNvbmNhdChzMik7XG59XG5mdW5jdGlvbiBwYWRkZWRIZXgob2N0ZXQpIHtcbiAgICByZXR1cm4gcGFyc2VJbnQob2N0ZXQsIDE2KS50b1N0cmluZygxNikucGFkU3RhcnQoNCwgJzAnKTtcbn1cbmZ1bmN0aW9uIHVuc2lnbkJ5dGUoYikge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1iaXR3aXNlXG4gICAgcmV0dXJuIGIgJiAweGZmO1xufVxuLyoqXG4gKiBSZXByZXNlbnRzIGFuIElQdjYgYWRkcmVzc1xuICogQGNsYXNzIEFkZHJlc3M2XG4gKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzcyAtIEFuIElQdjYgYWRkcmVzcyBzdHJpbmdcbiAqIEBwYXJhbSB7bnVtYmVyfSBbZ3JvdXBzPThdIC0gSG93IG1hbnkgb2N0ZXRzIHRvIHBhcnNlXG4gKiBAZXhhbXBsZVxuICogdmFyIGFkZHJlc3MgPSBuZXcgQWRkcmVzczYoJzIwMDE6Oi8zMicpO1xuICovXG5jbGFzcyBBZGRyZXNzNiB7XG4gICAgY29uc3RydWN0b3IoYWRkcmVzcywgb3B0aW9uYWxHcm91cHMpIHtcbiAgICAgICAgdGhpcy5hZGRyZXNzTWludXNTdWZmaXggPSAnJztcbiAgICAgICAgdGhpcy5wYXJzZWRTdWJuZXQgPSAnJztcbiAgICAgICAgdGhpcy5zdWJuZXQgPSAnLzEyOCc7XG4gICAgICAgIHRoaXMuc3VibmV0TWFzayA9IDEyODtcbiAgICAgICAgdGhpcy52NCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnpvbmUgPSAnJztcbiAgICAgICAgLy8gI3JlZ2lvbiBBdHRyaWJ1dGVzXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIGFkZHJlc3MgaXMgaW4gdGhlIHN1Ym5ldCBvZiB0aGUgY3VycmVudCBhZGRyZXNzXG4gICAgICAgICAqIEBtZW1iZXJvZiBBZGRyZXNzNlxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmlzSW5TdWJuZXQgPSBjb21tb24uaXNJblN1Ym5ldDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgYWRkcmVzcyBpcyBjb3JyZWN0LCBmYWxzZSBvdGhlcndpc2VcbiAgICAgICAgICogQG1lbWJlcm9mIEFkZHJlc3M2XG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaXNDb3JyZWN0ID0gY29tbW9uLmlzQ29ycmVjdChjb25zdGFudHM2LkJJVFMpO1xuICAgICAgICBpZiAob3B0aW9uYWxHcm91cHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5ncm91cHMgPSBjb25zdGFudHM2LkdST1VQUztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzID0gb3B0aW9uYWxHcm91cHM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hZGRyZXNzID0gYWRkcmVzcztcbiAgICAgICAgY29uc3Qgc3VibmV0ID0gY29uc3RhbnRzNi5SRV9TVUJORVRfU1RSSU5HLmV4ZWMoYWRkcmVzcyk7XG4gICAgICAgIGlmIChzdWJuZXQpIHtcbiAgICAgICAgICAgIHRoaXMucGFyc2VkU3VibmV0ID0gc3VibmV0WzBdLnJlcGxhY2UoJy8nLCAnJyk7XG4gICAgICAgICAgICB0aGlzLnN1Ym5ldE1hc2sgPSBwYXJzZUludCh0aGlzLnBhcnNlZFN1Ym5ldCwgMTApO1xuICAgICAgICAgICAgdGhpcy5zdWJuZXQgPSBgLyR7dGhpcy5zdWJuZXRNYXNrfWA7XG4gICAgICAgICAgICBpZiAoTnVtYmVyLmlzTmFOKHRoaXMuc3VibmV0TWFzaykgfHxcbiAgICAgICAgICAgICAgICB0aGlzLnN1Ym5ldE1hc2sgPCAwIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5zdWJuZXRNYXNrID4gY29uc3RhbnRzNi5CSVRTKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGFkZHJlc3NfZXJyb3JfMS5BZGRyZXNzRXJyb3IoJ0ludmFsaWQgc3VibmV0IG1hc2suJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhZGRyZXNzID0gYWRkcmVzcy5yZXBsYWNlKGNvbnN0YW50czYuUkVfU1VCTkVUX1NUUklORywgJycpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKC9cXC8vLnRlc3QoYWRkcmVzcykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBhZGRyZXNzX2Vycm9yXzEuQWRkcmVzc0Vycm9yKCdJbnZhbGlkIHN1Ym5ldCBtYXNrLicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHpvbmUgPSBjb25zdGFudHM2LlJFX1pPTkVfU1RSSU5HLmV4ZWMoYWRkcmVzcyk7XG4gICAgICAgIGlmICh6b25lKSB7XG4gICAgICAgICAgICB0aGlzLnpvbmUgPSB6b25lWzBdO1xuICAgICAgICAgICAgYWRkcmVzcyA9IGFkZHJlc3MucmVwbGFjZShjb25zdGFudHM2LlJFX1pPTkVfU1RSSU5HLCAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hZGRyZXNzTWludXNTdWZmaXggPSBhZGRyZXNzO1xuICAgICAgICB0aGlzLnBhcnNlZEFkZHJlc3MgPSB0aGlzLnBhcnNlKHRoaXMuYWRkcmVzc01pbnVzU3VmZml4KTtcbiAgICB9XG4gICAgc3RhdGljIGlzVmFsaWQoYWRkcmVzcykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ld1xuICAgICAgICAgICAgbmV3IEFkZHJlc3M2KGFkZHJlc3MpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IGEgQmlnSW50IHRvIGEgdjYgYWRkcmVzcyBvYmplY3RcbiAgICAgKiBAbWVtYmVyb2YgQWRkcmVzczZcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtiaWdpbnR9IGJpZ0ludCAtIGEgQmlnSW50IHRvIGNvbnZlcnRcbiAgICAgKiBAcmV0dXJucyB7QWRkcmVzczZ9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB2YXIgYmlnSW50ID0gQmlnSW50KCcxMDAwMDAwMDAwMDAwJyk7XG4gICAgICogdmFyIGFkZHJlc3MgPSBBZGRyZXNzNi5mcm9tQmlnSW50KGJpZ0ludCk7XG4gICAgICogYWRkcmVzcy5jb3JyZWN0Rm9ybSgpOyAvLyAnOjplODpkNGE1OjEwMDAnXG4gICAgICovXG4gICAgc3RhdGljIGZyb21CaWdJbnQoYmlnSW50KSB7XG4gICAgICAgIGNvbnN0IGhleCA9IGJpZ0ludC50b1N0cmluZygxNikucGFkU3RhcnQoMzIsICcwJyk7XG4gICAgICAgIGNvbnN0IGdyb3VwcyA9IFtdO1xuICAgICAgICBsZXQgaTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvbnN0YW50czYuR1JPVVBTOyBpKyspIHtcbiAgICAgICAgICAgIGdyb3Vwcy5wdXNoKGhleC5zbGljZShpICogNCwgKGkgKyAxKSAqIDQpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEFkZHJlc3M2KGdyb3Vwcy5qb2luKCc6JykpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IGEgVVJMICh3aXRoIG9wdGlvbmFsIHBvcnQgbnVtYmVyKSB0byBhbiBhZGRyZXNzIG9iamVjdFxuICAgICAqIEBtZW1iZXJvZiBBZGRyZXNzNlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsIC0gYSBVUkwgd2l0aCBvcHRpb25hbCBwb3J0IG51bWJlclxuICAgICAqIEBleGFtcGxlXG4gICAgICogdmFyIGFkZHJlc3NBbmRQb3J0ID0gQWRkcmVzczYuZnJvbVVSTCgnaHR0cDovL1tmZmZmOjpdOjgwODAvZm9vLycpO1xuICAgICAqIGFkZHJlc3NBbmRQb3J0LmFkZHJlc3MuY29ycmVjdEZvcm0oKTsgLy8gJ2ZmZmY6OidcbiAgICAgKiBhZGRyZXNzQW5kUG9ydC5wb3J0OyAvLyA4MDgwXG4gICAgICovXG4gICAgc3RhdGljIGZyb21VUkwodXJsKSB7XG4gICAgICAgIGxldCBob3N0O1xuICAgICAgICBsZXQgcG9ydCA9IG51bGw7XG4gICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgIC8vIElmIHdlIGhhdmUgYnJhY2tldHMgcGFyc2UgdGhlbSBhbmQgZmluZCBhIHBvcnRcbiAgICAgICAgaWYgKHVybC5pbmRleE9mKCdbJykgIT09IC0xICYmIHVybC5pbmRleE9mKCddOicpICE9PSAtMSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gY29uc3RhbnRzNi5SRV9VUkxfV0lUSF9QT1JULmV4ZWModXJsKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBlcnJvcjogJ2ZhaWxlZCB0byBwYXJzZSBhZGRyZXNzIHdpdGggcG9ydCcsXG4gICAgICAgICAgICAgICAgICAgIGFkZHJlc3M6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHBvcnQ6IG51bGwsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhvc3QgPSByZXN1bHRbMV07XG4gICAgICAgICAgICBwb3J0ID0gcmVzdWx0WzJdO1xuICAgICAgICAgICAgLy8gSWYgdGhlcmUncyBhIFVSTCBleHRyYWN0IHRoZSBhZGRyZXNzXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodXJsLmluZGV4T2YoJy8nKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgcHJvdG9jb2wgcHJlZml4XG4gICAgICAgICAgICB1cmwgPSB1cmwucmVwbGFjZSgvXlthLXowLTldKzpcXC9cXC8vLCAnJyk7XG4gICAgICAgICAgICAvLyBQYXJzZSB0aGUgYWRkcmVzc1xuICAgICAgICAgICAgcmVzdWx0ID0gY29uc3RhbnRzNi5SRV9VUkwuZXhlYyh1cmwpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiAnZmFpbGVkIHRvIHBhcnNlIGFkZHJlc3MgZnJvbSBVUkwnLFxuICAgICAgICAgICAgICAgICAgICBhZGRyZXNzOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBwb3J0OiBudWxsLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBob3N0ID0gcmVzdWx0WzFdO1xuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIGp1c3QgYXNzaWduIHRoZSBVUkwgdG8gdGhlIGhvc3QgYW5kIGxldCB0aGUgbGlicmFyeSBwYXJzZSBpdFxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaG9zdCA9IHVybDtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGVyZSdzIGEgcG9ydCBjb252ZXJ0IGl0IHRvIGFuIGludGVnZXJcbiAgICAgICAgaWYgKHBvcnQpIHtcbiAgICAgICAgICAgIHBvcnQgPSBwYXJzZUludChwb3J0LCAxMCk7XG4gICAgICAgICAgICAvLyBzcXVlbGNoIG91dCBvZiByYW5nZSBwb3J0c1xuICAgICAgICAgICAgaWYgKHBvcnQgPCAwIHx8IHBvcnQgPiA2NTUzNikge1xuICAgICAgICAgICAgICAgIHBvcnQgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gU3RhbmRhcmRpemUgYHVuZGVmaW5lZGAgdG8gYG51bGxgXG4gICAgICAgICAgICBwb3J0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYWRkcmVzczogbmV3IEFkZHJlc3M2KGhvc3QpLFxuICAgICAgICAgICAgcG9ydCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGFuIElQdjYtbWFwcGVkIGFkZHJlc3MgZ2l2ZW4gYW4gSVB2NCBhZGRyZXNzXG4gICAgICogQG1lbWJlcm9mIEFkZHJlc3M2XG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzIC0gQW4gSVB2NCBhZGRyZXNzIHN0cmluZ1xuICAgICAqIEByZXR1cm5zIHtBZGRyZXNzNn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHZhciBhZGRyZXNzID0gQWRkcmVzczYuZnJvbUFkZHJlc3M0KCcxOTIuMTY4LjAuMScpO1xuICAgICAqIGFkZHJlc3MuY29ycmVjdEZvcm0oKTsgLy8gJzo6ZmZmZjpjMGE4OjEnXG4gICAgICogYWRkcmVzcy50bzRpbjYoKTsgLy8gJzo6ZmZmZjoxOTIuMTY4LjAuMSdcbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbUFkZHJlc3M0KGFkZHJlc3MpIHtcbiAgICAgICAgY29uc3QgYWRkcmVzczQgPSBuZXcgaXB2NF8xLkFkZHJlc3M0KGFkZHJlc3MpO1xuICAgICAgICBjb25zdCBtYXNrNiA9IGNvbnN0YW50czYuQklUUyAtIChjb25zdGFudHM0LkJJVFMgLSBhZGRyZXNzNC5zdWJuZXRNYXNrKTtcbiAgICAgICAgcmV0dXJuIG5ldyBBZGRyZXNzNihgOjpmZmZmOiR7YWRkcmVzczQuY29ycmVjdEZvcm0oKX0vJHttYXNrNn1gKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGFuIGFkZHJlc3MgZnJvbSBpcDYuYXJwYSBmb3JtXG4gICAgICogQG1lbWJlcm9mIEFkZHJlc3M2XG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhcnBhRm9ybUFkZHJlc3MgLSBhbiAnaXA2LmFycGEnIGZvcm0gYWRkcmVzc1xuICAgICAqIEByZXR1cm5zIHtBZHJlc3M2fVxuICAgICAqIEBleGFtcGxlXG4gICAgICogdmFyIGFkZHJlc3MgPSBBZGRyZXNzNi5mcm9tQXJwYShlLmYuZi5mLjMuYy4yLjYuZi5mLmYuZS42LjYuOC5lLjEuMC42LjcuOS40LmUuYy4wLjAuMC4wLjEuMC4wLjIuaXA2LmFycGEuKVxuICAgICAqIGFkZHJlc3MuY29ycmVjdEZvcm0oKTsgLy8gJzIwMDE6MDpjZTQ5Ojc2MDE6ZTg2NjplZmZmOjYyYzM6ZmZmZSdcbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbUFycGEoYXJwYUZvcm1BZGRyZXNzKSB7XG4gICAgICAgIC8vIHJlbW92ZSBlbmRpbmcgXCIuaXA2LmFycGEuXCIgb3IganVzdCBcIi5cIlxuICAgICAgICBsZXQgYWRkcmVzcyA9IGFycGFGb3JtQWRkcmVzcy5yZXBsYWNlKC8oXFwuaXA2XFwuYXJwYSk/XFwuJC8sICcnKTtcbiAgICAgICAgY29uc3Qgc2VtaWNvbG9uQW1vdW50ID0gNztcbiAgICAgICAgLy8gY29ycmVjdCBpcDYuYXJwYSBmb3JtIHdpdGggZW5kaW5nIHJlbW92ZWQgd2lsbCBiZSA2MyBjaGFyYWN0ZXJzXG4gICAgICAgIGlmIChhZGRyZXNzLmxlbmd0aCAhPT0gNjMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBhZGRyZXNzX2Vycm9yXzEuQWRkcmVzc0Vycm9yKFwiSW52YWxpZCAnaXA2LmFycGEnIGZvcm0uXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcnRzID0gYWRkcmVzcy5zcGxpdCgnLicpLnJldmVyc2UoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHNlbWljb2xvbkFtb3VudDsgaSA+IDA7IGktLSkge1xuICAgICAgICAgICAgY29uc3QgaW5zZXJ0SW5kZXggPSBpICogNDtcbiAgICAgICAgICAgIHBhcnRzLnNwbGljZShpbnNlcnRJbmRleCwgMCwgJzonKTtcbiAgICAgICAgfVxuICAgICAgICBhZGRyZXNzID0gcGFydHMuam9pbignJyk7XG4gICAgICAgIHJldHVybiBuZXcgQWRkcmVzczYoYWRkcmVzcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgTWljcm9zb2Z0IFVOQyB0cmFuc2NyaXB0aW9uIG9mIHRoZSBhZGRyZXNzXG4gICAgICogQG1lbWJlcm9mIEFkZHJlc3M2XG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHJldHVybnMge1N0cmluZ30gdGhlIE1pY3Jvc29mdCBVTkMgdHJhbnNjcmlwdGlvbiBvZiB0aGUgYWRkcmVzc1xuICAgICAqL1xuICAgIG1pY3Jvc29mdFRyYW5zY3JpcHRpb24oKSB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmNvcnJlY3RGb3JtKCkucmVwbGFjZSgvOi9nLCAnLScpfS5pcHY2LWxpdGVyYWwubmV0YDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBmaXJzdCBuIGJpdHMgb2YgdGhlIGFkZHJlc3MsIGRlZmF1bHRpbmcgdG8gdGhlIHN1Ym5ldCBtYXNrXG4gICAgICogQG1lbWJlcm9mIEFkZHJlc3M2XG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFttYXNrPXN1Ym5ldF0gLSB0aGUgbnVtYmVyIG9mIGJpdHMgdG8gbWFza1xuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IHRoZSBmaXJzdCBuIGJpdHMgb2YgdGhlIGFkZHJlc3MgYXMgYSBzdHJpbmdcbiAgICAgKi9cbiAgICBtYXNrKG1hc2sgPSB0aGlzLnN1Ym5ldE1hc2spIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Qml0c0Jhc2UyKDAsIG1hc2spO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIG51bWJlciBvZiBwb3NzaWJsZSBzdWJuZXRzIG9mIGEgZ2l2ZW4gc2l6ZSBpbiB0aGUgYWRkcmVzc1xuICAgICAqIEBtZW1iZXJvZiBBZGRyZXNzNlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3VibmV0U2l6ZT0xMjhdIC0gdGhlIHN1Ym5ldCBzaXplXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICAvLyBUT0RPOiBwcm9iYWJseSB1c2VmdWwgdG8gaGF2ZSBhIG51bWVyaWMgdmVyc2lvbiBvZiB0aGlzIHRvb1xuICAgIHBvc3NpYmxlU3VibmV0cyhzdWJuZXRTaXplID0gMTI4KSB7XG4gICAgICAgIGNvbnN0IGF2YWlsYWJsZUJpdHMgPSBjb25zdGFudHM2LkJJVFMgLSB0aGlzLnN1Ym5ldE1hc2s7XG4gICAgICAgIGNvbnN0IHN1Ym5ldEJpdHMgPSBNYXRoLmFicyhzdWJuZXRTaXplIC0gY29uc3RhbnRzNi5CSVRTKTtcbiAgICAgICAgY29uc3Qgc3VibmV0UG93ZXJzID0gYXZhaWxhYmxlQml0cyAtIHN1Ym5ldEJpdHM7XG4gICAgICAgIGlmIChzdWJuZXRQb3dlcnMgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gJzAnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhZGRDb21tYXMoKEJpZ0ludCgnMicpICoqIEJpZ0ludChzdWJuZXRQb3dlcnMpKS50b1N0cmluZygxMCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgZnVuY3Rpb24gZ2V0dGluZyBzdGFydCBhZGRyZXNzLlxuICAgICAqIEBtZW1iZXJvZiBBZGRyZXNzNlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEByZXR1cm5zIHtiaWdpbnR9XG4gICAgICovXG4gICAgX3N0YXJ0QWRkcmVzcygpIHtcbiAgICAgICAgcmV0dXJuIEJpZ0ludChgMGIke3RoaXMubWFzaygpICsgJzAnLnJlcGVhdChjb25zdGFudHM2LkJJVFMgLSB0aGlzLnN1Ym5ldE1hc2spfWApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgZmlyc3QgYWRkcmVzcyBpbiB0aGUgcmFuZ2UgZ2l2ZW4gYnkgdGhpcyBhZGRyZXNzJyBzdWJuZXRcbiAgICAgKiBPZnRlbiByZWZlcnJlZCB0byBhcyB0aGUgTmV0d29yayBBZGRyZXNzLlxuICAgICAqIEBtZW1iZXJvZiBBZGRyZXNzNlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEByZXR1cm5zIHtBZGRyZXNzNn1cbiAgICAgKi9cbiAgICBzdGFydEFkZHJlc3MoKSB7XG4gICAgICAgIHJldHVybiBBZGRyZXNzNi5mcm9tQmlnSW50KHRoaXMuX3N0YXJ0QWRkcmVzcygpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGZpcnN0IGhvc3QgYWRkcmVzcyBpbiB0aGUgcmFuZ2UgZ2l2ZW4gYnkgdGhpcyBhZGRyZXNzJ3Mgc3VibmV0IGllXG4gICAgICogdGhlIGZpcnN0IGFkZHJlc3MgYWZ0ZXIgdGhlIE5ldHdvcmsgQWRkcmVzc1xuICAgICAqIEBtZW1iZXJvZiBBZGRyZXNzNlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEByZXR1cm5zIHtBZGRyZXNzNn1cbiAgICAgKi9cbiAgICBzdGFydEFkZHJlc3NFeGNsdXNpdmUoKSB7XG4gICAgICAgIGNvbnN0IGFkanVzdCA9IEJpZ0ludCgnMScpO1xuICAgICAgICByZXR1cm4gQWRkcmVzczYuZnJvbUJpZ0ludCh0aGlzLl9zdGFydEFkZHJlc3MoKSArIGFkanVzdCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhlbHBlciBmdW5jdGlvbiBnZXR0aW5nIGVuZCBhZGRyZXNzLlxuICAgICAqIEBtZW1iZXJvZiBBZGRyZXNzNlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEByZXR1cm5zIHtiaWdpbnR9XG4gICAgICovXG4gICAgX2VuZEFkZHJlc3MoKSB7XG4gICAgICAgIHJldHVybiBCaWdJbnQoYDBiJHt0aGlzLm1hc2soKSArICcxJy5yZXBlYXQoY29uc3RhbnRzNi5CSVRTIC0gdGhpcy5zdWJuZXRNYXNrKX1gKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGxhc3QgYWRkcmVzcyBpbiB0aGUgcmFuZ2UgZ2l2ZW4gYnkgdGhpcyBhZGRyZXNzJyBzdWJuZXRcbiAgICAgKiBPZnRlbiByZWZlcnJlZCB0byBhcyB0aGUgQnJvYWRjYXN0XG4gICAgICogQG1lbWJlcm9mIEFkZHJlc3M2XG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHJldHVybnMge0FkZHJlc3M2fVxuICAgICAqL1xuICAgIGVuZEFkZHJlc3MoKSB7XG4gICAgICAgIHJldHVybiBBZGRyZXNzNi5mcm9tQmlnSW50KHRoaXMuX2VuZEFkZHJlc3MoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBsYXN0IGhvc3QgYWRkcmVzcyBpbiB0aGUgcmFuZ2UgZ2l2ZW4gYnkgdGhpcyBhZGRyZXNzJ3Mgc3VibmV0IGllXG4gICAgICogdGhlIGxhc3QgYWRkcmVzcyBwcmlvciB0byB0aGUgQnJvYWRjYXN0IEFkZHJlc3NcbiAgICAgKiBAbWVtYmVyb2YgQWRkcmVzczZcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJucyB7QWRkcmVzczZ9XG4gICAgICovXG4gICAgZW5kQWRkcmVzc0V4Y2x1c2l2ZSgpIHtcbiAgICAgICAgY29uc3QgYWRqdXN0ID0gQmlnSW50KCcxJyk7XG4gICAgICAgIHJldHVybiBBZGRyZXNzNi5mcm9tQmlnSW50KHRoaXMuX2VuZEFkZHJlc3MoKSAtIGFkanVzdCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgc2NvcGUgb2YgdGhlIGFkZHJlc3NcbiAgICAgKiBAbWVtYmVyb2YgQWRkcmVzczZcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldFNjb3BlKCkge1xuICAgICAgICBsZXQgc2NvcGUgPSBjb25zdGFudHM2LlNDT1BFU1twYXJzZUludCh0aGlzLmdldEJpdHMoMTIsIDE2KS50b1N0cmluZygxMCksIDEwKV07XG4gICAgICAgIGlmICh0aGlzLmdldFR5cGUoKSA9PT0gJ0dsb2JhbCB1bmljYXN0JyAmJiBzY29wZSAhPT0gJ0xpbmsgbG9jYWwnKSB7XG4gICAgICAgICAgICBzY29wZSA9ICdHbG9iYWwnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzY29wZSB8fCAnVW5rbm93bic7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgdHlwZSBvZiB0aGUgYWRkcmVzc1xuICAgICAqIEBtZW1iZXJvZiBBZGRyZXNzNlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0VHlwZSgpIHtcbiAgICAgICAgZm9yIChjb25zdCBzdWJuZXQgb2YgT2JqZWN0LmtleXMoY29uc3RhbnRzNi5UWVBFUykpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzSW5TdWJuZXQobmV3IEFkZHJlc3M2KHN1Ym5ldCkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnN0YW50czYuVFlQRVNbc3VibmV0XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJ0dsb2JhbCB1bmljYXN0JztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBiaXRzIGluIHRoZSBnaXZlbiByYW5nZSBhcyBhIEJpZ0ludFxuICAgICAqIEBtZW1iZXJvZiBBZGRyZXNzNlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEByZXR1cm5zIHtiaWdpbnR9XG4gICAgICovXG4gICAgZ2V0Qml0cyhzdGFydCwgZW5kKSB7XG4gICAgICAgIHJldHVybiBCaWdJbnQoYDBiJHt0aGlzLmdldEJpdHNCYXNlMihzdGFydCwgZW5kKX1gKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBiaXRzIGluIHRoZSBnaXZlbiByYW5nZSBhcyBhIGJhc2UtMiBzdHJpbmdcbiAgICAgKiBAbWVtYmVyb2YgQWRkcmVzczZcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldEJpdHNCYXNlMihzdGFydCwgZW5kKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJpbmFyeVplcm9QYWQoKS5zbGljZShzdGFydCwgZW5kKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBiaXRzIGluIHRoZSBnaXZlbiByYW5nZSBhcyBhIGJhc2UtMTYgc3RyaW5nXG4gICAgICogQG1lbWJlcm9mIEFkZHJlc3M2XG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRCaXRzQmFzZTE2KHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gZW5kIC0gc3RhcnQ7XG4gICAgICAgIGlmIChsZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0xlbmd0aCBvZiBiaXRzIHRvIHJldHJpZXZlIG11c3QgYmUgZGl2aXNpYmxlIGJ5IGZvdXInKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5nZXRCaXRzKHN0YXJ0LCBlbmQpXG4gICAgICAgICAgICAudG9TdHJpbmcoMTYpXG4gICAgICAgICAgICAucGFkU3RhcnQobGVuZ3RoIC8gNCwgJzAnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBiaXRzIHRoYXQgYXJlIHNldCBwYXN0IHRoZSBzdWJuZXQgbWFzayBsZW5ndGhcbiAgICAgKiBAbWVtYmVyb2YgQWRkcmVzczZcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldEJpdHNQYXN0U3VibmV0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRCaXRzQmFzZTIodGhpcy5zdWJuZXRNYXNrLCBjb25zdGFudHM2LkJJVFMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIHJldmVyc2VkIGlwNi5hcnBhIGZvcm0gb2YgdGhlIGFkZHJlc3NcbiAgICAgKiBAbWVtYmVyb2YgQWRkcmVzczZcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5vbWl0U3VmZml4IC0gb21pdCB0aGUgXCJpcDYuYXJwYVwiIHN1ZmZpeFxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgcmV2ZXJzZUZvcm0ob3B0aW9ucykge1xuICAgICAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjaGFyYWN0ZXJzID0gTWF0aC5mbG9vcih0aGlzLnN1Ym5ldE1hc2sgLyA0KTtcbiAgICAgICAgY29uc3QgcmV2ZXJzZWQgPSB0aGlzLmNhbm9uaWNhbEZvcm0oKVxuICAgICAgICAgICAgLnJlcGxhY2UoLzovZywgJycpXG4gICAgICAgICAgICAuc3BsaXQoJycpXG4gICAgICAgICAgICAuc2xpY2UoMCwgY2hhcmFjdGVycylcbiAgICAgICAgICAgIC5yZXZlcnNlKClcbiAgICAgICAgICAgIC5qb2luKCcuJyk7XG4gICAgICAgIGlmIChjaGFyYWN0ZXJzID4gMCkge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMub21pdFN1ZmZpeCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXZlcnNlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBgJHtyZXZlcnNlZH0uaXA2LmFycGEuYDtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5vbWl0U3VmZml4KSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICdpcDYuYXJwYS4nO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIGNvcnJlY3QgZm9ybSBvZiB0aGUgYWRkcmVzc1xuICAgICAqIEBtZW1iZXJvZiBBZGRyZXNzNlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgY29ycmVjdEZvcm0oKSB7XG4gICAgICAgIGxldCBpO1xuICAgICAgICBsZXQgZ3JvdXBzID0gW107XG4gICAgICAgIGxldCB6ZXJvQ291bnRlciA9IDA7XG4gICAgICAgIGNvbnN0IHplcm9lcyA9IFtdO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5wYXJzZWRBZGRyZXNzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHBhcnNlSW50KHRoaXMucGFyc2VkQWRkcmVzc1tpXSwgMTYpO1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSAwKSB7XG4gICAgICAgICAgICAgICAgemVyb0NvdW50ZXIrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gMCAmJiB6ZXJvQ291bnRlciA+IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoemVyb0NvdW50ZXIgPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHplcm9lcy5wdXNoKFtpIC0gemVyb0NvdW50ZXIsIGkgLSAxXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHplcm9Db3VudGVyID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBEbyB3ZSBlbmQgd2l0aCBhIHN0cmluZyBvZiB6ZXJvZXM/XG4gICAgICAgIGlmICh6ZXJvQ291bnRlciA+IDEpIHtcbiAgICAgICAgICAgIHplcm9lcy5wdXNoKFt0aGlzLnBhcnNlZEFkZHJlc3MubGVuZ3RoIC0gemVyb0NvdW50ZXIsIHRoaXMucGFyc2VkQWRkcmVzcy5sZW5ndGggLSAxXSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgemVyb0xlbmd0aHMgPSB6ZXJvZXMubWFwKChuKSA9PiBuWzFdIC0gblswXSArIDEpO1xuICAgICAgICBpZiAoemVyb2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gemVyb0xlbmd0aHMuaW5kZXhPZihNYXRoLm1heCguLi56ZXJvTGVuZ3RocykpO1xuICAgICAgICAgICAgZ3JvdXBzID0gY29tcGFjdCh0aGlzLnBhcnNlZEFkZHJlc3MsIHplcm9lc1tpbmRleF0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZ3JvdXBzID0gdGhpcy5wYXJzZWRBZGRyZXNzO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBncm91cHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChncm91cHNbaV0gIT09ICdjb21wYWN0Jykge1xuICAgICAgICAgICAgICAgIGdyb3Vwc1tpXSA9IHBhcnNlSW50KGdyb3Vwc1tpXSwgMTYpLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgY29ycmVjdCA9IGdyb3Vwcy5qb2luKCc6Jyk7XG4gICAgICAgIGNvcnJlY3QgPSBjb3JyZWN0LnJlcGxhY2UoL15jb21wYWN0JC8sICc6OicpO1xuICAgICAgICBjb3JyZWN0ID0gY29ycmVjdC5yZXBsYWNlKC8oXmNvbXBhY3QpfChjb21wYWN0JCkvLCAnOicpO1xuICAgICAgICBjb3JyZWN0ID0gY29ycmVjdC5yZXBsYWNlKC9jb21wYWN0LywgJycpO1xuICAgICAgICByZXR1cm4gY29ycmVjdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgemVyby1wYWRkZWQgYmFzZS0yIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgYWRkcmVzc1xuICAgICAqIEBtZW1iZXJvZiBBZGRyZXNzNlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB2YXIgYWRkcmVzcyA9IG5ldyBBZGRyZXNzNignMjAwMTo0ODYwOjQwMDE6ODAzOjoxMDExJyk7XG4gICAgICogYWRkcmVzcy5iaW5hcnlaZXJvUGFkKCk7XG4gICAgICogLy8gJzAwMTAwMDAwMDAwMDAwMDEwMTAwMTAwMDAxMTAwMDAwMDEwMDAwMDAwMDAwMDAwMTAwMDAxMDAwMDAwMDAwMTFcbiAgICAgKiAvLyAgMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTAwMDAwMDAxMDAwMSdcbiAgICAgKi9cbiAgICBiaW5hcnlaZXJvUGFkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iaWdJbnQoKS50b1N0cmluZygyKS5wYWRTdGFydChjb25zdGFudHM2LkJJVFMsICcwJyk7XG4gICAgfVxuICAgIC8vIFRPRE86IEltcHJvdmUgdGhlIHNlbWFudGljcyBvZiB0aGlzIGhlbHBlciBmdW5jdGlvblxuICAgIHBhcnNlNGluNihhZGRyZXNzKSB7XG4gICAgICAgIGNvbnN0IGdyb3VwcyA9IGFkZHJlc3Muc3BsaXQoJzonKTtcbiAgICAgICAgY29uc3QgbGFzdEdyb3VwID0gZ3JvdXBzLnNsaWNlKC0xKVswXTtcbiAgICAgICAgY29uc3QgYWRkcmVzczQgPSBsYXN0R3JvdXAubWF0Y2goY29uc3RhbnRzNC5SRV9BRERSRVNTKTtcbiAgICAgICAgaWYgKGFkZHJlc3M0KSB7XG4gICAgICAgICAgICB0aGlzLnBhcnNlZEFkZHJlc3M0ID0gYWRkcmVzczRbMF07XG4gICAgICAgICAgICB0aGlzLmFkZHJlc3M0ID0gbmV3IGlwdjRfMS5BZGRyZXNzNCh0aGlzLnBhcnNlZEFkZHJlc3M0KTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5hZGRyZXNzNC5ncm91cHM7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICgvXjBbMC05XSsvLnRlc3QodGhpcy5hZGRyZXNzNC5wYXJzZWRBZGRyZXNzW2ldKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgYWRkcmVzc19lcnJvcl8xLkFkZHJlc3NFcnJvcihcIklQdjQgYWRkcmVzc2VzIGNhbid0IGhhdmUgbGVhZGluZyB6ZXJvZXMuXCIsIGFkZHJlc3MucmVwbGFjZShjb25zdGFudHM0LlJFX0FERFJFU1MsIHRoaXMuYWRkcmVzczQucGFyc2VkQWRkcmVzcy5tYXAoc3BhbkxlYWRpbmdaZXJvZXM0KS5qb2luKCcuJykpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnY0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGdyb3Vwc1tncm91cHMubGVuZ3RoIC0gMV0gPSB0aGlzLmFkZHJlc3M0LnRvR3JvdXA2KCk7XG4gICAgICAgICAgICBhZGRyZXNzID0gZ3JvdXBzLmpvaW4oJzonKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWRkcmVzcztcbiAgICB9XG4gICAgLy8gVE9ETzogTWFrZSBwcml2YXRlP1xuICAgIHBhcnNlKGFkZHJlc3MpIHtcbiAgICAgICAgYWRkcmVzcyA9IHRoaXMucGFyc2U0aW42KGFkZHJlc3MpO1xuICAgICAgICBjb25zdCBiYWRDaGFyYWN0ZXJzID0gYWRkcmVzcy5tYXRjaChjb25zdGFudHM2LlJFX0JBRF9DSEFSQUNURVJTKTtcbiAgICAgICAgaWYgKGJhZENoYXJhY3RlcnMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBhZGRyZXNzX2Vycm9yXzEuQWRkcmVzc0Vycm9yKGBCYWQgY2hhcmFjdGVyJHtiYWRDaGFyYWN0ZXJzLmxlbmd0aCA+IDEgPyAncycgOiAnJ30gZGV0ZWN0ZWQgaW4gYWRkcmVzczogJHtiYWRDaGFyYWN0ZXJzLmpvaW4oJycpfWAsIGFkZHJlc3MucmVwbGFjZShjb25zdGFudHM2LlJFX0JBRF9DSEFSQUNURVJTLCAnPHNwYW4gY2xhc3M9XCJwYXJzZS1lcnJvclwiPiQxPC9zcGFuPicpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBiYWRBZGRyZXNzID0gYWRkcmVzcy5tYXRjaChjb25zdGFudHM2LlJFX0JBRF9BRERSRVNTKTtcbiAgICAgICAgaWYgKGJhZEFkZHJlc3MpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBhZGRyZXNzX2Vycm9yXzEuQWRkcmVzc0Vycm9yKGBBZGRyZXNzIGZhaWxlZCByZWdleDogJHtiYWRBZGRyZXNzLmpvaW4oJycpfWAsIGFkZHJlc3MucmVwbGFjZShjb25zdGFudHM2LlJFX0JBRF9BRERSRVNTLCAnPHNwYW4gY2xhc3M9XCJwYXJzZS1lcnJvclwiPiQxPC9zcGFuPicpKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZ3JvdXBzID0gW107XG4gICAgICAgIGNvbnN0IGhhbHZlcyA9IGFkZHJlc3Muc3BsaXQoJzo6Jyk7XG4gICAgICAgIGlmIChoYWx2ZXMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICBsZXQgZmlyc3QgPSBoYWx2ZXNbMF0uc3BsaXQoJzonKTtcbiAgICAgICAgICAgIGxldCBsYXN0ID0gaGFsdmVzWzFdLnNwbGl0KCc6Jyk7XG4gICAgICAgICAgICBpZiAoZmlyc3QubGVuZ3RoID09PSAxICYmIGZpcnN0WzBdID09PSAnJykge1xuICAgICAgICAgICAgICAgIGZpcnN0ID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGFzdC5sZW5ndGggPT09IDEgJiYgbGFzdFswXSA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICBsYXN0ID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZW1haW5pbmcgPSB0aGlzLmdyb3VwcyAtIChmaXJzdC5sZW5ndGggKyBsYXN0Lmxlbmd0aCk7XG4gICAgICAgICAgICBpZiAoIXJlbWFpbmluZykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBhZGRyZXNzX2Vycm9yXzEuQWRkcmVzc0Vycm9yKCdFcnJvciBwYXJzaW5nIGdyb3VwcycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5lbGlkZWRHcm91cHMgPSByZW1haW5pbmc7XG4gICAgICAgICAgICB0aGlzLmVsaXNpb25CZWdpbiA9IGZpcnN0Lmxlbmd0aDtcbiAgICAgICAgICAgIHRoaXMuZWxpc2lvbkVuZCA9IGZpcnN0Lmxlbmd0aCArIHRoaXMuZWxpZGVkR3JvdXBzO1xuICAgICAgICAgICAgZ3JvdXBzID0gZ3JvdXBzLmNvbmNhdChmaXJzdCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlbWFpbmluZzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZ3JvdXBzLnB1c2goJzAnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdyb3VwcyA9IGdyb3Vwcy5jb25jYXQobGFzdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaGFsdmVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgZ3JvdXBzID0gYWRkcmVzcy5zcGxpdCgnOicpO1xuICAgICAgICAgICAgdGhpcy5lbGlkZWRHcm91cHMgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGFkZHJlc3NfZXJyb3JfMS5BZGRyZXNzRXJyb3IoJ1RvbyBtYW55IDo6IGdyb3VwcyBmb3VuZCcpO1xuICAgICAgICB9XG4gICAgICAgIGdyb3VwcyA9IGdyb3Vwcy5tYXAoKGdyb3VwKSA9PiBwYXJzZUludChncm91cCwgMTYpLnRvU3RyaW5nKDE2KSk7XG4gICAgICAgIGlmIChncm91cHMubGVuZ3RoICE9PSB0aGlzLmdyb3Vwcykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGFkZHJlc3NfZXJyb3JfMS5BZGRyZXNzRXJyb3IoJ0luY29ycmVjdCBudW1iZXIgb2YgZ3JvdXBzIGZvdW5kJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdyb3VwcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBjYW5vbmljYWwgZm9ybSBvZiB0aGUgYWRkcmVzc1xuICAgICAqIEBtZW1iZXJvZiBBZGRyZXNzNlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgY2Fub25pY2FsRm9ybSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VkQWRkcmVzcy5tYXAocGFkZGVkSGV4KS5qb2luKCc6Jyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgZGVjaW1hbCBmb3JtIG9mIHRoZSBhZGRyZXNzXG4gICAgICogQG1lbWJlcm9mIEFkZHJlc3M2XG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBkZWNpbWFsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZWRBZGRyZXNzLm1hcCgobikgPT4gcGFyc2VJbnQobiwgMTYpLnRvU3RyaW5nKDEwKS5wYWRTdGFydCg1LCAnMCcpKS5qb2luKCc6Jyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgYWRkcmVzcyBhcyBhIEJpZ0ludFxuICAgICAqIEBtZW1iZXJvZiBBZGRyZXNzNlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEByZXR1cm5zIHtiaWdpbnR9XG4gICAgICovXG4gICAgYmlnSW50KCkge1xuICAgICAgICByZXR1cm4gQmlnSW50KGAweCR7dGhpcy5wYXJzZWRBZGRyZXNzLm1hcChwYWRkZWRIZXgpLmpvaW4oJycpfWApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIGxhc3QgdHdvIGdyb3VwcyBvZiB0aGlzIGFkZHJlc3MgYXMgYW4gSVB2NCBhZGRyZXNzIHN0cmluZ1xuICAgICAqIEBtZW1iZXJvZiBBZGRyZXNzNlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEByZXR1cm5zIHtBZGRyZXNzNH1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHZhciBhZGRyZXNzID0gbmV3IEFkZHJlc3M2KCcyMDAxOjQ4NjA6NDAwMTo6MTgyNTpiZjExJyk7XG4gICAgICogYWRkcmVzcy50bzQoKS5jb3JyZWN0Rm9ybSgpOyAvLyAnMjQuMzcuMTkxLjE3J1xuICAgICAqL1xuICAgIHRvNCgpIHtcbiAgICAgICAgY29uc3QgYmluYXJ5ID0gdGhpcy5iaW5hcnlaZXJvUGFkKCkuc3BsaXQoJycpO1xuICAgICAgICByZXR1cm4gaXB2NF8xLkFkZHJlc3M0LmZyb21IZXgoQmlnSW50KGAwYiR7YmluYXJ5LnNsaWNlKDk2LCAxMjgpLmpvaW4oJycpfWApLnRvU3RyaW5nKDE2KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgdjQtaW4tdjYgZm9ybSBvZiB0aGUgYWRkcmVzc1xuICAgICAqIEBtZW1iZXJvZiBBZGRyZXNzNlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgdG80aW42KCkge1xuICAgICAgICBjb25zdCBhZGRyZXNzNCA9IHRoaXMudG80KCk7XG4gICAgICAgIGNvbnN0IGFkZHJlc3M2ID0gbmV3IEFkZHJlc3M2KHRoaXMucGFyc2VkQWRkcmVzcy5zbGljZSgwLCA2KS5qb2luKCc6JyksIDYpO1xuICAgICAgICBjb25zdCBjb3JyZWN0ID0gYWRkcmVzczYuY29ycmVjdEZvcm0oKTtcbiAgICAgICAgbGV0IGluZml4ID0gJyc7XG4gICAgICAgIGlmICghLzokLy50ZXN0KGNvcnJlY3QpKSB7XG4gICAgICAgICAgICBpbmZpeCA9ICc6JztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29ycmVjdCArIGluZml4ICsgYWRkcmVzczQuYWRkcmVzcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSBUZXJlZG8gcHJvcGVydGllcyBvZiB0aGUgYWRkcmVzc1xuICAgICAqIEBtZW1iZXJvZiBBZGRyZXNzNlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgaW5zcGVjdFRlcmVkbygpIHtcbiAgICAgICAgLypcbiAgICAgICAgLSBCaXRzIDAgdG8gMzEgYXJlIHNldCB0byB0aGUgVGVyZWRvIHByZWZpeCAobm9ybWFsbHkgMjAwMTowMDAwOjovMzIpLlxuICAgICAgICAtIEJpdHMgMzIgdG8gNjMgZW1iZWQgdGhlIHByaW1hcnkgSVB2NCBhZGRyZXNzIG9mIHRoZSBUZXJlZG8gc2VydmVyIHRoYXRcbiAgICAgICAgICBpcyB1c2VkLlxuICAgICAgICAtIEJpdHMgNjQgdG8gNzkgY2FuIGJlIHVzZWQgdG8gZGVmaW5lIHNvbWUgZmxhZ3MuIEN1cnJlbnRseSBvbmx5IHRoZVxuICAgICAgICAgIGhpZ2hlciBvcmRlciBiaXQgaXMgdXNlZDsgaXQgaXMgc2V0IHRvIDEgaWYgdGhlIFRlcmVkbyBjbGllbnQgaXNcbiAgICAgICAgICBsb2NhdGVkIGJlaGluZCBhIGNvbmUgTkFULCAwIG90aGVyd2lzZS4gRm9yIE1pY3Jvc29mdCdzIFdpbmRvd3MgVmlzdGFcbiAgICAgICAgICBhbmQgV2luZG93cyBTZXJ2ZXIgMjAwOCBpbXBsZW1lbnRhdGlvbnMsIG1vcmUgYml0cyBhcmUgdXNlZC4gSW4gdGhvc2VcbiAgICAgICAgICBpbXBsZW1lbnRhdGlvbnMsIHRoZSBmb3JtYXQgZm9yIHRoZXNlIDE2IGJpdHMgaXMgXCJDUkFBQUFVRyBBQUFBQUFBQVwiLFxuICAgICAgICAgIHdoZXJlIFwiQ1wiIHJlbWFpbnMgdGhlIFwiQ29uZVwiIGZsYWcuIFRoZSBcIlJcIiBiaXQgaXMgcmVzZXJ2ZWQgZm9yIGZ1dHVyZVxuICAgICAgICAgIHVzZS4gVGhlIFwiVVwiIGJpdCBpcyBmb3IgdGhlIFVuaXZlcnNhbC9Mb2NhbCBmbGFnIChzZXQgdG8gMCkuIFRoZSBcIkdcIiBiaXRcbiAgICAgICAgICBpcyBJbmRpdmlkdWFsL0dyb3VwIGZsYWcgKHNldCB0byAwKS4gVGhlIEEgYml0cyBhcmUgc2V0IHRvIGEgMTItYml0XG4gICAgICAgICAgcmFuZG9tbHkgZ2VuZXJhdGVkIG51bWJlciBjaG9zZW4gYnkgdGhlIFRlcmVkbyBjbGllbnQgdG8gaW50cm9kdWNlXG4gICAgICAgICAgYWRkaXRpb25hbCBwcm90ZWN0aW9uIGZvciB0aGUgVGVyZWRvIG5vZGUgYWdhaW5zdCBJUHY2LWJhc2VkIHNjYW5uaW5nXG4gICAgICAgICAgYXR0YWNrcy5cbiAgICAgICAgLSBCaXRzIDgwIHRvIDk1IGNvbnRhaW5zIHRoZSBvYmZ1c2NhdGVkIFVEUCBwb3J0IG51bWJlci4gVGhpcyBpcyB0aGVcbiAgICAgICAgICBwb3J0IG51bWJlciB0aGF0IGlzIG1hcHBlZCBieSB0aGUgTkFUIHRvIHRoZSBUZXJlZG8gY2xpZW50IHdpdGggYWxsXG4gICAgICAgICAgYml0cyBpbnZlcnRlZC5cbiAgICAgICAgLSBCaXRzIDk2IHRvIDEyNyBjb250YWlucyB0aGUgb2JmdXNjYXRlZCBJUHY0IGFkZHJlc3MuIFRoaXMgaXMgdGhlXG4gICAgICAgICAgcHVibGljIElQdjQgYWRkcmVzcyBvZiB0aGUgTkFUIHdpdGggYWxsIGJpdHMgaW52ZXJ0ZWQuXG4gICAgICAgICovXG4gICAgICAgIGNvbnN0IHByZWZpeCA9IHRoaXMuZ2V0Qml0c0Jhc2UxNigwLCAzMik7XG4gICAgICAgIGNvbnN0IGJpdHNGb3JVZHBQb3J0ID0gdGhpcy5nZXRCaXRzKDgwLCA5Nik7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1iaXR3aXNlXG4gICAgICAgIGNvbnN0IHVkcFBvcnQgPSAoYml0c0ZvclVkcFBvcnQgXiBCaWdJbnQoJzB4ZmZmZicpKS50b1N0cmluZygpO1xuICAgICAgICBjb25zdCBzZXJ2ZXI0ID0gaXB2NF8xLkFkZHJlc3M0LmZyb21IZXgodGhpcy5nZXRCaXRzQmFzZTE2KDMyLCA2NCkpO1xuICAgICAgICBjb25zdCBiaXRzRm9yQ2xpZW50NCA9IHRoaXMuZ2V0Qml0cyg5NiwgMTI4KTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWJpdHdpc2VcbiAgICAgICAgY29uc3QgY2xpZW50NCA9IGlwdjRfMS5BZGRyZXNzNC5mcm9tSGV4KChiaXRzRm9yQ2xpZW50NCBeIEJpZ0ludCgnMHhmZmZmZmZmZicpKS50b1N0cmluZygxNikpO1xuICAgICAgICBjb25zdCBmbGFnc0Jhc2UyID0gdGhpcy5nZXRCaXRzQmFzZTIoNjQsIDgwKTtcbiAgICAgICAgY29uc3QgY29uZU5hdCA9ICgwLCBjb21tb25fMS50ZXN0Qml0KShmbGFnc0Jhc2UyLCAxNSk7XG4gICAgICAgIGNvbnN0IHJlc2VydmVkID0gKDAsIGNvbW1vbl8xLnRlc3RCaXQpKGZsYWdzQmFzZTIsIDE0KTtcbiAgICAgICAgY29uc3QgZ3JvdXBJbmRpdmlkdWFsID0gKDAsIGNvbW1vbl8xLnRlc3RCaXQpKGZsYWdzQmFzZTIsIDgpO1xuICAgICAgICBjb25zdCB1bml2ZXJzYWxMb2NhbCA9ICgwLCBjb21tb25fMS50ZXN0Qml0KShmbGFnc0Jhc2UyLCA5KTtcbiAgICAgICAgY29uc3Qgbm9uY2UgPSBCaWdJbnQoYDBiJHtmbGFnc0Jhc2UyLnNsaWNlKDIsIDYpICsgZmxhZ3NCYXNlMi5zbGljZSg4LCAxNil9YCkudG9TdHJpbmcoMTApO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcHJlZml4OiBgJHtwcmVmaXguc2xpY2UoMCwgNCl9OiR7cHJlZml4LnNsaWNlKDQsIDgpfWAsXG4gICAgICAgICAgICBzZXJ2ZXI0OiBzZXJ2ZXI0LmFkZHJlc3MsXG4gICAgICAgICAgICBjbGllbnQ0OiBjbGllbnQ0LmFkZHJlc3MsXG4gICAgICAgICAgICBmbGFnczogZmxhZ3NCYXNlMixcbiAgICAgICAgICAgIGNvbmVOYXQsXG4gICAgICAgICAgICBtaWNyb3NvZnQ6IHtcbiAgICAgICAgICAgICAgICByZXNlcnZlZCxcbiAgICAgICAgICAgICAgICB1bml2ZXJzYWxMb2NhbCxcbiAgICAgICAgICAgICAgICBncm91cEluZGl2aWR1YWwsXG4gICAgICAgICAgICAgICAgbm9uY2UsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdWRwUG9ydCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSA2dG80IHByb3BlcnRpZXMgb2YgdGhlIGFkZHJlc3NcbiAgICAgKiBAbWVtYmVyb2YgQWRkcmVzczZcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIGluc3BlY3Q2dG80KCkge1xuICAgICAgICAvKlxuICAgICAgICAtIEJpdHMgMCB0byAxNSBhcmUgc2V0IHRvIHRoZSA2dG80IHByZWZpeCAoMjAwMjo6LzE2KS5cbiAgICAgICAgLSBCaXRzIDE2IHRvIDQ4IGVtYmVkIHRoZSBJUHY0IGFkZHJlc3Mgb2YgdGhlIDZ0bzQgZ2F0ZXdheSB0aGF0IGlzIHVzZWQuXG4gICAgICAgICovXG4gICAgICAgIGNvbnN0IHByZWZpeCA9IHRoaXMuZ2V0Qml0c0Jhc2UxNigwLCAxNik7XG4gICAgICAgIGNvbnN0IGdhdGV3YXkgPSBpcHY0XzEuQWRkcmVzczQuZnJvbUhleCh0aGlzLmdldEJpdHNCYXNlMTYoMTYsIDQ4KSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwcmVmaXg6IHByZWZpeC5zbGljZSgwLCA0KSxcbiAgICAgICAgICAgIGdhdGV3YXk6IGdhdGV3YXkuYWRkcmVzcyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgdjYgNnRvNCBhZGRyZXNzIGZyb20gYSB2NiB2NGludjYgYWRkcmVzc1xuICAgICAqIEBtZW1iZXJvZiBBZGRyZXNzNlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEByZXR1cm5zIHtBZGRyZXNzNn1cbiAgICAgKi9cbiAgICB0bzZ0bzQoKSB7XG4gICAgICAgIGlmICghdGhpcy5pczQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWRkcjZ0bzQgPSBbXG4gICAgICAgICAgICAnMjAwMicsXG4gICAgICAgICAgICB0aGlzLmdldEJpdHNCYXNlMTYoOTYsIDExMiksXG4gICAgICAgICAgICB0aGlzLmdldEJpdHNCYXNlMTYoMTEyLCAxMjgpLFxuICAgICAgICAgICAgJycsXG4gICAgICAgICAgICAnLzE2JyxcbiAgICAgICAgXS5qb2luKCc6Jyk7XG4gICAgICAgIHJldHVybiBuZXcgQWRkcmVzczYoYWRkcjZ0bzQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBieXRlIGFycmF5XG4gICAgICogQG1lbWJlcm9mIEFkZHJlc3M2XG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAqL1xuICAgIHRvQnl0ZUFycmF5KCkge1xuICAgICAgICBjb25zdCB2YWx1ZVdpdGhvdXRQYWRkaW5nID0gdGhpcy5iaWdJbnQoKS50b1N0cmluZygxNik7XG4gICAgICAgIGNvbnN0IGxlYWRpbmdQYWQgPSAnMCcucmVwZWF0KHZhbHVlV2l0aG91dFBhZGRpbmcubGVuZ3RoICUgMik7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gYCR7bGVhZGluZ1BhZH0ke3ZhbHVlV2l0aG91dFBhZGRpbmd9YDtcbiAgICAgICAgY29uc3QgYnl0ZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbmd0aCA9IHZhbHVlLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICBieXRlcy5wdXNoKHBhcnNlSW50KHZhbHVlLnN1YnN0cmluZyhpLCBpICsgMiksIDE2KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ5dGVzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYW4gdW5zaWduZWQgYnl0ZSBhcnJheVxuICAgICAqIEBtZW1iZXJvZiBBZGRyZXNzNlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgKi9cbiAgICB0b1Vuc2lnbmVkQnl0ZUFycmF5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b0J5dGVBcnJheSgpLm1hcCh1bnNpZ25CeXRlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydCBhIGJ5dGUgYXJyYXkgdG8gYW4gQWRkcmVzczYgb2JqZWN0XG4gICAgICogQG1lbWJlcm9mIEFkZHJlc3M2XG4gICAgICogQHN0YXRpY1xuICAgICAqIEByZXR1cm5zIHtBZGRyZXNzNn1cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbUJ5dGVBcnJheShieXRlcykge1xuICAgICAgICByZXR1cm4gdGhpcy5mcm9tVW5zaWduZWRCeXRlQXJyYXkoYnl0ZXMubWFwKHVuc2lnbkJ5dGUpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydCBhbiB1bnNpZ25lZCBieXRlIGFycmF5IHRvIGFuIEFkZHJlc3M2IG9iamVjdFxuICAgICAqIEBtZW1iZXJvZiBBZGRyZXNzNlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcmV0dXJucyB7QWRkcmVzczZ9XG4gICAgICovXG4gICAgc3RhdGljIGZyb21VbnNpZ25lZEJ5dGVBcnJheShieXRlcykge1xuICAgICAgICBjb25zdCBCWVRFX01BWCA9IEJpZ0ludCgnMjU2Jyk7XG4gICAgICAgIGxldCByZXN1bHQgPSBCaWdJbnQoJzAnKTtcbiAgICAgICAgbGV0IG11bHRpcGxpZXIgPSBCaWdJbnQoJzEnKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IGJ5dGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gbXVsdGlwbGllciAqIEJpZ0ludChieXRlc1tpXS50b1N0cmluZygxMCkpO1xuICAgICAgICAgICAgbXVsdGlwbGllciAqPSBCWVRFX01BWDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQWRkcmVzczYuZnJvbUJpZ0ludChyZXN1bHQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGFkZHJlc3MgaXMgaW4gdGhlIGNhbm9uaWNhbCBmb3JtLCBmYWxzZSBvdGhlcndpc2VcbiAgICAgKiBAbWVtYmVyb2YgQWRkcmVzczZcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBpc0Nhbm9uaWNhbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkcmVzc01pbnVzU3VmZml4ID09PSB0aGlzLmNhbm9uaWNhbEZvcm0oKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBhZGRyZXNzIGlzIGEgbGluayBsb2NhbCBhZGRyZXNzLCBmYWxzZSBvdGhlcndpc2VcbiAgICAgKiBAbWVtYmVyb2YgQWRkcmVzczZcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBpc0xpbmtMb2NhbCgpIHtcbiAgICAgICAgLy8gWmVyb2VzIGFyZSByZXF1aXJlZCwgaS5lLiB3ZSBjYW4ndCBjaGVjayBpc0luU3VibmV0IHdpdGggJ2ZlODA6Oi8xMCdcbiAgICAgICAgaWYgKHRoaXMuZ2V0Qml0c0Jhc2UyKDAsIDY0KSA9PT1cbiAgICAgICAgICAgICcxMTExMTExMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGFkZHJlc3MgaXMgYSBtdWx0aWNhc3QgYWRkcmVzcywgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICogQG1lbWJlcm9mIEFkZHJlc3M2XG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgaXNNdWx0aWNhc3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFR5cGUoKSA9PT0gJ011bHRpY2FzdCc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgYWRkcmVzcyBpcyBhIHY0LWluLXY2IGFkZHJlc3MsIGZhbHNlIG90aGVyd2lzZVxuICAgICAqIEBtZW1iZXJvZiBBZGRyZXNzNlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGlzNCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudjQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgYWRkcmVzcyBpcyBhIFRlcmVkbyBhZGRyZXNzLCBmYWxzZSBvdGhlcndpc2VcbiAgICAgKiBAbWVtYmVyb2YgQWRkcmVzczZcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBpc1RlcmVkbygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNJblN1Ym5ldChuZXcgQWRkcmVzczYoJzIwMDE6Oi8zMicpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBhZGRyZXNzIGlzIGEgNnRvNCBhZGRyZXNzLCBmYWxzZSBvdGhlcndpc2VcbiAgICAgKiBAbWVtYmVyb2YgQWRkcmVzczZcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBpczZ0bzQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzSW5TdWJuZXQobmV3IEFkZHJlc3M2KCcyMDAyOjovMTYnKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgYWRkcmVzcyBpcyBhIGxvb3BiYWNrIGFkZHJlc3MsIGZhbHNlIG90aGVyd2lzZVxuICAgICAqIEBtZW1iZXJvZiBBZGRyZXNzNlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGlzTG9vcGJhY2soKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFR5cGUoKSA9PT0gJ0xvb3BiYWNrJztcbiAgICB9XG4gICAgLy8gI2VuZHJlZ2lvblxuICAgIC8vICNyZWdpb24gSFRNTFxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IHRoZSBhZGRyZXNzIGluIGxpbmsgZm9ybSB3aXRoIGEgZGVmYXVsdCBwb3J0IG9mIDgwXG4gICAgICovXG4gICAgaHJlZihvcHRpb25hbFBvcnQpIHtcbiAgICAgICAgaWYgKG9wdGlvbmFsUG9ydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBvcHRpb25hbFBvcnQgPSAnJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9wdGlvbmFsUG9ydCA9IGA6JHtvcHRpb25hbFBvcnR9YDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYGh0dHA6Ly9bJHt0aGlzLmNvcnJlY3RGb3JtKCl9XSR7b3B0aW9uYWxQb3J0fS9gO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBhIGxpbmsgc3VpdGFibGUgZm9yIGNvbnZleWluZyB0aGUgYWRkcmVzcyB2aWEgYSBVUkwgaGFzaFxuICAgICAqL1xuICAgIGxpbmsob3B0aW9ucykge1xuICAgICAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5jbGFzc05hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgb3B0aW9ucy5jbGFzc05hbWUgPSAnJztcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5wcmVmaXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgb3B0aW9ucy5wcmVmaXggPSAnLyNhZGRyZXNzPSc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMudjQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgb3B0aW9ucy52NCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBmb3JtRnVuY3Rpb24gPSB0aGlzLmNvcnJlY3RGb3JtO1xuICAgICAgICBpZiAob3B0aW9ucy52NCkge1xuICAgICAgICAgICAgZm9ybUZ1bmN0aW9uID0gdGhpcy50bzRpbjY7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZm9ybSA9IGZvcm1GdW5jdGlvbi5jYWxsKHRoaXMpO1xuICAgICAgICBpZiAob3B0aW9ucy5jbGFzc05hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBgPGEgaHJlZj1cIiR7b3B0aW9ucy5wcmVmaXh9JHtmb3JtfVwiIGNsYXNzPVwiJHtvcHRpb25zLmNsYXNzTmFtZX1cIj4ke2Zvcm19PC9hPmA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGA8YSBocmVmPVwiJHtvcHRpb25zLnByZWZpeH0ke2Zvcm19XCI+JHtmb3JtfTwvYT5gO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHcm91cHMgYW4gYWRkcmVzc1xuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ3JvdXAoKSB7XG4gICAgICAgIGlmICh0aGlzLmVsaWRlZEdyb3VwcyA9PT0gMCkge1xuICAgICAgICAgICAgLy8gVGhlIHNpbXBsZSBjYXNlXG4gICAgICAgICAgICByZXR1cm4gaGVscGVycy5zaW1wbGVHcm91cCh0aGlzLmFkZHJlc3MpLmpvaW4oJzonKTtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnQodHlwZW9mIHRoaXMuZWxpZGVkR3JvdXBzID09PSAnbnVtYmVyJyk7XG4gICAgICAgIGFzc2VydCh0eXBlb2YgdGhpcy5lbGlzaW9uQmVnaW4gPT09ICdudW1iZXInKTtcbiAgICAgICAgLy8gVGhlIGVsaWRlZCBjYXNlXG4gICAgICAgIGNvbnN0IG91dHB1dCA9IFtdO1xuICAgICAgICBjb25zdCBbbGVmdCwgcmlnaHRdID0gdGhpcy5hZGRyZXNzLnNwbGl0KCc6OicpO1xuICAgICAgICBpZiAobGVmdC5sZW5ndGgpIHtcbiAgICAgICAgICAgIG91dHB1dC5wdXNoKC4uLmhlbHBlcnMuc2ltcGxlR3JvdXAobGVmdCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb3V0cHV0LnB1c2goJycpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNsYXNzZXMgPSBbJ2hvdmVyLWdyb3VwJ107XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmVsaXNpb25CZWdpbjsgaSA8IHRoaXMuZWxpc2lvbkJlZ2luICsgdGhpcy5lbGlkZWRHcm91cHM7IGkrKykge1xuICAgICAgICAgICAgY2xhc3Nlcy5wdXNoKGBncm91cC0ke2l9YCk7XG4gICAgICAgIH1cbiAgICAgICAgb3V0cHV0LnB1c2goYDxzcGFuIGNsYXNzPVwiJHtjbGFzc2VzLmpvaW4oJyAnKX1cIj48L3NwYW4+YCk7XG4gICAgICAgIGlmIChyaWdodC5sZW5ndGgpIHtcbiAgICAgICAgICAgIG91dHB1dC5wdXNoKC4uLmhlbHBlcnMuc2ltcGxlR3JvdXAocmlnaHQsIHRoaXMuZWxpc2lvbkVuZCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb3V0cHV0LnB1c2goJycpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmlzNCgpKSB7XG4gICAgICAgICAgICBhc3NlcnQodGhpcy5hZGRyZXNzNCBpbnN0YW5jZW9mIGlwdjRfMS5BZGRyZXNzNCk7XG4gICAgICAgICAgICBvdXRwdXQucG9wKCk7XG4gICAgICAgICAgICBvdXRwdXQucHVzaCh0aGlzLmFkZHJlc3M0Lmdyb3VwRm9yVjYoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dHB1dC5qb2luKCc6Jyk7XG4gICAgfVxuICAgIC8vICNlbmRyZWdpb25cbiAgICAvLyAjcmVnaW9uIFJlZ3VsYXIgZXhwcmVzc2lvbnNcbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBzdHJpbmcgdGhhdCBjYW4gYmUgdXNlZCB0byBmaW5kIG9yIHZhbGlkYXRlXG4gICAgICogYWxsIHZhcmlhdGlvbnMgb2YgdGhpcyBhZGRyZXNzXG4gICAgICogQG1lbWJlcm9mIEFkZHJlc3M2XG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBzdWJzdHJpbmdTZWFyY2hcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIHJlZ3VsYXJFeHByZXNzaW9uU3RyaW5nKHN1YnN0cmluZ1NlYXJjaCA9IGZhbHNlKSB7XG4gICAgICAgIGxldCBvdXRwdXQgPSBbXTtcbiAgICAgICAgLy8gVE9ETzogcmV2aXNpdCB3aHkgdGhpcyBpcyBuZWNlc3NhcnlcbiAgICAgICAgY29uc3QgYWRkcmVzczYgPSBuZXcgQWRkcmVzczYodGhpcy5jb3JyZWN0Rm9ybSgpKTtcbiAgICAgICAgaWYgKGFkZHJlc3M2LmVsaWRlZEdyb3VwcyA9PT0gMCkge1xuICAgICAgICAgICAgLy8gVGhlIHNpbXBsZSBjYXNlXG4gICAgICAgICAgICBvdXRwdXQucHVzaCgoMCwgcmVndWxhcl9leHByZXNzaW9uc18xLnNpbXBsZVJlZ3VsYXJFeHByZXNzaW9uKShhZGRyZXNzNi5wYXJzZWRBZGRyZXNzKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYWRkcmVzczYuZWxpZGVkR3JvdXBzID09PSBjb25zdGFudHM2LkdST1VQUykge1xuICAgICAgICAgICAgLy8gQSBjb21wbGV0ZWx5IGVsaWRlZCBhZGRyZXNzXG4gICAgICAgICAgICBvdXRwdXQucHVzaCgoMCwgcmVndWxhcl9leHByZXNzaW9uc18xLnBvc3NpYmxlRWxpc2lvbnMpKGNvbnN0YW50czYuR1JPVVBTKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBBIHBhcnRpYWxseSBlbGlkZWQgYWRkcmVzc1xuICAgICAgICAgICAgY29uc3QgaGFsdmVzID0gYWRkcmVzczYuYWRkcmVzcy5zcGxpdCgnOjonKTtcbiAgICAgICAgICAgIGlmIChoYWx2ZXNbMF0ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0LnB1c2goKDAsIHJlZ3VsYXJfZXhwcmVzc2lvbnNfMS5zaW1wbGVSZWd1bGFyRXhwcmVzc2lvbikoaGFsdmVzWzBdLnNwbGl0KCc6JykpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFzc2VydCh0eXBlb2YgYWRkcmVzczYuZWxpZGVkR3JvdXBzID09PSAnbnVtYmVyJyk7XG4gICAgICAgICAgICBvdXRwdXQucHVzaCgoMCwgcmVndWxhcl9leHByZXNzaW9uc18xLnBvc3NpYmxlRWxpc2lvbnMpKGFkZHJlc3M2LmVsaWRlZEdyb3VwcywgaGFsdmVzWzBdLmxlbmd0aCAhPT0gMCwgaGFsdmVzWzFdLmxlbmd0aCAhPT0gMCkpO1xuICAgICAgICAgICAgaWYgKGhhbHZlc1sxXS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQucHVzaCgoMCwgcmVndWxhcl9leHByZXNzaW9uc18xLnNpbXBsZVJlZ3VsYXJFeHByZXNzaW9uKShoYWx2ZXNbMV0uc3BsaXQoJzonKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3V0cHV0ID0gW291dHB1dC5qb2luKCc6JyldO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc3Vic3RyaW5nU2VhcmNoKSB7XG4gICAgICAgICAgICBvdXRwdXQgPSBbXG4gICAgICAgICAgICAgICAgJyg/PV58JyxcbiAgICAgICAgICAgICAgICByZWd1bGFyX2V4cHJlc3Npb25zXzEuQUREUkVTU19CT1VOREFSWSxcbiAgICAgICAgICAgICAgICAnfFteXFxcXHdcXFxcOl0pKCcsXG4gICAgICAgICAgICAgICAgLi4ub3V0cHV0LFxuICAgICAgICAgICAgICAgICcpKD89W15cXFxcd1xcXFw6XXwnLFxuICAgICAgICAgICAgICAgIHJlZ3VsYXJfZXhwcmVzc2lvbnNfMS5BRERSRVNTX0JPVU5EQVJZLFxuICAgICAgICAgICAgICAgICd8JCknLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0cHV0LmpvaW4oJycpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSBhIHJlZ3VsYXIgZXhwcmVzc2lvbiB0aGF0IGNhbiBiZSB1c2VkIHRvIGZpbmQgb3IgdmFsaWRhdGUgYWxsXG4gICAgICogdmFyaWF0aW9ucyBvZiB0aGlzIGFkZHJlc3MuXG4gICAgICogQG1lbWJlcm9mIEFkZHJlc3M2XG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBzdWJzdHJpbmdTZWFyY2hcbiAgICAgKiBAcmV0dXJucyB7UmVnRXhwfVxuICAgICAqL1xuICAgIHJlZ3VsYXJFeHByZXNzaW9uKHN1YnN0cmluZ1NlYXJjaCA9IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVnRXhwKHRoaXMucmVndWxhckV4cHJlc3Npb25TdHJpbmcoc3Vic3RyaW5nU2VhcmNoKSwgJ2knKTtcbiAgICB9XG59XG5leHBvcnRzLkFkZHJlc3M2ID0gQWRkcmVzczY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pcHY2LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ip-address/dist/ipv6.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ip-address/dist/v4/constants.js":
/*!******************************************************!*\
  !*** ./node_modules/ip-address/dist/v4/constants.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.RE_SUBNET_STRING = exports.RE_ADDRESS = exports.GROUPS = exports.BITS = void 0;\nexports.BITS = 32;\nexports.GROUPS = 4;\nexports.RE_ADDRESS = /^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/g;\nexports.RE_SUBNET_STRING = /\\/\\d{1,2}$/;\n//# sourceMappingURL=constants.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaXAtYWRkcmVzcy9kaXN0L3Y0L2NvbnN0YW50cy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx3QkFBd0IsR0FBRyxrQkFBa0IsR0FBRyxjQUFjLEdBQUcsWUFBWTtBQUM3RSxZQUFZO0FBQ1osY0FBYztBQUNkLGtCQUFrQjtBQUNsQix3QkFBd0IsU0FBUyxJQUFJO0FBQ3JDIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXFNpbXBsZVxcRG93bmxvYWRzXFxQcm95ZWN0b0V4dHJhY3RvckRlRmlsYW1lbnRvXFxleHRyYWN0b3Itc2VydmVyXFxub2RlX21vZHVsZXNcXGlwLWFkZHJlc3NcXGRpc3RcXHY0XFxjb25zdGFudHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlJFX1NVQk5FVF9TVFJJTkcgPSBleHBvcnRzLlJFX0FERFJFU1MgPSBleHBvcnRzLkdST1VQUyA9IGV4cG9ydHMuQklUUyA9IHZvaWQgMDtcbmV4cG9ydHMuQklUUyA9IDMyO1xuZXhwb3J0cy5HUk9VUFMgPSA0O1xuZXhwb3J0cy5SRV9BRERSRVNTID0gL14oMjVbMC01XXwyWzAtNF1bMC05XXxbMDFdP1swLTldWzAtOV0/KVxcLigyNVswLTVdfDJbMC00XVswLTldfFswMV0/WzAtOV1bMC05XT8pXFwuKDI1WzAtNV18MlswLTRdWzAtOV18WzAxXT9bMC05XVswLTldPylcXC4oMjVbMC01XXwyWzAtNF1bMC05XXxbMDFdP1swLTldWzAtOV0/KSQvZztcbmV4cG9ydHMuUkVfU1VCTkVUX1NUUklORyA9IC9cXC9cXGR7MSwyfSQvO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uc3RhbnRzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ip-address/dist/v4/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ip-address/dist/v6/constants.js":
/*!******************************************************!*\
  !*** ./node_modules/ip-address/dist/v6/constants.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.RE_URL_WITH_PORT = exports.RE_URL = exports.RE_ZONE_STRING = exports.RE_SUBNET_STRING = exports.RE_BAD_ADDRESS = exports.RE_BAD_CHARACTERS = exports.TYPES = exports.SCOPES = exports.GROUPS = exports.BITS = void 0;\nexports.BITS = 128;\nexports.GROUPS = 8;\n/**\n * Represents IPv6 address scopes\n * @memberof Address6\n * @static\n */\nexports.SCOPES = {\n    0: 'Reserved',\n    1: 'Interface local',\n    2: 'Link local',\n    4: 'Admin local',\n    5: 'Site local',\n    8: 'Organization local',\n    14: 'Global',\n    15: 'Reserved',\n};\n/**\n * Represents IPv6 address types\n * @memberof Address6\n * @static\n */\nexports.TYPES = {\n    'ff01::1/128': 'Multicast (All nodes on this interface)',\n    'ff01::2/128': 'Multicast (All routers on this interface)',\n    'ff02::1/128': 'Multicast (All nodes on this link)',\n    'ff02::2/128': 'Multicast (All routers on this link)',\n    'ff05::2/128': 'Multicast (All routers in this site)',\n    'ff02::5/128': 'Multicast (OSPFv3 AllSPF routers)',\n    'ff02::6/128': 'Multicast (OSPFv3 AllDR routers)',\n    'ff02::9/128': 'Multicast (RIP routers)',\n    'ff02::a/128': 'Multicast (EIGRP routers)',\n    'ff02::d/128': 'Multicast (PIM routers)',\n    'ff02::16/128': 'Multicast (MLDv2 reports)',\n    'ff01::fb/128': 'Multicast (mDNSv6)',\n    'ff02::fb/128': 'Multicast (mDNSv6)',\n    'ff05::fb/128': 'Multicast (mDNSv6)',\n    'ff02::1:2/128': 'Multicast (All DHCP servers and relay agents on this link)',\n    'ff05::1:2/128': 'Multicast (All DHCP servers and relay agents in this site)',\n    'ff02::1:3/128': 'Multicast (All DHCP servers on this link)',\n    'ff05::1:3/128': 'Multicast (All DHCP servers in this site)',\n    '::/128': 'Unspecified',\n    '::1/128': 'Loopback',\n    'ff00::/8': 'Multicast',\n    'fe80::/10': 'Link-local unicast',\n};\n/**\n * A regular expression that matches bad characters in an IPv6 address\n * @memberof Address6\n * @static\n */\nexports.RE_BAD_CHARACTERS = /([^0-9a-f:/%])/gi;\n/**\n * A regular expression that matches an incorrect IPv6 address\n * @memberof Address6\n * @static\n */\nexports.RE_BAD_ADDRESS = /([0-9a-f]{5,}|:{3,}|[^:]:$|^:[^:]|\\/$)/gi;\n/**\n * A regular expression that matches an IPv6 subnet\n * @memberof Address6\n * @static\n */\nexports.RE_SUBNET_STRING = /\\/\\d{1,3}(?=%|$)/;\n/**\n * A regular expression that matches an IPv6 zone\n * @memberof Address6\n * @static\n */\nexports.RE_ZONE_STRING = /%.*$/;\nexports.RE_URL = /^\\[{0,1}([0-9a-f:]+)\\]{0,1}/;\nexports.RE_URL_WITH_PORT = /\\[([0-9a-f:]+)\\]:([0-9]{1,5})/;\n//# sourceMappingURL=constants.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaXAtYWRkcmVzcy9kaXN0L3Y2L2NvbnN0YW50cy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx3QkFBd0IsR0FBRyxjQUFjLEdBQUcsc0JBQXNCLEdBQUcsd0JBQXdCLEdBQUcsc0JBQXNCLEdBQUcseUJBQXlCLEdBQUcsYUFBYSxHQUFHLGNBQWMsR0FBRyxjQUFjLEdBQUcsWUFBWTtBQUNuTixZQUFZO0FBQ1osY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGNBQWMsR0FBRyxHQUFHLEdBQUc7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixTQUFTLElBQUk7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QixjQUFjLFFBQVEsSUFBSSxlQUFlLElBQUk7QUFDN0Msd0JBQXdCLDRCQUE0QixJQUFJO0FBQ3hEIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXFNpbXBsZVxcRG93bmxvYWRzXFxQcm95ZWN0b0V4dHJhY3RvckRlRmlsYW1lbnRvXFxleHRyYWN0b3Itc2VydmVyXFxub2RlX21vZHVsZXNcXGlwLWFkZHJlc3NcXGRpc3RcXHY2XFxjb25zdGFudHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlJFX1VSTF9XSVRIX1BPUlQgPSBleHBvcnRzLlJFX1VSTCA9IGV4cG9ydHMuUkVfWk9ORV9TVFJJTkcgPSBleHBvcnRzLlJFX1NVQk5FVF9TVFJJTkcgPSBleHBvcnRzLlJFX0JBRF9BRERSRVNTID0gZXhwb3J0cy5SRV9CQURfQ0hBUkFDVEVSUyA9IGV4cG9ydHMuVFlQRVMgPSBleHBvcnRzLlNDT1BFUyA9IGV4cG9ydHMuR1JPVVBTID0gZXhwb3J0cy5CSVRTID0gdm9pZCAwO1xuZXhwb3J0cy5CSVRTID0gMTI4O1xuZXhwb3J0cy5HUk9VUFMgPSA4O1xuLyoqXG4gKiBSZXByZXNlbnRzIElQdjYgYWRkcmVzcyBzY29wZXNcbiAqIEBtZW1iZXJvZiBBZGRyZXNzNlxuICogQHN0YXRpY1xuICovXG5leHBvcnRzLlNDT1BFUyA9IHtcbiAgICAwOiAnUmVzZXJ2ZWQnLFxuICAgIDE6ICdJbnRlcmZhY2UgbG9jYWwnLFxuICAgIDI6ICdMaW5rIGxvY2FsJyxcbiAgICA0OiAnQWRtaW4gbG9jYWwnLFxuICAgIDU6ICdTaXRlIGxvY2FsJyxcbiAgICA4OiAnT3JnYW5pemF0aW9uIGxvY2FsJyxcbiAgICAxNDogJ0dsb2JhbCcsXG4gICAgMTU6ICdSZXNlcnZlZCcsXG59O1xuLyoqXG4gKiBSZXByZXNlbnRzIElQdjYgYWRkcmVzcyB0eXBlc1xuICogQG1lbWJlcm9mIEFkZHJlc3M2XG4gKiBAc3RhdGljXG4gKi9cbmV4cG9ydHMuVFlQRVMgPSB7XG4gICAgJ2ZmMDE6OjEvMTI4JzogJ011bHRpY2FzdCAoQWxsIG5vZGVzIG9uIHRoaXMgaW50ZXJmYWNlKScsXG4gICAgJ2ZmMDE6OjIvMTI4JzogJ011bHRpY2FzdCAoQWxsIHJvdXRlcnMgb24gdGhpcyBpbnRlcmZhY2UpJyxcbiAgICAnZmYwMjo6MS8xMjgnOiAnTXVsdGljYXN0IChBbGwgbm9kZXMgb24gdGhpcyBsaW5rKScsXG4gICAgJ2ZmMDI6OjIvMTI4JzogJ011bHRpY2FzdCAoQWxsIHJvdXRlcnMgb24gdGhpcyBsaW5rKScsXG4gICAgJ2ZmMDU6OjIvMTI4JzogJ011bHRpY2FzdCAoQWxsIHJvdXRlcnMgaW4gdGhpcyBzaXRlKScsXG4gICAgJ2ZmMDI6OjUvMTI4JzogJ011bHRpY2FzdCAoT1NQRnYzIEFsbFNQRiByb3V0ZXJzKScsXG4gICAgJ2ZmMDI6OjYvMTI4JzogJ011bHRpY2FzdCAoT1NQRnYzIEFsbERSIHJvdXRlcnMpJyxcbiAgICAnZmYwMjo6OS8xMjgnOiAnTXVsdGljYXN0IChSSVAgcm91dGVycyknLFxuICAgICdmZjAyOjphLzEyOCc6ICdNdWx0aWNhc3QgKEVJR1JQIHJvdXRlcnMpJyxcbiAgICAnZmYwMjo6ZC8xMjgnOiAnTXVsdGljYXN0IChQSU0gcm91dGVycyknLFxuICAgICdmZjAyOjoxNi8xMjgnOiAnTXVsdGljYXN0IChNTER2MiByZXBvcnRzKScsXG4gICAgJ2ZmMDE6OmZiLzEyOCc6ICdNdWx0aWNhc3QgKG1ETlN2NiknLFxuICAgICdmZjAyOjpmYi8xMjgnOiAnTXVsdGljYXN0IChtRE5TdjYpJyxcbiAgICAnZmYwNTo6ZmIvMTI4JzogJ011bHRpY2FzdCAobUROU3Y2KScsXG4gICAgJ2ZmMDI6OjE6Mi8xMjgnOiAnTXVsdGljYXN0IChBbGwgREhDUCBzZXJ2ZXJzIGFuZCByZWxheSBhZ2VudHMgb24gdGhpcyBsaW5rKScsXG4gICAgJ2ZmMDU6OjE6Mi8xMjgnOiAnTXVsdGljYXN0IChBbGwgREhDUCBzZXJ2ZXJzIGFuZCByZWxheSBhZ2VudHMgaW4gdGhpcyBzaXRlKScsXG4gICAgJ2ZmMDI6OjE6My8xMjgnOiAnTXVsdGljYXN0IChBbGwgREhDUCBzZXJ2ZXJzIG9uIHRoaXMgbGluayknLFxuICAgICdmZjA1OjoxOjMvMTI4JzogJ011bHRpY2FzdCAoQWxsIERIQ1Agc2VydmVycyBpbiB0aGlzIHNpdGUpJyxcbiAgICAnOjovMTI4JzogJ1Vuc3BlY2lmaWVkJyxcbiAgICAnOjoxLzEyOCc6ICdMb29wYmFjaycsXG4gICAgJ2ZmMDA6Oi84JzogJ011bHRpY2FzdCcsXG4gICAgJ2ZlODA6Oi8xMCc6ICdMaW5rLWxvY2FsIHVuaWNhc3QnLFxufTtcbi8qKlxuICogQSByZWd1bGFyIGV4cHJlc3Npb24gdGhhdCBtYXRjaGVzIGJhZCBjaGFyYWN0ZXJzIGluIGFuIElQdjYgYWRkcmVzc1xuICogQG1lbWJlcm9mIEFkZHJlc3M2XG4gKiBAc3RhdGljXG4gKi9cbmV4cG9ydHMuUkVfQkFEX0NIQVJBQ1RFUlMgPSAvKFteMC05YS1mOi8lXSkvZ2k7XG4vKipcbiAqIEEgcmVndWxhciBleHByZXNzaW9uIHRoYXQgbWF0Y2hlcyBhbiBpbmNvcnJlY3QgSVB2NiBhZGRyZXNzXG4gKiBAbWVtYmVyb2YgQWRkcmVzczZcbiAqIEBzdGF0aWNcbiAqL1xuZXhwb3J0cy5SRV9CQURfQUREUkVTUyA9IC8oWzAtOWEtZl17NSx9fDp7Myx9fFteOl06JHxeOlteOl18XFwvJCkvZ2k7XG4vKipcbiAqIEEgcmVndWxhciBleHByZXNzaW9uIHRoYXQgbWF0Y2hlcyBhbiBJUHY2IHN1Ym5ldFxuICogQG1lbWJlcm9mIEFkZHJlc3M2XG4gKiBAc3RhdGljXG4gKi9cbmV4cG9ydHMuUkVfU1VCTkVUX1NUUklORyA9IC9cXC9cXGR7MSwzfSg/PSV8JCkvO1xuLyoqXG4gKiBBIHJlZ3VsYXIgZXhwcmVzc2lvbiB0aGF0IG1hdGNoZXMgYW4gSVB2NiB6b25lXG4gKiBAbWVtYmVyb2YgQWRkcmVzczZcbiAqIEBzdGF0aWNcbiAqL1xuZXhwb3J0cy5SRV9aT05FX1NUUklORyA9IC8lLiokLztcbmV4cG9ydHMuUkVfVVJMID0gL15cXFt7MCwxfShbMC05YS1mOl0rKVxcXXswLDF9LztcbmV4cG9ydHMuUkVfVVJMX1dJVEhfUE9SVCA9IC9cXFsoWzAtOWEtZjpdKylcXF06KFswLTldezEsNX0pLztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnN0YW50cy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ip-address/dist/v6/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ip-address/dist/v6/helpers.js":
/*!****************************************************!*\
  !*** ./node_modules/ip-address/dist/v6/helpers.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.spanAllZeroes = spanAllZeroes;\nexports.spanAll = spanAll;\nexports.spanLeadingZeroes = spanLeadingZeroes;\nexports.simpleGroup = simpleGroup;\n/**\n * @returns {String} the string with all zeroes contained in a <span>\n */\nfunction spanAllZeroes(s) {\n    return s.replace(/(0+)/g, '<span class=\"zero\">$1</span>');\n}\n/**\n * @returns {String} the string with each character contained in a <span>\n */\nfunction spanAll(s, offset = 0) {\n    const letters = s.split('');\n    return letters\n        .map((n, i) => `<span class=\"digit value-${n} position-${i + offset}\">${spanAllZeroes(n)}</span>`)\n        .join('');\n}\nfunction spanLeadingZeroesSimple(group) {\n    return group.replace(/^(0+)/, '<span class=\"zero\">$1</span>');\n}\n/**\n * @returns {String} the string with leading zeroes contained in a <span>\n */\nfunction spanLeadingZeroes(address) {\n    const groups = address.split(':');\n    return groups.map((g) => spanLeadingZeroesSimple(g)).join(':');\n}\n/**\n * Groups an address\n * @returns {String} a grouped address\n */\nfunction simpleGroup(addressString, offset = 0) {\n    const groups = addressString.split(':');\n    return groups.map((g, i) => {\n        if (/group-v4/.test(g)) {\n            return g;\n        }\n        return `<span class=\"hover-group group-${i + offset}\">${spanLeadingZeroesSimple(g)}</span>`;\n    });\n}\n//# sourceMappingURL=helpers.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaXAtYWRkcmVzcy9kaXN0L3Y2L2hlbHBlcnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QscUJBQXFCO0FBQ3JCLGVBQWU7QUFDZix5QkFBeUI7QUFDekIsbUJBQW1CO0FBQ25CO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsR0FBRyxXQUFXLFdBQVcsSUFBSSxpQkFBaUI7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELFdBQVcsSUFBSSwyQkFBMkI7QUFDM0YsS0FBSztBQUNMO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcU2ltcGxlXFxEb3dubG9hZHNcXFByb3llY3RvRXh0cmFjdG9yRGVGaWxhbWVudG9cXGV4dHJhY3Rvci1zZXJ2ZXJcXG5vZGVfbW9kdWxlc1xcaXAtYWRkcmVzc1xcZGlzdFxcdjZcXGhlbHBlcnMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnNwYW5BbGxaZXJvZXMgPSBzcGFuQWxsWmVyb2VzO1xuZXhwb3J0cy5zcGFuQWxsID0gc3BhbkFsbDtcbmV4cG9ydHMuc3BhbkxlYWRpbmdaZXJvZXMgPSBzcGFuTGVhZGluZ1plcm9lcztcbmV4cG9ydHMuc2ltcGxlR3JvdXAgPSBzaW1wbGVHcm91cDtcbi8qKlxuICogQHJldHVybnMge1N0cmluZ30gdGhlIHN0cmluZyB3aXRoIGFsbCB6ZXJvZXMgY29udGFpbmVkIGluIGEgPHNwYW4+XG4gKi9cbmZ1bmN0aW9uIHNwYW5BbGxaZXJvZXMocykge1xuICAgIHJldHVybiBzLnJlcGxhY2UoLygwKykvZywgJzxzcGFuIGNsYXNzPVwiemVyb1wiPiQxPC9zcGFuPicpO1xufVxuLyoqXG4gKiBAcmV0dXJucyB7U3RyaW5nfSB0aGUgc3RyaW5nIHdpdGggZWFjaCBjaGFyYWN0ZXIgY29udGFpbmVkIGluIGEgPHNwYW4+XG4gKi9cbmZ1bmN0aW9uIHNwYW5BbGwocywgb2Zmc2V0ID0gMCkge1xuICAgIGNvbnN0IGxldHRlcnMgPSBzLnNwbGl0KCcnKTtcbiAgICByZXR1cm4gbGV0dGVyc1xuICAgICAgICAubWFwKChuLCBpKSA9PiBgPHNwYW4gY2xhc3M9XCJkaWdpdCB2YWx1ZS0ke259IHBvc2l0aW9uLSR7aSArIG9mZnNldH1cIj4ke3NwYW5BbGxaZXJvZXMobil9PC9zcGFuPmApXG4gICAgICAgIC5qb2luKCcnKTtcbn1cbmZ1bmN0aW9uIHNwYW5MZWFkaW5nWmVyb2VzU2ltcGxlKGdyb3VwKSB7XG4gICAgcmV0dXJuIGdyb3VwLnJlcGxhY2UoL14oMCspLywgJzxzcGFuIGNsYXNzPVwiemVyb1wiPiQxPC9zcGFuPicpO1xufVxuLyoqXG4gKiBAcmV0dXJucyB7U3RyaW5nfSB0aGUgc3RyaW5nIHdpdGggbGVhZGluZyB6ZXJvZXMgY29udGFpbmVkIGluIGEgPHNwYW4+XG4gKi9cbmZ1bmN0aW9uIHNwYW5MZWFkaW5nWmVyb2VzKGFkZHJlc3MpIHtcbiAgICBjb25zdCBncm91cHMgPSBhZGRyZXNzLnNwbGl0KCc6Jyk7XG4gICAgcmV0dXJuIGdyb3Vwcy5tYXAoKGcpID0+IHNwYW5MZWFkaW5nWmVyb2VzU2ltcGxlKGcpKS5qb2luKCc6Jyk7XG59XG4vKipcbiAqIEdyb3VwcyBhbiBhZGRyZXNzXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBhIGdyb3VwZWQgYWRkcmVzc1xuICovXG5mdW5jdGlvbiBzaW1wbGVHcm91cChhZGRyZXNzU3RyaW5nLCBvZmZzZXQgPSAwKSB7XG4gICAgY29uc3QgZ3JvdXBzID0gYWRkcmVzc1N0cmluZy5zcGxpdCgnOicpO1xuICAgIHJldHVybiBncm91cHMubWFwKChnLCBpKSA9PiB7XG4gICAgICAgIGlmICgvZ3JvdXAtdjQvLnRlc3QoZykpIHtcbiAgICAgICAgICAgIHJldHVybiBnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgPHNwYW4gY2xhc3M9XCJob3Zlci1ncm91cCBncm91cC0ke2kgKyBvZmZzZXR9XCI+JHtzcGFuTGVhZGluZ1plcm9lc1NpbXBsZShnKX08L3NwYW4+YDtcbiAgICB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhlbHBlcnMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ip-address/dist/v6/helpers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ip-address/dist/v6/regular-expressions.js":
/*!****************************************************************!*\
  !*** ./node_modules/ip-address/dist/v6/regular-expressions.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ADDRESS_BOUNDARY = void 0;\nexports.groupPossibilities = groupPossibilities;\nexports.padGroup = padGroup;\nexports.simpleRegularExpression = simpleRegularExpression;\nexports.possibleElisions = possibleElisions;\nconst v6 = __importStar(__webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/ip-address/dist/v6/constants.js\"));\nfunction groupPossibilities(possibilities) {\n    return `(${possibilities.join('|')})`;\n}\nfunction padGroup(group) {\n    if (group.length < 4) {\n        return `0{0,${4 - group.length}}${group}`;\n    }\n    return group;\n}\nexports.ADDRESS_BOUNDARY = '[^A-Fa-f0-9:]';\nfunction simpleRegularExpression(groups) {\n    const zeroIndexes = [];\n    groups.forEach((group, i) => {\n        const groupInteger = parseInt(group, 16);\n        if (groupInteger === 0) {\n            zeroIndexes.push(i);\n        }\n    });\n    // You can technically elide a single 0, this creates the regular expressions\n    // to match that eventuality\n    const possibilities = zeroIndexes.map((zeroIndex) => groups\n        .map((group, i) => {\n        if (i === zeroIndex) {\n            const elision = i === 0 || i === v6.GROUPS - 1 ? ':' : '';\n            return groupPossibilities([padGroup(group), elision]);\n        }\n        return padGroup(group);\n    })\n        .join(':'));\n    // The simplest case\n    possibilities.push(groups.map(padGroup).join(':'));\n    return groupPossibilities(possibilities);\n}\nfunction possibleElisions(elidedGroups, moreLeft, moreRight) {\n    const left = moreLeft ? '' : ':';\n    const right = moreRight ? '' : ':';\n    const possibilities = [];\n    // 1. elision of everything (::)\n    if (!moreLeft && !moreRight) {\n        possibilities.push('::');\n    }\n    // 2. complete elision of the middle\n    if (moreLeft && moreRight) {\n        possibilities.push('');\n    }\n    if ((moreRight && !moreLeft) || (!moreRight && moreLeft)) {\n        // 3. complete elision of one side\n        possibilities.push(':');\n    }\n    // 4. elision from the left side\n    possibilities.push(`${left}(:0{1,4}){1,${elidedGroups - 1}}`);\n    // 5. elision from the right side\n    possibilities.push(`(0{1,4}:){1,${elidedGroups - 1}}${right}`);\n    // 6. no elision\n    possibilities.push(`(0{1,4}:){${elidedGroups - 1}}0{1,4}`);\n    // 7. elision (including sloppy elision) from the middle\n    for (let groups = 1; groups < elidedGroups - 1; groups++) {\n        for (let position = 1; position < elidedGroups - groups; position++) {\n            possibilities.push(`(0{1,4}:){${position}}:(0{1,4}:){${elidedGroups - position - groups - 1}}0{1,4}`);\n        }\n    }\n    return groupPossibilities(possibilities);\n}\n//# sourceMappingURL=regular-expressions.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaXAtYWRkcmVzcy9kaXN0L3Y2L3JlZ3VsYXItZXhwcmVzc2lvbnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDBDQUEwQyw0QkFBNEI7QUFDdEUsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHdCQUF3QjtBQUN4QiwwQkFBMEI7QUFDMUIsZ0JBQWdCO0FBQ2hCLCtCQUErQjtBQUMvQix3QkFBd0I7QUFDeEIsd0JBQXdCLG1CQUFPLENBQUMseUVBQWE7QUFDN0M7QUFDQSxlQUFlLHdCQUF3QjtBQUN2QztBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsSUFBSSxrQkFBa0IsRUFBRSxNQUFNO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsS0FBSyxJQUFJLElBQUksRUFBRSxJQUFJLGtCQUFrQjtBQUMvRDtBQUNBLDJCQUEyQixJQUFJLEdBQUcsSUFBSSxrQkFBa0IsRUFBRSxNQUFNO0FBQ2hFO0FBQ0EsMkJBQTJCLElBQUksR0FBRyxFQUFFLGtCQUFrQixFQUFFLElBQUk7QUFDNUQ7QUFDQSx5QkFBeUIsMkJBQTJCO0FBQ3BELCtCQUErQixrQ0FBa0M7QUFDakUsbUNBQW1DLElBQUksR0FBRyxFQUFFLFVBQVUsSUFBSSxJQUFJLEdBQUcsRUFBRSxzQ0FBc0MsRUFBRSxJQUFJO0FBQy9HO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcU2ltcGxlXFxEb3dubG9hZHNcXFByb3llY3RvRXh0cmFjdG9yRGVGaWxhbWVudG9cXGV4dHJhY3Rvci1zZXJ2ZXJcXG5vZGVfbW9kdWxlc1xcaXAtYWRkcmVzc1xcZGlzdFxcdjZcXHJlZ3VsYXItZXhwcmVzc2lvbnMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQUREUkVTU19CT1VOREFSWSA9IHZvaWQgMDtcbmV4cG9ydHMuZ3JvdXBQb3NzaWJpbGl0aWVzID0gZ3JvdXBQb3NzaWJpbGl0aWVzO1xuZXhwb3J0cy5wYWRHcm91cCA9IHBhZEdyb3VwO1xuZXhwb3J0cy5zaW1wbGVSZWd1bGFyRXhwcmVzc2lvbiA9IHNpbXBsZVJlZ3VsYXJFeHByZXNzaW9uO1xuZXhwb3J0cy5wb3NzaWJsZUVsaXNpb25zID0gcG9zc2libGVFbGlzaW9ucztcbmNvbnN0IHY2ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKSk7XG5mdW5jdGlvbiBncm91cFBvc3NpYmlsaXRpZXMocG9zc2liaWxpdGllcykge1xuICAgIHJldHVybiBgKCR7cG9zc2liaWxpdGllcy5qb2luKCd8Jyl9KWA7XG59XG5mdW5jdGlvbiBwYWRHcm91cChncm91cCkge1xuICAgIGlmIChncm91cC5sZW5ndGggPCA0KSB7XG4gICAgICAgIHJldHVybiBgMHswLCR7NCAtIGdyb3VwLmxlbmd0aH19JHtncm91cH1gO1xuICAgIH1cbiAgICByZXR1cm4gZ3JvdXA7XG59XG5leHBvcnRzLkFERFJFU1NfQk9VTkRBUlkgPSAnW15BLUZhLWYwLTk6XSc7XG5mdW5jdGlvbiBzaW1wbGVSZWd1bGFyRXhwcmVzc2lvbihncm91cHMpIHtcbiAgICBjb25zdCB6ZXJvSW5kZXhlcyA9IFtdO1xuICAgIGdyb3Vwcy5mb3JFYWNoKChncm91cCwgaSkgPT4ge1xuICAgICAgICBjb25zdCBncm91cEludGVnZXIgPSBwYXJzZUludChncm91cCwgMTYpO1xuICAgICAgICBpZiAoZ3JvdXBJbnRlZ2VyID09PSAwKSB7XG4gICAgICAgICAgICB6ZXJvSW5kZXhlcy5wdXNoKGkpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgLy8gWW91IGNhbiB0ZWNobmljYWxseSBlbGlkZSBhIHNpbmdsZSAwLCB0aGlzIGNyZWF0ZXMgdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbnNcbiAgICAvLyB0byBtYXRjaCB0aGF0IGV2ZW50dWFsaXR5XG4gICAgY29uc3QgcG9zc2liaWxpdGllcyA9IHplcm9JbmRleGVzLm1hcCgoemVyb0luZGV4KSA9PiBncm91cHNcbiAgICAgICAgLm1hcCgoZ3JvdXAsIGkpID0+IHtcbiAgICAgICAgaWYgKGkgPT09IHplcm9JbmRleCkge1xuICAgICAgICAgICAgY29uc3QgZWxpc2lvbiA9IGkgPT09IDAgfHwgaSA9PT0gdjYuR1JPVVBTIC0gMSA/ICc6JyA6ICcnO1xuICAgICAgICAgICAgcmV0dXJuIGdyb3VwUG9zc2liaWxpdGllcyhbcGFkR3JvdXAoZ3JvdXApLCBlbGlzaW9uXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhZEdyb3VwKGdyb3VwKTtcbiAgICB9KVxuICAgICAgICAuam9pbignOicpKTtcbiAgICAvLyBUaGUgc2ltcGxlc3QgY2FzZVxuICAgIHBvc3NpYmlsaXRpZXMucHVzaChncm91cHMubWFwKHBhZEdyb3VwKS5qb2luKCc6JykpO1xuICAgIHJldHVybiBncm91cFBvc3NpYmlsaXRpZXMocG9zc2liaWxpdGllcyk7XG59XG5mdW5jdGlvbiBwb3NzaWJsZUVsaXNpb25zKGVsaWRlZEdyb3VwcywgbW9yZUxlZnQsIG1vcmVSaWdodCkge1xuICAgIGNvbnN0IGxlZnQgPSBtb3JlTGVmdCA/ICcnIDogJzonO1xuICAgIGNvbnN0IHJpZ2h0ID0gbW9yZVJpZ2h0ID8gJycgOiAnOic7XG4gICAgY29uc3QgcG9zc2liaWxpdGllcyA9IFtdO1xuICAgIC8vIDEuIGVsaXNpb24gb2YgZXZlcnl0aGluZyAoOjopXG4gICAgaWYgKCFtb3JlTGVmdCAmJiAhbW9yZVJpZ2h0KSB7XG4gICAgICAgIHBvc3NpYmlsaXRpZXMucHVzaCgnOjonKTtcbiAgICB9XG4gICAgLy8gMi4gY29tcGxldGUgZWxpc2lvbiBvZiB0aGUgbWlkZGxlXG4gICAgaWYgKG1vcmVMZWZ0ICYmIG1vcmVSaWdodCkge1xuICAgICAgICBwb3NzaWJpbGl0aWVzLnB1c2goJycpO1xuICAgIH1cbiAgICBpZiAoKG1vcmVSaWdodCAmJiAhbW9yZUxlZnQpIHx8ICghbW9yZVJpZ2h0ICYmIG1vcmVMZWZ0KSkge1xuICAgICAgICAvLyAzLiBjb21wbGV0ZSBlbGlzaW9uIG9mIG9uZSBzaWRlXG4gICAgICAgIHBvc3NpYmlsaXRpZXMucHVzaCgnOicpO1xuICAgIH1cbiAgICAvLyA0LiBlbGlzaW9uIGZyb20gdGhlIGxlZnQgc2lkZVxuICAgIHBvc3NpYmlsaXRpZXMucHVzaChgJHtsZWZ0fSg6MHsxLDR9KXsxLCR7ZWxpZGVkR3JvdXBzIC0gMX19YCk7XG4gICAgLy8gNS4gZWxpc2lvbiBmcm9tIHRoZSByaWdodCBzaWRlXG4gICAgcG9zc2liaWxpdGllcy5wdXNoKGAoMHsxLDR9Oil7MSwke2VsaWRlZEdyb3VwcyAtIDF9fSR7cmlnaHR9YCk7XG4gICAgLy8gNi4gbm8gZWxpc2lvblxuICAgIHBvc3NpYmlsaXRpZXMucHVzaChgKDB7MSw0fTopeyR7ZWxpZGVkR3JvdXBzIC0gMX19MHsxLDR9YCk7XG4gICAgLy8gNy4gZWxpc2lvbiAoaW5jbHVkaW5nIHNsb3BweSBlbGlzaW9uKSBmcm9tIHRoZSBtaWRkbGVcbiAgICBmb3IgKGxldCBncm91cHMgPSAxOyBncm91cHMgPCBlbGlkZWRHcm91cHMgLSAxOyBncm91cHMrKykge1xuICAgICAgICBmb3IgKGxldCBwb3NpdGlvbiA9IDE7IHBvc2l0aW9uIDwgZWxpZGVkR3JvdXBzIC0gZ3JvdXBzOyBwb3NpdGlvbisrKSB7XG4gICAgICAgICAgICBwb3NzaWJpbGl0aWVzLnB1c2goYCgwezEsNH06KXske3Bvc2l0aW9ufX06KDB7MSw0fTopeyR7ZWxpZGVkR3JvdXBzIC0gcG9zaXRpb24gLSBncm91cHMgLSAxfX0wezEsNH1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZ3JvdXBQb3NzaWJpbGl0aWVzKHBvc3NpYmlsaXRpZXMpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVndWxhci1leHByZXNzaW9ucy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ip-address/dist/v6/regular-expressions.js\n");

/***/ })

};
;