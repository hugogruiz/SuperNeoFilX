"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/smart-buffer";
exports.ids = ["vendor-chunks/smart-buffer"];
exports.modules = {

/***/ "(ssr)/./node_modules/smart-buffer/build/smartbuffer.js":
/*!********************************************************!*\
  !*** ./node_modules/smart-buffer/build/smartbuffer.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/smart-buffer/build/utils.js\");\n// The default Buffer size if one is not provided.\nconst DEFAULT_SMARTBUFFER_SIZE = 4096;\n// The default string encoding to use for reading/writing strings.\nconst DEFAULT_SMARTBUFFER_ENCODING = 'utf8';\nclass SmartBuffer {\n    /**\n     * Creates a new SmartBuffer instance.\n     *\n     * @param options { SmartBufferOptions } The SmartBufferOptions to apply to this instance.\n     */\n    constructor(options) {\n        this.length = 0;\n        this._encoding = DEFAULT_SMARTBUFFER_ENCODING;\n        this._writeOffset = 0;\n        this._readOffset = 0;\n        if (SmartBuffer.isSmartBufferOptions(options)) {\n            // Checks for encoding\n            if (options.encoding) {\n                utils_1.checkEncoding(options.encoding);\n                this._encoding = options.encoding;\n            }\n            // Checks for initial size length\n            if (options.size) {\n                if (utils_1.isFiniteInteger(options.size) && options.size > 0) {\n                    this._buff = Buffer.allocUnsafe(options.size);\n                }\n                else {\n                    throw new Error(utils_1.ERRORS.INVALID_SMARTBUFFER_SIZE);\n                }\n                // Check for initial Buffer\n            }\n            else if (options.buff) {\n                if (Buffer.isBuffer(options.buff)) {\n                    this._buff = options.buff;\n                    this.length = options.buff.length;\n                }\n                else {\n                    throw new Error(utils_1.ERRORS.INVALID_SMARTBUFFER_BUFFER);\n                }\n            }\n            else {\n                this._buff = Buffer.allocUnsafe(DEFAULT_SMARTBUFFER_SIZE);\n            }\n        }\n        else {\n            // If something was passed but it's not a SmartBufferOptions object\n            if (typeof options !== 'undefined') {\n                throw new Error(utils_1.ERRORS.INVALID_SMARTBUFFER_OBJECT);\n            }\n            // Otherwise default to sane options\n            this._buff = Buffer.allocUnsafe(DEFAULT_SMARTBUFFER_SIZE);\n        }\n    }\n    /**\n     * Creates a new SmartBuffer instance with the provided internal Buffer size and optional encoding.\n     *\n     * @param size { Number } The size of the internal Buffer.\n     * @param encoding { String } The BufferEncoding to use for strings.\n     *\n     * @return { SmartBuffer }\n     */\n    static fromSize(size, encoding) {\n        return new this({\n            size: size,\n            encoding: encoding\n        });\n    }\n    /**\n     * Creates a new SmartBuffer instance with the provided Buffer and optional encoding.\n     *\n     * @param buffer { Buffer } The Buffer to use as the internal Buffer value.\n     * @param encoding { String } The BufferEncoding to use for strings.\n     *\n     * @return { SmartBuffer }\n     */\n    static fromBuffer(buff, encoding) {\n        return new this({\n            buff: buff,\n            encoding: encoding\n        });\n    }\n    /**\n     * Creates a new SmartBuffer instance with the provided SmartBufferOptions options.\n     *\n     * @param options { SmartBufferOptions } The options to use when creating the SmartBuffer instance.\n     */\n    static fromOptions(options) {\n        return new this(options);\n    }\n    /**\n     * Type checking function that determines if an object is a SmartBufferOptions object.\n     */\n    static isSmartBufferOptions(options) {\n        const castOptions = options;\n        return (castOptions &&\n            (castOptions.encoding !== undefined || castOptions.size !== undefined || castOptions.buff !== undefined));\n    }\n    // Signed integers\n    /**\n     * Reads an Int8 value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { Number }\n     */\n    readInt8(offset) {\n        return this._readNumberValue(Buffer.prototype.readInt8, 1, offset);\n    }\n    /**\n     * Reads an Int16BE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { Number }\n     */\n    readInt16BE(offset) {\n        return this._readNumberValue(Buffer.prototype.readInt16BE, 2, offset);\n    }\n    /**\n     * Reads an Int16LE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { Number }\n     */\n    readInt16LE(offset) {\n        return this._readNumberValue(Buffer.prototype.readInt16LE, 2, offset);\n    }\n    /**\n     * Reads an Int32BE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { Number }\n     */\n    readInt32BE(offset) {\n        return this._readNumberValue(Buffer.prototype.readInt32BE, 4, offset);\n    }\n    /**\n     * Reads an Int32LE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { Number }\n     */\n    readInt32LE(offset) {\n        return this._readNumberValue(Buffer.prototype.readInt32LE, 4, offset);\n    }\n    /**\n     * Reads a BigInt64BE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { BigInt }\n     */\n    readBigInt64BE(offset) {\n        utils_1.bigIntAndBufferInt64Check('readBigInt64BE');\n        return this._readNumberValue(Buffer.prototype.readBigInt64BE, 8, offset);\n    }\n    /**\n     * Reads a BigInt64LE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { BigInt }\n     */\n    readBigInt64LE(offset) {\n        utils_1.bigIntAndBufferInt64Check('readBigInt64LE');\n        return this._readNumberValue(Buffer.prototype.readBigInt64LE, 8, offset);\n    }\n    /**\n     * Writes an Int8 value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */\n    writeInt8(value, offset) {\n        this._writeNumberValue(Buffer.prototype.writeInt8, 1, value, offset);\n        return this;\n    }\n    /**\n     * Inserts an Int8 value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */\n    insertInt8(value, offset) {\n        return this._insertNumberValue(Buffer.prototype.writeInt8, 1, value, offset);\n    }\n    /**\n     * Writes an Int16BE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */\n    writeInt16BE(value, offset) {\n        return this._writeNumberValue(Buffer.prototype.writeInt16BE, 2, value, offset);\n    }\n    /**\n     * Inserts an Int16BE value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */\n    insertInt16BE(value, offset) {\n        return this._insertNumberValue(Buffer.prototype.writeInt16BE, 2, value, offset);\n    }\n    /**\n     * Writes an Int16LE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */\n    writeInt16LE(value, offset) {\n        return this._writeNumberValue(Buffer.prototype.writeInt16LE, 2, value, offset);\n    }\n    /**\n     * Inserts an Int16LE value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */\n    insertInt16LE(value, offset) {\n        return this._insertNumberValue(Buffer.prototype.writeInt16LE, 2, value, offset);\n    }\n    /**\n     * Writes an Int32BE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */\n    writeInt32BE(value, offset) {\n        return this._writeNumberValue(Buffer.prototype.writeInt32BE, 4, value, offset);\n    }\n    /**\n     * Inserts an Int32BE value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */\n    insertInt32BE(value, offset) {\n        return this._insertNumberValue(Buffer.prototype.writeInt32BE, 4, value, offset);\n    }\n    /**\n     * Writes an Int32LE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */\n    writeInt32LE(value, offset) {\n        return this._writeNumberValue(Buffer.prototype.writeInt32LE, 4, value, offset);\n    }\n    /**\n     * Inserts an Int32LE value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */\n    insertInt32LE(value, offset) {\n        return this._insertNumberValue(Buffer.prototype.writeInt32LE, 4, value, offset);\n    }\n    /**\n     * Writes a BigInt64BE value to the current write position (or at optional offset).\n     *\n     * @param value { BigInt } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */\n    writeBigInt64BE(value, offset) {\n        utils_1.bigIntAndBufferInt64Check('writeBigInt64BE');\n        return this._writeNumberValue(Buffer.prototype.writeBigInt64BE, 8, value, offset);\n    }\n    /**\n     * Inserts a BigInt64BE value at the given offset value.\n     *\n     * @param value { BigInt } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */\n    insertBigInt64BE(value, offset) {\n        utils_1.bigIntAndBufferInt64Check('writeBigInt64BE');\n        return this._insertNumberValue(Buffer.prototype.writeBigInt64BE, 8, value, offset);\n    }\n    /**\n     * Writes a BigInt64LE value to the current write position (or at optional offset).\n     *\n     * @param value { BigInt } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */\n    writeBigInt64LE(value, offset) {\n        utils_1.bigIntAndBufferInt64Check('writeBigInt64LE');\n        return this._writeNumberValue(Buffer.prototype.writeBigInt64LE, 8, value, offset);\n    }\n    /**\n     * Inserts a Int64LE value at the given offset value.\n     *\n     * @param value { BigInt } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */\n    insertBigInt64LE(value, offset) {\n        utils_1.bigIntAndBufferInt64Check('writeBigInt64LE');\n        return this._insertNumberValue(Buffer.prototype.writeBigInt64LE, 8, value, offset);\n    }\n    // Unsigned Integers\n    /**\n     * Reads an UInt8 value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { Number }\n     */\n    readUInt8(offset) {\n        return this._readNumberValue(Buffer.prototype.readUInt8, 1, offset);\n    }\n    /**\n     * Reads an UInt16BE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { Number }\n     */\n    readUInt16BE(offset) {\n        return this._readNumberValue(Buffer.prototype.readUInt16BE, 2, offset);\n    }\n    /**\n     * Reads an UInt16LE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { Number }\n     */\n    readUInt16LE(offset) {\n        return this._readNumberValue(Buffer.prototype.readUInt16LE, 2, offset);\n    }\n    /**\n     * Reads an UInt32BE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { Number }\n     */\n    readUInt32BE(offset) {\n        return this._readNumberValue(Buffer.prototype.readUInt32BE, 4, offset);\n    }\n    /**\n     * Reads an UInt32LE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { Number }\n     */\n    readUInt32LE(offset) {\n        return this._readNumberValue(Buffer.prototype.readUInt32LE, 4, offset);\n    }\n    /**\n     * Reads a BigUInt64BE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { BigInt }\n     */\n    readBigUInt64BE(offset) {\n        utils_1.bigIntAndBufferInt64Check('readBigUInt64BE');\n        return this._readNumberValue(Buffer.prototype.readBigUInt64BE, 8, offset);\n    }\n    /**\n     * Reads a BigUInt64LE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { BigInt }\n     */\n    readBigUInt64LE(offset) {\n        utils_1.bigIntAndBufferInt64Check('readBigUInt64LE');\n        return this._readNumberValue(Buffer.prototype.readBigUInt64LE, 8, offset);\n    }\n    /**\n     * Writes an UInt8 value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */\n    writeUInt8(value, offset) {\n        return this._writeNumberValue(Buffer.prototype.writeUInt8, 1, value, offset);\n    }\n    /**\n     * Inserts an UInt8 value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */\n    insertUInt8(value, offset) {\n        return this._insertNumberValue(Buffer.prototype.writeUInt8, 1, value, offset);\n    }\n    /**\n     * Writes an UInt16BE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */\n    writeUInt16BE(value, offset) {\n        return this._writeNumberValue(Buffer.prototype.writeUInt16BE, 2, value, offset);\n    }\n    /**\n     * Inserts an UInt16BE value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */\n    insertUInt16BE(value, offset) {\n        return this._insertNumberValue(Buffer.prototype.writeUInt16BE, 2, value, offset);\n    }\n    /**\n     * Writes an UInt16LE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */\n    writeUInt16LE(value, offset) {\n        return this._writeNumberValue(Buffer.prototype.writeUInt16LE, 2, value, offset);\n    }\n    /**\n     * Inserts an UInt16LE value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */\n    insertUInt16LE(value, offset) {\n        return this._insertNumberValue(Buffer.prototype.writeUInt16LE, 2, value, offset);\n    }\n    /**\n     * Writes an UInt32BE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */\n    writeUInt32BE(value, offset) {\n        return this._writeNumberValue(Buffer.prototype.writeUInt32BE, 4, value, offset);\n    }\n    /**\n     * Inserts an UInt32BE value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */\n    insertUInt32BE(value, offset) {\n        return this._insertNumberValue(Buffer.prototype.writeUInt32BE, 4, value, offset);\n    }\n    /**\n     * Writes an UInt32LE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */\n    writeUInt32LE(value, offset) {\n        return this._writeNumberValue(Buffer.prototype.writeUInt32LE, 4, value, offset);\n    }\n    /**\n     * Inserts an UInt32LE value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */\n    insertUInt32LE(value, offset) {\n        return this._insertNumberValue(Buffer.prototype.writeUInt32LE, 4, value, offset);\n    }\n    /**\n     * Writes a BigUInt64BE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */\n    writeBigUInt64BE(value, offset) {\n        utils_1.bigIntAndBufferInt64Check('writeBigUInt64BE');\n        return this._writeNumberValue(Buffer.prototype.writeBigUInt64BE, 8, value, offset);\n    }\n    /**\n     * Inserts a BigUInt64BE value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */\n    insertBigUInt64BE(value, offset) {\n        utils_1.bigIntAndBufferInt64Check('writeBigUInt64BE');\n        return this._insertNumberValue(Buffer.prototype.writeBigUInt64BE, 8, value, offset);\n    }\n    /**\n     * Writes a BigUInt64LE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */\n    writeBigUInt64LE(value, offset) {\n        utils_1.bigIntAndBufferInt64Check('writeBigUInt64LE');\n        return this._writeNumberValue(Buffer.prototype.writeBigUInt64LE, 8, value, offset);\n    }\n    /**\n     * Inserts a BigUInt64LE value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */\n    insertBigUInt64LE(value, offset) {\n        utils_1.bigIntAndBufferInt64Check('writeBigUInt64LE');\n        return this._insertNumberValue(Buffer.prototype.writeBigUInt64LE, 8, value, offset);\n    }\n    // Floating Point\n    /**\n     * Reads an FloatBE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { Number }\n     */\n    readFloatBE(offset) {\n        return this._readNumberValue(Buffer.prototype.readFloatBE, 4, offset);\n    }\n    /**\n     * Reads an FloatLE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { Number }\n     */\n    readFloatLE(offset) {\n        return this._readNumberValue(Buffer.prototype.readFloatLE, 4, offset);\n    }\n    /**\n     * Writes a FloatBE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */\n    writeFloatBE(value, offset) {\n        return this._writeNumberValue(Buffer.prototype.writeFloatBE, 4, value, offset);\n    }\n    /**\n     * Inserts a FloatBE value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */\n    insertFloatBE(value, offset) {\n        return this._insertNumberValue(Buffer.prototype.writeFloatBE, 4, value, offset);\n    }\n    /**\n     * Writes a FloatLE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */\n    writeFloatLE(value, offset) {\n        return this._writeNumberValue(Buffer.prototype.writeFloatLE, 4, value, offset);\n    }\n    /**\n     * Inserts a FloatLE value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */\n    insertFloatLE(value, offset) {\n        return this._insertNumberValue(Buffer.prototype.writeFloatLE, 4, value, offset);\n    }\n    // Double Floating Point\n    /**\n     * Reads an DoublEBE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { Number }\n     */\n    readDoubleBE(offset) {\n        return this._readNumberValue(Buffer.prototype.readDoubleBE, 8, offset);\n    }\n    /**\n     * Reads an DoubleLE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { Number }\n     */\n    readDoubleLE(offset) {\n        return this._readNumberValue(Buffer.prototype.readDoubleLE, 8, offset);\n    }\n    /**\n     * Writes a DoubleBE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */\n    writeDoubleBE(value, offset) {\n        return this._writeNumberValue(Buffer.prototype.writeDoubleBE, 8, value, offset);\n    }\n    /**\n     * Inserts a DoubleBE value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */\n    insertDoubleBE(value, offset) {\n        return this._insertNumberValue(Buffer.prototype.writeDoubleBE, 8, value, offset);\n    }\n    /**\n     * Writes a DoubleLE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */\n    writeDoubleLE(value, offset) {\n        return this._writeNumberValue(Buffer.prototype.writeDoubleLE, 8, value, offset);\n    }\n    /**\n     * Inserts a DoubleLE value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */\n    insertDoubleLE(value, offset) {\n        return this._insertNumberValue(Buffer.prototype.writeDoubleLE, 8, value, offset);\n    }\n    // Strings\n    /**\n     * Reads a String from the current read position.\n     *\n     * @param arg1 { Number | String } The number of bytes to read as a String, or the BufferEncoding to use for\n     *             the string (Defaults to instance level encoding).\n     * @param encoding { String } The BufferEncoding to use for the string (Defaults to instance level encoding).\n     *\n     * @return { String }\n     */\n    readString(arg1, encoding) {\n        let lengthVal;\n        // Length provided\n        if (typeof arg1 === 'number') {\n            utils_1.checkLengthValue(arg1);\n            lengthVal = Math.min(arg1, this.length - this._readOffset);\n        }\n        else {\n            encoding = arg1;\n            lengthVal = this.length - this._readOffset;\n        }\n        // Check encoding\n        if (typeof encoding !== 'undefined') {\n            utils_1.checkEncoding(encoding);\n        }\n        const value = this._buff.slice(this._readOffset, this._readOffset + lengthVal).toString(encoding || this._encoding);\n        this._readOffset += lengthVal;\n        return value;\n    }\n    /**\n     * Inserts a String\n     *\n     * @param value { String } The String value to insert.\n     * @param offset { Number } The offset to insert the string at.\n     * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).\n     *\n     * @return this\n     */\n    insertString(value, offset, encoding) {\n        utils_1.checkOffsetValue(offset);\n        return this._handleString(value, true, offset, encoding);\n    }\n    /**\n     * Writes a String\n     *\n     * @param value { String } The String value to write.\n     * @param arg2 { Number | String } The offset to write the string at, or the BufferEncoding to use.\n     * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).\n     *\n     * @return this\n     */\n    writeString(value, arg2, encoding) {\n        return this._handleString(value, false, arg2, encoding);\n    }\n    /**\n     * Reads a null-terminated String from the current read position.\n     *\n     * @param encoding { String } The BufferEncoding to use for the string (Defaults to instance level encoding).\n     *\n     * @return { String }\n     */\n    readStringNT(encoding) {\n        if (typeof encoding !== 'undefined') {\n            utils_1.checkEncoding(encoding);\n        }\n        // Set null character position to the end SmartBuffer instance.\n        let nullPos = this.length;\n        // Find next null character (if one is not found, default from above is used)\n        for (let i = this._readOffset; i < this.length; i++) {\n            if (this._buff[i] === 0x00) {\n                nullPos = i;\n                break;\n            }\n        }\n        // Read string value\n        const value = this._buff.slice(this._readOffset, nullPos);\n        // Increment internal Buffer read offset\n        this._readOffset = nullPos + 1;\n        return value.toString(encoding || this._encoding);\n    }\n    /**\n     * Inserts a null-terminated String.\n     *\n     * @param value { String } The String value to write.\n     * @param arg2 { Number | String } The offset to write the string to, or the BufferEncoding to use.\n     * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).\n     *\n     * @return this\n     */\n    insertStringNT(value, offset, encoding) {\n        utils_1.checkOffsetValue(offset);\n        // Write Values\n        this.insertString(value, offset, encoding);\n        this.insertUInt8(0x00, offset + value.length);\n        return this;\n    }\n    /**\n     * Writes a null-terminated String.\n     *\n     * @param value { String } The String value to write.\n     * @param arg2 { Number | String } The offset to write the string to, or the BufferEncoding to use.\n     * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).\n     *\n     * @return this\n     */\n    writeStringNT(value, arg2, encoding) {\n        // Write Values\n        this.writeString(value, arg2, encoding);\n        this.writeUInt8(0x00, typeof arg2 === 'number' ? arg2 + value.length : this.writeOffset);\n        return this;\n    }\n    // Buffers\n    /**\n     * Reads a Buffer from the internal read position.\n     *\n     * @param length { Number } The length of data to read as a Buffer.\n     *\n     * @return { Buffer }\n     */\n    readBuffer(length) {\n        if (typeof length !== 'undefined') {\n            utils_1.checkLengthValue(length);\n        }\n        const lengthVal = typeof length === 'number' ? length : this.length;\n        const endPoint = Math.min(this.length, this._readOffset + lengthVal);\n        // Read buffer value\n        const value = this._buff.slice(this._readOffset, endPoint);\n        // Increment internal Buffer read offset\n        this._readOffset = endPoint;\n        return value;\n    }\n    /**\n     * Writes a Buffer to the current write position.\n     *\n     * @param value { Buffer } The Buffer to write.\n     * @param offset { Number } The offset to write the Buffer to.\n     *\n     * @return this\n     */\n    insertBuffer(value, offset) {\n        utils_1.checkOffsetValue(offset);\n        return this._handleBuffer(value, true, offset);\n    }\n    /**\n     * Writes a Buffer to the current write position.\n     *\n     * @param value { Buffer } The Buffer to write.\n     * @param offset { Number } The offset to write the Buffer to.\n     *\n     * @return this\n     */\n    writeBuffer(value, offset) {\n        return this._handleBuffer(value, false, offset);\n    }\n    /**\n     * Reads a null-terminated Buffer from the current read poisiton.\n     *\n     * @return { Buffer }\n     */\n    readBufferNT() {\n        // Set null character position to the end SmartBuffer instance.\n        let nullPos = this.length;\n        // Find next null character (if one is not found, default from above is used)\n        for (let i = this._readOffset; i < this.length; i++) {\n            if (this._buff[i] === 0x00) {\n                nullPos = i;\n                break;\n            }\n        }\n        // Read value\n        const value = this._buff.slice(this._readOffset, nullPos);\n        // Increment internal Buffer read offset\n        this._readOffset = nullPos + 1;\n        return value;\n    }\n    /**\n     * Inserts a null-terminated Buffer.\n     *\n     * @param value { Buffer } The Buffer to write.\n     * @param offset { Number } The offset to write the Buffer to.\n     *\n     * @return this\n     */\n    insertBufferNT(value, offset) {\n        utils_1.checkOffsetValue(offset);\n        // Write Values\n        this.insertBuffer(value, offset);\n        this.insertUInt8(0x00, offset + value.length);\n        return this;\n    }\n    /**\n     * Writes a null-terminated Buffer.\n     *\n     * @param value { Buffer } The Buffer to write.\n     * @param offset { Number } The offset to write the Buffer to.\n     *\n     * @return this\n     */\n    writeBufferNT(value, offset) {\n        // Checks for valid numberic value;\n        if (typeof offset !== 'undefined') {\n            utils_1.checkOffsetValue(offset);\n        }\n        // Write Values\n        this.writeBuffer(value, offset);\n        this.writeUInt8(0x00, typeof offset === 'number' ? offset + value.length : this._writeOffset);\n        return this;\n    }\n    /**\n     * Clears the SmartBuffer instance to its original empty state.\n     */\n    clear() {\n        this._writeOffset = 0;\n        this._readOffset = 0;\n        this.length = 0;\n        return this;\n    }\n    /**\n     * Gets the remaining data left to be read from the SmartBuffer instance.\n     *\n     * @return { Number }\n     */\n    remaining() {\n        return this.length - this._readOffset;\n    }\n    /**\n     * Gets the current read offset value of the SmartBuffer instance.\n     *\n     * @return { Number }\n     */\n    get readOffset() {\n        return this._readOffset;\n    }\n    /**\n     * Sets the read offset value of the SmartBuffer instance.\n     *\n     * @param offset { Number } - The offset value to set.\n     */\n    set readOffset(offset) {\n        utils_1.checkOffsetValue(offset);\n        // Check for bounds.\n        utils_1.checkTargetOffset(offset, this);\n        this._readOffset = offset;\n    }\n    /**\n     * Gets the current write offset value of the SmartBuffer instance.\n     *\n     * @return { Number }\n     */\n    get writeOffset() {\n        return this._writeOffset;\n    }\n    /**\n     * Sets the write offset value of the SmartBuffer instance.\n     *\n     * @param offset { Number } - The offset value to set.\n     */\n    set writeOffset(offset) {\n        utils_1.checkOffsetValue(offset);\n        // Check for bounds.\n        utils_1.checkTargetOffset(offset, this);\n        this._writeOffset = offset;\n    }\n    /**\n     * Gets the currently set string encoding of the SmartBuffer instance.\n     *\n     * @return { BufferEncoding } The string Buffer encoding currently set.\n     */\n    get encoding() {\n        return this._encoding;\n    }\n    /**\n     * Sets the string encoding of the SmartBuffer instance.\n     *\n     * @param encoding { BufferEncoding } The string Buffer encoding to set.\n     */\n    set encoding(encoding) {\n        utils_1.checkEncoding(encoding);\n        this._encoding = encoding;\n    }\n    /**\n     * Gets the underlying internal Buffer. (This includes unmanaged data in the Buffer)\n     *\n     * @return { Buffer } The Buffer value.\n     */\n    get internalBuffer() {\n        return this._buff;\n    }\n    /**\n     * Gets the value of the internal managed Buffer (Includes managed data only)\n     *\n     * @param { Buffer }\n     */\n    toBuffer() {\n        return this._buff.slice(0, this.length);\n    }\n    /**\n     * Gets the String value of the internal managed Buffer\n     *\n     * @param encoding { String } The BufferEncoding to display the Buffer as (defaults to instance level encoding).\n     */\n    toString(encoding) {\n        const encodingVal = typeof encoding === 'string' ? encoding : this._encoding;\n        // Check for invalid encoding.\n        utils_1.checkEncoding(encodingVal);\n        return this._buff.toString(encodingVal, 0, this.length);\n    }\n    /**\n     * Destroys the SmartBuffer instance.\n     */\n    destroy() {\n        this.clear();\n        return this;\n    }\n    /**\n     * Handles inserting and writing strings.\n     *\n     * @param value { String } The String value to insert.\n     * @param isInsert { Boolean } True if inserting a string, false if writing.\n     * @param arg2 { Number | String } The offset to insert the string at, or the BufferEncoding to use.\n     * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).\n     */\n    _handleString(value, isInsert, arg3, encoding) {\n        let offsetVal = this._writeOffset;\n        let encodingVal = this._encoding;\n        // Check for offset\n        if (typeof arg3 === 'number') {\n            offsetVal = arg3;\n            // Check for encoding\n        }\n        else if (typeof arg3 === 'string') {\n            utils_1.checkEncoding(arg3);\n            encodingVal = arg3;\n        }\n        // Check for encoding (third param)\n        if (typeof encoding === 'string') {\n            utils_1.checkEncoding(encoding);\n            encodingVal = encoding;\n        }\n        // Calculate bytelength of string.\n        const byteLength = Buffer.byteLength(value, encodingVal);\n        // Ensure there is enough internal Buffer capacity.\n        if (isInsert) {\n            this.ensureInsertable(byteLength, offsetVal);\n        }\n        else {\n            this._ensureWriteable(byteLength, offsetVal);\n        }\n        // Write value\n        this._buff.write(value, offsetVal, byteLength, encodingVal);\n        // Increment internal Buffer write offset;\n        if (isInsert) {\n            this._writeOffset += byteLength;\n        }\n        else {\n            // If an offset was given, check to see if we wrote beyond the current writeOffset.\n            if (typeof arg3 === 'number') {\n                this._writeOffset = Math.max(this._writeOffset, offsetVal + byteLength);\n            }\n            else {\n                // If no offset was given, we wrote to the end of the SmartBuffer so increment writeOffset.\n                this._writeOffset += byteLength;\n            }\n        }\n        return this;\n    }\n    /**\n     * Handles writing or insert of a Buffer.\n     *\n     * @param value { Buffer } The Buffer to write.\n     * @param offset { Number } The offset to write the Buffer to.\n     */\n    _handleBuffer(value, isInsert, offset) {\n        const offsetVal = typeof offset === 'number' ? offset : this._writeOffset;\n        // Ensure there is enough internal Buffer capacity.\n        if (isInsert) {\n            this.ensureInsertable(value.length, offsetVal);\n        }\n        else {\n            this._ensureWriteable(value.length, offsetVal);\n        }\n        // Write buffer value\n        value.copy(this._buff, offsetVal);\n        // Increment internal Buffer write offset;\n        if (isInsert) {\n            this._writeOffset += value.length;\n        }\n        else {\n            // If an offset was given, check to see if we wrote beyond the current writeOffset.\n            if (typeof offset === 'number') {\n                this._writeOffset = Math.max(this._writeOffset, offsetVal + value.length);\n            }\n            else {\n                // If no offset was given, we wrote to the end of the SmartBuffer so increment writeOffset.\n                this._writeOffset += value.length;\n            }\n        }\n        return this;\n    }\n    /**\n     * Ensures that the internal Buffer is large enough to read data.\n     *\n     * @param length { Number } The length of the data that needs to be read.\n     * @param offset { Number } The offset of the data that needs to be read.\n     */\n    ensureReadable(length, offset) {\n        // Offset value defaults to managed read offset.\n        let offsetVal = this._readOffset;\n        // If an offset was provided, use it.\n        if (typeof offset !== 'undefined') {\n            // Checks for valid numberic value;\n            utils_1.checkOffsetValue(offset);\n            // Overide with custom offset.\n            offsetVal = offset;\n        }\n        // Checks if offset is below zero, or the offset+length offset is beyond the total length of the managed data.\n        if (offsetVal < 0 || offsetVal + length > this.length) {\n            throw new Error(utils_1.ERRORS.INVALID_READ_BEYOND_BOUNDS);\n        }\n    }\n    /**\n     * Ensures that the internal Buffer is large enough to insert data.\n     *\n     * @param dataLength { Number } The length of the data that needs to be written.\n     * @param offset { Number } The offset of the data to be written.\n     */\n    ensureInsertable(dataLength, offset) {\n        // Checks for valid numberic value;\n        utils_1.checkOffsetValue(offset);\n        // Ensure there is enough internal Buffer capacity.\n        this._ensureCapacity(this.length + dataLength);\n        // If an offset was provided and its not the very end of the buffer, copy data into appropriate location in regards to the offset.\n        if (offset < this.length) {\n            this._buff.copy(this._buff, offset + dataLength, offset, this._buff.length);\n        }\n        // Adjust tracked smart buffer length\n        if (offset + dataLength > this.length) {\n            this.length = offset + dataLength;\n        }\n        else {\n            this.length += dataLength;\n        }\n    }\n    /**\n     * Ensures that the internal Buffer is large enough to write data.\n     *\n     * @param dataLength { Number } The length of the data that needs to be written.\n     * @param offset { Number } The offset of the data to be written (defaults to writeOffset).\n     */\n    _ensureWriteable(dataLength, offset) {\n        const offsetVal = typeof offset === 'number' ? offset : this._writeOffset;\n        // Ensure enough capacity to write data.\n        this._ensureCapacity(offsetVal + dataLength);\n        // Adjust SmartBuffer length (if offset + length is larger than managed length, adjust length)\n        if (offsetVal + dataLength > this.length) {\n            this.length = offsetVal + dataLength;\n        }\n    }\n    /**\n     * Ensures that the internal Buffer is large enough to write at least the given amount of data.\n     *\n     * @param minLength { Number } The minimum length of the data needs to be written.\n     */\n    _ensureCapacity(minLength) {\n        const oldLength = this._buff.length;\n        if (minLength > oldLength) {\n            let data = this._buff;\n            let newLength = (oldLength * 3) / 2 + 1;\n            if (newLength < minLength) {\n                newLength = minLength;\n            }\n            this._buff = Buffer.allocUnsafe(newLength);\n            data.copy(this._buff, 0, 0, oldLength);\n        }\n    }\n    /**\n     * Reads a numeric number value using the provided function.\n     *\n     * @typeparam T { number | bigint } The type of the value to be read\n     *\n     * @param func { Function(offset: number) => number } The function to read data on the internal Buffer with.\n     * @param byteSize { Number } The number of bytes read.\n     * @param offset { Number } The offset to read from (optional). When this is not provided, the managed readOffset is used instead.\n     *\n     * @returns { T } the number value\n     */\n    _readNumberValue(func, byteSize, offset) {\n        this.ensureReadable(byteSize, offset);\n        // Call Buffer.readXXXX();\n        const value = func.call(this._buff, typeof offset === 'number' ? offset : this._readOffset);\n        // Adjust internal read offset if an optional read offset was not provided.\n        if (typeof offset === 'undefined') {\n            this._readOffset += byteSize;\n        }\n        return value;\n    }\n    /**\n     * Inserts a numeric number value based on the given offset and value.\n     *\n     * @typeparam T { number | bigint } The type of the value to be written\n     *\n     * @param func { Function(offset: T, offset?) => number} The function to write data on the internal Buffer with.\n     * @param byteSize { Number } The number of bytes written.\n     * @param value { T } The number value to write.\n     * @param offset { Number } the offset to write the number at (REQUIRED).\n     *\n     * @returns SmartBuffer this buffer\n     */\n    _insertNumberValue(func, byteSize, value, offset) {\n        // Check for invalid offset values.\n        utils_1.checkOffsetValue(offset);\n        // Ensure there is enough internal Buffer capacity. (raw offset is passed)\n        this.ensureInsertable(byteSize, offset);\n        // Call buffer.writeXXXX();\n        func.call(this._buff, value, offset);\n        // Adjusts internally managed write offset.\n        this._writeOffset += byteSize;\n        return this;\n    }\n    /**\n     * Writes a numeric number value based on the given offset and value.\n     *\n     * @typeparam T { number | bigint } The type of the value to be written\n     *\n     * @param func { Function(offset: T, offset?) => number} The function to write data on the internal Buffer with.\n     * @param byteSize { Number } The number of bytes written.\n     * @param value { T } The number value to write.\n     * @param offset { Number } the offset to write the number at (REQUIRED).\n     *\n     * @returns SmartBuffer this buffer\n     */\n    _writeNumberValue(func, byteSize, value, offset) {\n        // If an offset was provided, validate it.\n        if (typeof offset === 'number') {\n            // Check if we're writing beyond the bounds of the managed data.\n            if (offset < 0) {\n                throw new Error(utils_1.ERRORS.INVALID_WRITE_BEYOND_BOUNDS);\n            }\n            utils_1.checkOffsetValue(offset);\n        }\n        // Default to writeOffset if no offset value was given.\n        const offsetVal = typeof offset === 'number' ? offset : this._writeOffset;\n        // Ensure there is enough internal Buffer capacity. (raw offset is passed)\n        this._ensureWriteable(byteSize, offsetVal);\n        func.call(this._buff, value, offsetVal);\n        // If an offset was given, check to see if we wrote beyond the current writeOffset.\n        if (typeof offset === 'number') {\n            this._writeOffset = Math.max(this._writeOffset, offsetVal + byteSize);\n        }\n        else {\n            // If no numeric offset was given, we wrote to the end of the SmartBuffer so increment writeOffset.\n            this._writeOffset += byteSize;\n        }\n        return this;\n    }\n}\nexports.SmartBuffer = SmartBuffer;\n//# sourceMappingURL=smartbuffer.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc21hcnQtYnVmZmVyL2J1aWxkL3NtYXJ0YnVmZmVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdCQUFnQixtQkFBTyxDQUFDLGlFQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IscUJBQXFCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsU0FBUztBQUM5Qix5QkFBeUIsU0FBUztBQUNsQztBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFNBQVM7QUFDaEMseUJBQXlCLFNBQVM7QUFDbEM7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixxQkFBcUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsU0FBUztBQUNoQyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsU0FBUztBQUNoQyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsU0FBUztBQUNoQyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsU0FBUztBQUNoQyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsU0FBUztBQUNoQyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsU0FBUztBQUNoQyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixTQUFTO0FBQ2hDLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFNBQVM7QUFDL0IsdUJBQXVCLFNBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsU0FBUztBQUMvQix1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsU0FBUztBQUMvQix1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsU0FBUztBQUMvQix1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsU0FBUztBQUMvQix1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsU0FBUztBQUMvQix1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsU0FBUztBQUMvQix1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsU0FBUztBQUMvQix1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsU0FBUztBQUMvQix1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsU0FBUztBQUMvQix1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsU0FBUztBQUMvQix1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixTQUFTO0FBQy9CLHVCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFNBQVM7QUFDL0IsdUJBQXVCLFNBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsU0FBUztBQUMvQix1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFNBQVM7QUFDaEMsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFNBQVM7QUFDaEMsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFNBQVM7QUFDaEMsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFNBQVM7QUFDaEMsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFNBQVM7QUFDaEMsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFNBQVM7QUFDaEMsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsU0FBUztBQUNoQyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixTQUFTO0FBQy9CLHVCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixTQUFTO0FBQy9CLHVCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixTQUFTO0FBQy9CLHVCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixTQUFTO0FBQy9CLHVCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixTQUFTO0FBQy9CLHVCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixTQUFTO0FBQy9CLHVCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixTQUFTO0FBQy9CLHVCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixTQUFTO0FBQy9CLHVCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixTQUFTO0FBQy9CLHVCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixTQUFTO0FBQy9CLHVCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixTQUFTO0FBQy9CLHVCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFNBQVM7QUFDL0IsdUJBQXVCLFNBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsU0FBUztBQUMvQix1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixTQUFTO0FBQy9CLHVCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsU0FBUztBQUNoQyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsU0FBUztBQUNoQyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsU0FBUztBQUMvQix1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsU0FBUztBQUMvQix1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsU0FBUztBQUMvQix1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsU0FBUztBQUMvQix1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixTQUFTO0FBQ2hDLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixTQUFTO0FBQ2hDLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixTQUFTO0FBQy9CLHVCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixTQUFTO0FBQy9CLHVCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixTQUFTO0FBQy9CLHVCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixTQUFTO0FBQy9CLHVCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGtCQUFrQjtBQUN2QztBQUNBLHlCQUF5QixTQUFTO0FBQ2xDO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsU0FBUztBQUMvQix1QkFBdUIsU0FBUztBQUNoQyx5QkFBeUIsU0FBUztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixTQUFTO0FBQy9CLHFCQUFxQixrQkFBa0I7QUFDdkMseUJBQXlCLFNBQVM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFNBQVM7QUFDbEM7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxpQkFBaUI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixTQUFTO0FBQy9CLHFCQUFxQixrQkFBa0I7QUFDdkMseUJBQXlCLFNBQVM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsU0FBUztBQUMvQixxQkFBcUIsa0JBQWtCO0FBQ3ZDLHlCQUF5QixTQUFTO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFNBQVM7QUFDaEM7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsU0FBUztBQUMvQix1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixTQUFTO0FBQy9CLHVCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGlCQUFpQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFNBQVM7QUFDL0IsdUJBQXVCLFNBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsU0FBUztBQUMvQix1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFNBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsaUJBQWlCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGlCQUFpQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsU0FBUztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFNBQVM7QUFDL0IseUJBQXlCLFVBQVU7QUFDbkMscUJBQXFCLGtCQUFrQjtBQUN2Qyx5QkFBeUIsU0FBUztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsU0FBUztBQUMvQix1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixTQUFTO0FBQ2hDLHVCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFNBQVM7QUFDcEMsdUJBQXVCLFNBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFNBQVM7QUFDcEMsdUJBQXVCLFNBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsU0FBUztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixrQkFBa0I7QUFDeEM7QUFDQSxxQkFBcUIscUNBQXFDO0FBQzFELHlCQUF5QixTQUFTO0FBQ2xDLHVCQUF1QixTQUFTO0FBQ2hDO0FBQ0Esa0JBQWtCLElBQUk7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixrQkFBa0I7QUFDeEM7QUFDQSxxQkFBcUIsd0NBQXdDO0FBQzdELHlCQUF5QixTQUFTO0FBQ2xDLHNCQUFzQixJQUFJO0FBQzFCLHVCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isa0JBQWtCO0FBQ3hDO0FBQ0EscUJBQXFCLHdDQUF3QztBQUM3RCx5QkFBeUIsU0FBUztBQUNsQyxzQkFBc0IsSUFBSTtBQUMxQix1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxTaW1wbGVcXERvd25sb2Fkc1xcUHJveWVjdG9FeHRyYWN0b3JEZUZpbGFtZW50b1xcZXh0cmFjdG9yLXNlcnZlclxcbm9kZV9tb2R1bGVzXFxzbWFydC1idWZmZXJcXGJ1aWxkXFxzbWFydGJ1ZmZlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbi8vIFRoZSBkZWZhdWx0IEJ1ZmZlciBzaXplIGlmIG9uZSBpcyBub3QgcHJvdmlkZWQuXG5jb25zdCBERUZBVUxUX1NNQVJUQlVGRkVSX1NJWkUgPSA0MDk2O1xuLy8gVGhlIGRlZmF1bHQgc3RyaW5nIGVuY29kaW5nIHRvIHVzZSBmb3IgcmVhZGluZy93cml0aW5nIHN0cmluZ3MuXG5jb25zdCBERUZBVUxUX1NNQVJUQlVGRkVSX0VOQ09ESU5HID0gJ3V0ZjgnO1xuY2xhc3MgU21hcnRCdWZmZXIge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgU21hcnRCdWZmZXIgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyB7IFNtYXJ0QnVmZmVyT3B0aW9ucyB9IFRoZSBTbWFydEJ1ZmZlck9wdGlvbnMgdG8gYXBwbHkgdG8gdGhpcyBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5fZW5jb2RpbmcgPSBERUZBVUxUX1NNQVJUQlVGRkVSX0VOQ09ESU5HO1xuICAgICAgICB0aGlzLl93cml0ZU9mZnNldCA9IDA7XG4gICAgICAgIHRoaXMuX3JlYWRPZmZzZXQgPSAwO1xuICAgICAgICBpZiAoU21hcnRCdWZmZXIuaXNTbWFydEJ1ZmZlck9wdGlvbnMob3B0aW9ucykpIHtcbiAgICAgICAgICAgIC8vIENoZWNrcyBmb3IgZW5jb2RpbmdcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmVuY29kaW5nKSB7XG4gICAgICAgICAgICAgICAgdXRpbHNfMS5jaGVja0VuY29kaW5nKG9wdGlvbnMuZW5jb2RpbmcpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2VuY29kaW5nID0gb3B0aW9ucy5lbmNvZGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENoZWNrcyBmb3IgaW5pdGlhbCBzaXplIGxlbmd0aFxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuc2l6ZSkge1xuICAgICAgICAgICAgICAgIGlmICh1dGlsc18xLmlzRmluaXRlSW50ZWdlcihvcHRpb25zLnNpemUpICYmIG9wdGlvbnMuc2l6ZSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYnVmZiA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShvcHRpb25zLnNpemUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHV0aWxzXzEuRVJST1JTLklOVkFMSURfU01BUlRCVUZGRVJfU0laRSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIENoZWNrIGZvciBpbml0aWFsIEJ1ZmZlclxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAob3B0aW9ucy5idWZmKSB7XG4gICAgICAgICAgICAgICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihvcHRpb25zLmJ1ZmYpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2J1ZmYgPSBvcHRpb25zLmJ1ZmY7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGVuZ3RoID0gb3B0aW9ucy5idWZmLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcih1dGlsc18xLkVSUk9SUy5JTlZBTElEX1NNQVJUQlVGRkVSX0JVRkZFUik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYnVmZiA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShERUZBVUxUX1NNQVJUQlVGRkVSX1NJWkUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gSWYgc29tZXRoaW5nIHdhcyBwYXNzZWQgYnV0IGl0J3Mgbm90IGEgU21hcnRCdWZmZXJPcHRpb25zIG9iamVjdFxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcih1dGlsc18xLkVSUk9SUy5JTlZBTElEX1NNQVJUQlVGRkVSX09CSkVDVCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBPdGhlcndpc2UgZGVmYXVsdCB0byBzYW5lIG9wdGlvbnNcbiAgICAgICAgICAgIHRoaXMuX2J1ZmYgPSBCdWZmZXIuYWxsb2NVbnNhZmUoREVGQVVMVF9TTUFSVEJVRkZFUl9TSVpFKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IFNtYXJ0QnVmZmVyIGluc3RhbmNlIHdpdGggdGhlIHByb3ZpZGVkIGludGVybmFsIEJ1ZmZlciBzaXplIGFuZCBvcHRpb25hbCBlbmNvZGluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzaXplIHsgTnVtYmVyIH0gVGhlIHNpemUgb2YgdGhlIGludGVybmFsIEJ1ZmZlci5cbiAgICAgKiBAcGFyYW0gZW5jb2RpbmcgeyBTdHJpbmcgfSBUaGUgQnVmZmVyRW5jb2RpbmcgdG8gdXNlIGZvciBzdHJpbmdzLlxuICAgICAqXG4gICAgICogQHJldHVybiB7IFNtYXJ0QnVmZmVyIH1cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbVNpemUoc2l6ZSwgZW5jb2RpbmcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzKHtcbiAgICAgICAgICAgIHNpemU6IHNpemUsXG4gICAgICAgICAgICBlbmNvZGluZzogZW5jb2RpbmdcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgU21hcnRCdWZmZXIgaW5zdGFuY2Ugd2l0aCB0aGUgcHJvdmlkZWQgQnVmZmVyIGFuZCBvcHRpb25hbCBlbmNvZGluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBidWZmZXIgeyBCdWZmZXIgfSBUaGUgQnVmZmVyIHRvIHVzZSBhcyB0aGUgaW50ZXJuYWwgQnVmZmVyIHZhbHVlLlxuICAgICAqIEBwYXJhbSBlbmNvZGluZyB7IFN0cmluZyB9IFRoZSBCdWZmZXJFbmNvZGluZyB0byB1c2UgZm9yIHN0cmluZ3MuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHsgU21hcnRCdWZmZXIgfVxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tQnVmZmVyKGJ1ZmYsIGVuY29kaW5nKSB7XG4gICAgICAgIHJldHVybiBuZXcgdGhpcyh7XG4gICAgICAgICAgICBidWZmOiBidWZmLFxuICAgICAgICAgICAgZW5jb2Rpbmc6IGVuY29kaW5nXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IFNtYXJ0QnVmZmVyIGluc3RhbmNlIHdpdGggdGhlIHByb3ZpZGVkIFNtYXJ0QnVmZmVyT3B0aW9ucyBvcHRpb25zLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgeyBTbWFydEJ1ZmZlck9wdGlvbnMgfSBUaGUgb3B0aW9ucyB0byB1c2Ugd2hlbiBjcmVhdGluZyB0aGUgU21hcnRCdWZmZXIgaW5zdGFuY2UuXG4gICAgICovXG4gICAgc3RhdGljIGZyb21PcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzKG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUeXBlIGNoZWNraW5nIGZ1bmN0aW9uIHRoYXQgZGV0ZXJtaW5lcyBpZiBhbiBvYmplY3QgaXMgYSBTbWFydEJ1ZmZlck9wdGlvbnMgb2JqZWN0LlxuICAgICAqL1xuICAgIHN0YXRpYyBpc1NtYXJ0QnVmZmVyT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGNhc3RPcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgcmV0dXJuIChjYXN0T3B0aW9ucyAmJlxuICAgICAgICAgICAgKGNhc3RPcHRpb25zLmVuY29kaW5nICE9PSB1bmRlZmluZWQgfHwgY2FzdE9wdGlvbnMuc2l6ZSAhPT0gdW5kZWZpbmVkIHx8IGNhc3RPcHRpb25zLmJ1ZmYgIT09IHVuZGVmaW5lZCkpO1xuICAgIH1cbiAgICAvLyBTaWduZWQgaW50ZWdlcnNcbiAgICAvKipcbiAgICAgKiBSZWFkcyBhbiBJbnQ4IHZhbHVlIGZyb20gdGhlIGN1cnJlbnQgcmVhZCBwb3NpdGlvbiBvciBhbiBvcHRpb25hbGx5IHByb3ZpZGVkIG9mZnNldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSBUaGUgb2Zmc2V0IHRvIHJlYWQgZGF0YSBmcm9tIChvcHRpb25hbClcbiAgICAgKiBAcmV0dXJuIHsgTnVtYmVyIH1cbiAgICAgKi9cbiAgICByZWFkSW50OChvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWROdW1iZXJWYWx1ZShCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4LCAxLCBvZmZzZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkcyBhbiBJbnQxNkJFIHZhbHVlIGZyb20gdGhlIGN1cnJlbnQgcmVhZCBwb3NpdGlvbiBvciBhbiBvcHRpb25hbGx5IHByb3ZpZGVkIG9mZnNldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSBUaGUgb2Zmc2V0IHRvIHJlYWQgZGF0YSBmcm9tIChvcHRpb25hbClcbiAgICAgKiBAcmV0dXJuIHsgTnVtYmVyIH1cbiAgICAgKi9cbiAgICByZWFkSW50MTZCRShvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWROdW1iZXJWYWx1ZShCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFLCAyLCBvZmZzZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkcyBhbiBJbnQxNkxFIHZhbHVlIGZyb20gdGhlIGN1cnJlbnQgcmVhZCBwb3NpdGlvbiBvciBhbiBvcHRpb25hbGx5IHByb3ZpZGVkIG9mZnNldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSBUaGUgb2Zmc2V0IHRvIHJlYWQgZGF0YSBmcm9tIChvcHRpb25hbClcbiAgICAgKiBAcmV0dXJuIHsgTnVtYmVyIH1cbiAgICAgKi9cbiAgICByZWFkSW50MTZMRShvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWROdW1iZXJWYWx1ZShCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFLCAyLCBvZmZzZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkcyBhbiBJbnQzMkJFIHZhbHVlIGZyb20gdGhlIGN1cnJlbnQgcmVhZCBwb3NpdGlvbiBvciBhbiBvcHRpb25hbGx5IHByb3ZpZGVkIG9mZnNldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSBUaGUgb2Zmc2V0IHRvIHJlYWQgZGF0YSBmcm9tIChvcHRpb25hbClcbiAgICAgKiBAcmV0dXJuIHsgTnVtYmVyIH1cbiAgICAgKi9cbiAgICByZWFkSW50MzJCRShvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWROdW1iZXJWYWx1ZShCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFLCA0LCBvZmZzZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkcyBhbiBJbnQzMkxFIHZhbHVlIGZyb20gdGhlIGN1cnJlbnQgcmVhZCBwb3NpdGlvbiBvciBhbiBvcHRpb25hbGx5IHByb3ZpZGVkIG9mZnNldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSBUaGUgb2Zmc2V0IHRvIHJlYWQgZGF0YSBmcm9tIChvcHRpb25hbClcbiAgICAgKiBAcmV0dXJuIHsgTnVtYmVyIH1cbiAgICAgKi9cbiAgICByZWFkSW50MzJMRShvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWROdW1iZXJWYWx1ZShCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFLCA0LCBvZmZzZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkcyBhIEJpZ0ludDY0QkUgdmFsdWUgZnJvbSB0aGUgY3VycmVudCByZWFkIHBvc2l0aW9uIG9yIGFuIG9wdGlvbmFsbHkgcHJvdmlkZWQgb2Zmc2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIG9mZnNldCB7IE51bWJlciB9IFRoZSBvZmZzZXQgdG8gcmVhZCBkYXRhIGZyb20gKG9wdGlvbmFsKVxuICAgICAqIEByZXR1cm4geyBCaWdJbnQgfVxuICAgICAqL1xuICAgIHJlYWRCaWdJbnQ2NEJFKG9mZnNldCkge1xuICAgICAgICB1dGlsc18xLmJpZ0ludEFuZEJ1ZmZlckludDY0Q2hlY2soJ3JlYWRCaWdJbnQ2NEJFJyk7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWFkTnVtYmVyVmFsdWUoQnVmZmVyLnByb3RvdHlwZS5yZWFkQmlnSW50NjRCRSwgOCwgb2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVhZHMgYSBCaWdJbnQ2NExFIHZhbHVlIGZyb20gdGhlIGN1cnJlbnQgcmVhZCBwb3NpdGlvbiBvciBhbiBvcHRpb25hbGx5IHByb3ZpZGVkIG9mZnNldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSBUaGUgb2Zmc2V0IHRvIHJlYWQgZGF0YSBmcm9tIChvcHRpb25hbClcbiAgICAgKiBAcmV0dXJuIHsgQmlnSW50IH1cbiAgICAgKi9cbiAgICByZWFkQmlnSW50NjRMRShvZmZzZXQpIHtcbiAgICAgICAgdXRpbHNfMS5iaWdJbnRBbmRCdWZmZXJJbnQ2NENoZWNrKCdyZWFkQmlnSW50NjRMRScpO1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVhZE51bWJlclZhbHVlKEJ1ZmZlci5wcm90b3R5cGUucmVhZEJpZ0ludDY0TEUsIDgsIG9mZnNldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyaXRlcyBhbiBJbnQ4IHZhbHVlIHRvIHRoZSBjdXJyZW50IHdyaXRlIHBvc2l0aW9uIChvciBhdCBvcHRpb25hbCBvZmZzZXQpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIHsgTnVtYmVyIH0gVGhlIHZhbHVlIHRvIHdyaXRlLlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSBUaGUgb2Zmc2V0IHRvIHdyaXRlIHRoZSB2YWx1ZSBhdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gdGhpc1xuICAgICAqL1xuICAgIHdyaXRlSW50OCh2YWx1ZSwgb2Zmc2V0KSB7XG4gICAgICAgIHRoaXMuX3dyaXRlTnVtYmVyVmFsdWUoQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDgsIDEsIHZhbHVlLCBvZmZzZXQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5zZXJ0cyBhbiBJbnQ4IHZhbHVlIGF0IHRoZSBnaXZlbiBvZmZzZXQgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgeyBOdW1iZXIgfSBUaGUgdmFsdWUgdG8gaW5zZXJ0LlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSBUaGUgb2Zmc2V0IHRvIGluc2VydCB0aGUgdmFsdWUgYXQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHRoaXNcbiAgICAgKi9cbiAgICBpbnNlcnRJbnQ4KHZhbHVlLCBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luc2VydE51bWJlclZhbHVlKEJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4LCAxLCB2YWx1ZSwgb2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGVzIGFuIEludDE2QkUgdmFsdWUgdG8gdGhlIGN1cnJlbnQgd3JpdGUgcG9zaXRpb24gKG9yIGF0IG9wdGlvbmFsIG9mZnNldCkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgeyBOdW1iZXIgfSBUaGUgdmFsdWUgdG8gd3JpdGUuXG4gICAgICogQHBhcmFtIG9mZnNldCB7IE51bWJlciB9IFRoZSBvZmZzZXQgdG8gd3JpdGUgdGhlIHZhbHVlIGF0LlxuICAgICAqXG4gICAgICogQHJldHVybiB0aGlzXG4gICAgICovXG4gICAgd3JpdGVJbnQxNkJFKHZhbHVlLCBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dyaXRlTnVtYmVyVmFsdWUoQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUsIDIsIHZhbHVlLCBvZmZzZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnNlcnRzIGFuIEludDE2QkUgdmFsdWUgYXQgdGhlIGdpdmVuIG9mZnNldCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSB7IE51bWJlciB9IFRoZSB2YWx1ZSB0byBpbnNlcnQuXG4gICAgICogQHBhcmFtIG9mZnNldCB7IE51bWJlciB9IFRoZSBvZmZzZXQgdG8gaW5zZXJ0IHRoZSB2YWx1ZSBhdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gdGhpc1xuICAgICAqL1xuICAgIGluc2VydEludDE2QkUodmFsdWUsIG9mZnNldCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW5zZXJ0TnVtYmVyVmFsdWUoQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUsIDIsIHZhbHVlLCBvZmZzZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZXMgYW4gSW50MTZMRSB2YWx1ZSB0byB0aGUgY3VycmVudCB3cml0ZSBwb3NpdGlvbiAob3IgYXQgb3B0aW9uYWwgb2Zmc2V0KS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSB7IE51bWJlciB9IFRoZSB2YWx1ZSB0byB3cml0ZS5cbiAgICAgKiBAcGFyYW0gb2Zmc2V0IHsgTnVtYmVyIH0gVGhlIG9mZnNldCB0byB3cml0ZSB0aGUgdmFsdWUgYXQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHRoaXNcbiAgICAgKi9cbiAgICB3cml0ZUludDE2TEUodmFsdWUsIG9mZnNldCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd3JpdGVOdW1iZXJWYWx1ZShCdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSwgMiwgdmFsdWUsIG9mZnNldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluc2VydHMgYW4gSW50MTZMRSB2YWx1ZSBhdCB0aGUgZ2l2ZW4gb2Zmc2V0IHZhbHVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIHsgTnVtYmVyIH0gVGhlIHZhbHVlIHRvIGluc2VydC5cbiAgICAgKiBAcGFyYW0gb2Zmc2V0IHsgTnVtYmVyIH0gVGhlIG9mZnNldCB0byBpbnNlcnQgdGhlIHZhbHVlIGF0LlxuICAgICAqXG4gICAgICogQHJldHVybiB0aGlzXG4gICAgICovXG4gICAgaW5zZXJ0SW50MTZMRSh2YWx1ZSwgb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnNlcnROdW1iZXJWYWx1ZShCdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSwgMiwgdmFsdWUsIG9mZnNldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyaXRlcyBhbiBJbnQzMkJFIHZhbHVlIHRvIHRoZSBjdXJyZW50IHdyaXRlIHBvc2l0aW9uIChvciBhdCBvcHRpb25hbCBvZmZzZXQpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIHsgTnVtYmVyIH0gVGhlIHZhbHVlIHRvIHdyaXRlLlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSBUaGUgb2Zmc2V0IHRvIHdyaXRlIHRoZSB2YWx1ZSBhdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gdGhpc1xuICAgICAqL1xuICAgIHdyaXRlSW50MzJCRSh2YWx1ZSwgb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93cml0ZU51bWJlclZhbHVlKEJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFLCA0LCB2YWx1ZSwgb2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5zZXJ0cyBhbiBJbnQzMkJFIHZhbHVlIGF0IHRoZSBnaXZlbiBvZmZzZXQgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgeyBOdW1iZXIgfSBUaGUgdmFsdWUgdG8gaW5zZXJ0LlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSBUaGUgb2Zmc2V0IHRvIGluc2VydCB0aGUgdmFsdWUgYXQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHRoaXNcbiAgICAgKi9cbiAgICBpbnNlcnRJbnQzMkJFKHZhbHVlLCBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luc2VydE51bWJlclZhbHVlKEJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFLCA0LCB2YWx1ZSwgb2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGVzIGFuIEludDMyTEUgdmFsdWUgdG8gdGhlIGN1cnJlbnQgd3JpdGUgcG9zaXRpb24gKG9yIGF0IG9wdGlvbmFsIG9mZnNldCkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgeyBOdW1iZXIgfSBUaGUgdmFsdWUgdG8gd3JpdGUuXG4gICAgICogQHBhcmFtIG9mZnNldCB7IE51bWJlciB9IFRoZSBvZmZzZXQgdG8gd3JpdGUgdGhlIHZhbHVlIGF0LlxuICAgICAqXG4gICAgICogQHJldHVybiB0aGlzXG4gICAgICovXG4gICAgd3JpdGVJbnQzMkxFKHZhbHVlLCBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dyaXRlTnVtYmVyVmFsdWUoQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEUsIDQsIHZhbHVlLCBvZmZzZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnNlcnRzIGFuIEludDMyTEUgdmFsdWUgYXQgdGhlIGdpdmVuIG9mZnNldCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSB7IE51bWJlciB9IFRoZSB2YWx1ZSB0byBpbnNlcnQuXG4gICAgICogQHBhcmFtIG9mZnNldCB7IE51bWJlciB9IFRoZSBvZmZzZXQgdG8gaW5zZXJ0IHRoZSB2YWx1ZSBhdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gdGhpc1xuICAgICAqL1xuICAgIGluc2VydEludDMyTEUodmFsdWUsIG9mZnNldCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW5zZXJ0TnVtYmVyVmFsdWUoQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEUsIDQsIHZhbHVlLCBvZmZzZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZXMgYSBCaWdJbnQ2NEJFIHZhbHVlIHRvIHRoZSBjdXJyZW50IHdyaXRlIHBvc2l0aW9uIChvciBhdCBvcHRpb25hbCBvZmZzZXQpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIHsgQmlnSW50IH0gVGhlIHZhbHVlIHRvIHdyaXRlLlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSBUaGUgb2Zmc2V0IHRvIHdyaXRlIHRoZSB2YWx1ZSBhdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gdGhpc1xuICAgICAqL1xuICAgIHdyaXRlQmlnSW50NjRCRSh2YWx1ZSwgb2Zmc2V0KSB7XG4gICAgICAgIHV0aWxzXzEuYmlnSW50QW5kQnVmZmVySW50NjRDaGVjaygnd3JpdGVCaWdJbnQ2NEJFJyk7XG4gICAgICAgIHJldHVybiB0aGlzLl93cml0ZU51bWJlclZhbHVlKEJ1ZmZlci5wcm90b3R5cGUud3JpdGVCaWdJbnQ2NEJFLCA4LCB2YWx1ZSwgb2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5zZXJ0cyBhIEJpZ0ludDY0QkUgdmFsdWUgYXQgdGhlIGdpdmVuIG9mZnNldCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSB7IEJpZ0ludCB9IFRoZSB2YWx1ZSB0byBpbnNlcnQuXG4gICAgICogQHBhcmFtIG9mZnNldCB7IE51bWJlciB9IFRoZSBvZmZzZXQgdG8gaW5zZXJ0IHRoZSB2YWx1ZSBhdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gdGhpc1xuICAgICAqL1xuICAgIGluc2VydEJpZ0ludDY0QkUodmFsdWUsIG9mZnNldCkge1xuICAgICAgICB1dGlsc18xLmJpZ0ludEFuZEJ1ZmZlckludDY0Q2hlY2soJ3dyaXRlQmlnSW50NjRCRScpO1xuICAgICAgICByZXR1cm4gdGhpcy5faW5zZXJ0TnVtYmVyVmFsdWUoQnVmZmVyLnByb3RvdHlwZS53cml0ZUJpZ0ludDY0QkUsIDgsIHZhbHVlLCBvZmZzZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZXMgYSBCaWdJbnQ2NExFIHZhbHVlIHRvIHRoZSBjdXJyZW50IHdyaXRlIHBvc2l0aW9uIChvciBhdCBvcHRpb25hbCBvZmZzZXQpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIHsgQmlnSW50IH0gVGhlIHZhbHVlIHRvIHdyaXRlLlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSBUaGUgb2Zmc2V0IHRvIHdyaXRlIHRoZSB2YWx1ZSBhdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gdGhpc1xuICAgICAqL1xuICAgIHdyaXRlQmlnSW50NjRMRSh2YWx1ZSwgb2Zmc2V0KSB7XG4gICAgICAgIHV0aWxzXzEuYmlnSW50QW5kQnVmZmVySW50NjRDaGVjaygnd3JpdGVCaWdJbnQ2NExFJyk7XG4gICAgICAgIHJldHVybiB0aGlzLl93cml0ZU51bWJlclZhbHVlKEJ1ZmZlci5wcm90b3R5cGUud3JpdGVCaWdJbnQ2NExFLCA4LCB2YWx1ZSwgb2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5zZXJ0cyBhIEludDY0TEUgdmFsdWUgYXQgdGhlIGdpdmVuIG9mZnNldCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSB7IEJpZ0ludCB9IFRoZSB2YWx1ZSB0byBpbnNlcnQuXG4gICAgICogQHBhcmFtIG9mZnNldCB7IE51bWJlciB9IFRoZSBvZmZzZXQgdG8gaW5zZXJ0IHRoZSB2YWx1ZSBhdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gdGhpc1xuICAgICAqL1xuICAgIGluc2VydEJpZ0ludDY0TEUodmFsdWUsIG9mZnNldCkge1xuICAgICAgICB1dGlsc18xLmJpZ0ludEFuZEJ1ZmZlckludDY0Q2hlY2soJ3dyaXRlQmlnSW50NjRMRScpO1xuICAgICAgICByZXR1cm4gdGhpcy5faW5zZXJ0TnVtYmVyVmFsdWUoQnVmZmVyLnByb3RvdHlwZS53cml0ZUJpZ0ludDY0TEUsIDgsIHZhbHVlLCBvZmZzZXQpO1xuICAgIH1cbiAgICAvLyBVbnNpZ25lZCBJbnRlZ2Vyc1xuICAgIC8qKlxuICAgICAqIFJlYWRzIGFuIFVJbnQ4IHZhbHVlIGZyb20gdGhlIGN1cnJlbnQgcmVhZCBwb3NpdGlvbiBvciBhbiBvcHRpb25hbGx5IHByb3ZpZGVkIG9mZnNldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSBUaGUgb2Zmc2V0IHRvIHJlYWQgZGF0YSBmcm9tIChvcHRpb25hbClcbiAgICAgKiBAcmV0dXJuIHsgTnVtYmVyIH1cbiAgICAgKi9cbiAgICByZWFkVUludDgob2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWFkTnVtYmVyVmFsdWUoQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDgsIDEsIG9mZnNldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlYWRzIGFuIFVJbnQxNkJFIHZhbHVlIGZyb20gdGhlIGN1cnJlbnQgcmVhZCBwb3NpdGlvbiBvciBhbiBvcHRpb25hbGx5IHByb3ZpZGVkIG9mZnNldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSBUaGUgb2Zmc2V0IHRvIHJlYWQgZGF0YSBmcm9tIChvcHRpb25hbClcbiAgICAgKiBAcmV0dXJuIHsgTnVtYmVyIH1cbiAgICAgKi9cbiAgICByZWFkVUludDE2QkUob2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWFkTnVtYmVyVmFsdWUoQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUsIDIsIG9mZnNldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlYWRzIGFuIFVJbnQxNkxFIHZhbHVlIGZyb20gdGhlIGN1cnJlbnQgcmVhZCBwb3NpdGlvbiBvciBhbiBvcHRpb25hbGx5IHByb3ZpZGVkIG9mZnNldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSBUaGUgb2Zmc2V0IHRvIHJlYWQgZGF0YSBmcm9tIChvcHRpb25hbClcbiAgICAgKiBAcmV0dXJuIHsgTnVtYmVyIH1cbiAgICAgKi9cbiAgICByZWFkVUludDE2TEUob2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWFkTnVtYmVyVmFsdWUoQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUsIDIsIG9mZnNldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlYWRzIGFuIFVJbnQzMkJFIHZhbHVlIGZyb20gdGhlIGN1cnJlbnQgcmVhZCBwb3NpdGlvbiBvciBhbiBvcHRpb25hbGx5IHByb3ZpZGVkIG9mZnNldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSBUaGUgb2Zmc2V0IHRvIHJlYWQgZGF0YSBmcm9tIChvcHRpb25hbClcbiAgICAgKiBAcmV0dXJuIHsgTnVtYmVyIH1cbiAgICAgKi9cbiAgICByZWFkVUludDMyQkUob2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWFkTnVtYmVyVmFsdWUoQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUsIDQsIG9mZnNldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlYWRzIGFuIFVJbnQzMkxFIHZhbHVlIGZyb20gdGhlIGN1cnJlbnQgcmVhZCBwb3NpdGlvbiBvciBhbiBvcHRpb25hbGx5IHByb3ZpZGVkIG9mZnNldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSBUaGUgb2Zmc2V0IHRvIHJlYWQgZGF0YSBmcm9tIChvcHRpb25hbClcbiAgICAgKiBAcmV0dXJuIHsgTnVtYmVyIH1cbiAgICAgKi9cbiAgICByZWFkVUludDMyTEUob2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWFkTnVtYmVyVmFsdWUoQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUsIDQsIG9mZnNldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlYWRzIGEgQmlnVUludDY0QkUgdmFsdWUgZnJvbSB0aGUgY3VycmVudCByZWFkIHBvc2l0aW9uIG9yIGFuIG9wdGlvbmFsbHkgcHJvdmlkZWQgb2Zmc2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIG9mZnNldCB7IE51bWJlciB9IFRoZSBvZmZzZXQgdG8gcmVhZCBkYXRhIGZyb20gKG9wdGlvbmFsKVxuICAgICAqIEByZXR1cm4geyBCaWdJbnQgfVxuICAgICAqL1xuICAgIHJlYWRCaWdVSW50NjRCRShvZmZzZXQpIHtcbiAgICAgICAgdXRpbHNfMS5iaWdJbnRBbmRCdWZmZXJJbnQ2NENoZWNrKCdyZWFkQmlnVUludDY0QkUnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWROdW1iZXJWYWx1ZShCdWZmZXIucHJvdG90eXBlLnJlYWRCaWdVSW50NjRCRSwgOCwgb2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVhZHMgYSBCaWdVSW50NjRMRSB2YWx1ZSBmcm9tIHRoZSBjdXJyZW50IHJlYWQgcG9zaXRpb24gb3IgYW4gb3B0aW9uYWxseSBwcm92aWRlZCBvZmZzZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb2Zmc2V0IHsgTnVtYmVyIH0gVGhlIG9mZnNldCB0byByZWFkIGRhdGEgZnJvbSAob3B0aW9uYWwpXG4gICAgICogQHJldHVybiB7IEJpZ0ludCB9XG4gICAgICovXG4gICAgcmVhZEJpZ1VJbnQ2NExFKG9mZnNldCkge1xuICAgICAgICB1dGlsc18xLmJpZ0ludEFuZEJ1ZmZlckludDY0Q2hlY2soJ3JlYWRCaWdVSW50NjRMRScpO1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVhZE51bWJlclZhbHVlKEJ1ZmZlci5wcm90b3R5cGUucmVhZEJpZ1VJbnQ2NExFLCA4LCBvZmZzZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZXMgYW4gVUludDggdmFsdWUgdG8gdGhlIGN1cnJlbnQgd3JpdGUgcG9zaXRpb24gKG9yIGF0IG9wdGlvbmFsIG9mZnNldCkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgeyBOdW1iZXIgfSBUaGUgdmFsdWUgdG8gd3JpdGUuXG4gICAgICogQHBhcmFtIG9mZnNldCB7IE51bWJlciB9IFRoZSBvZmZzZXQgdG8gd3JpdGUgdGhlIHZhbHVlIGF0LlxuICAgICAqXG4gICAgICogQHJldHVybiB0aGlzXG4gICAgICovXG4gICAgd3JpdGVVSW50OCh2YWx1ZSwgb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93cml0ZU51bWJlclZhbHVlKEJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCwgMSwgdmFsdWUsIG9mZnNldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluc2VydHMgYW4gVUludDggdmFsdWUgYXQgdGhlIGdpdmVuIG9mZnNldCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSB7IE51bWJlciB9IFRoZSB2YWx1ZSB0byBpbnNlcnQuXG4gICAgICogQHBhcmFtIG9mZnNldCB7IE51bWJlciB9IFRoZSBvZmZzZXQgdG8gaW5zZXJ0IHRoZSB2YWx1ZSBhdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gdGhpc1xuICAgICAqL1xuICAgIGluc2VydFVJbnQ4KHZhbHVlLCBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luc2VydE51bWJlclZhbHVlKEJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCwgMSwgdmFsdWUsIG9mZnNldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyaXRlcyBhbiBVSW50MTZCRSB2YWx1ZSB0byB0aGUgY3VycmVudCB3cml0ZSBwb3NpdGlvbiAob3IgYXQgb3B0aW9uYWwgb2Zmc2V0KS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSB7IE51bWJlciB9IFRoZSB2YWx1ZSB0byB3cml0ZS5cbiAgICAgKiBAcGFyYW0gb2Zmc2V0IHsgTnVtYmVyIH0gVGhlIG9mZnNldCB0byB3cml0ZSB0aGUgdmFsdWUgYXQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHRoaXNcbiAgICAgKi9cbiAgICB3cml0ZVVJbnQxNkJFKHZhbHVlLCBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dyaXRlTnVtYmVyVmFsdWUoQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFLCAyLCB2YWx1ZSwgb2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5zZXJ0cyBhbiBVSW50MTZCRSB2YWx1ZSBhdCB0aGUgZ2l2ZW4gb2Zmc2V0IHZhbHVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIHsgTnVtYmVyIH0gVGhlIHZhbHVlIHRvIGluc2VydC5cbiAgICAgKiBAcGFyYW0gb2Zmc2V0IHsgTnVtYmVyIH0gVGhlIG9mZnNldCB0byBpbnNlcnQgdGhlIHZhbHVlIGF0LlxuICAgICAqXG4gICAgICogQHJldHVybiB0aGlzXG4gICAgICovXG4gICAgaW5zZXJ0VUludDE2QkUodmFsdWUsIG9mZnNldCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW5zZXJ0TnVtYmVyVmFsdWUoQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFLCAyLCB2YWx1ZSwgb2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGVzIGFuIFVJbnQxNkxFIHZhbHVlIHRvIHRoZSBjdXJyZW50IHdyaXRlIHBvc2l0aW9uIChvciBhdCBvcHRpb25hbCBvZmZzZXQpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIHsgTnVtYmVyIH0gVGhlIHZhbHVlIHRvIHdyaXRlLlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSBUaGUgb2Zmc2V0IHRvIHdyaXRlIHRoZSB2YWx1ZSBhdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gdGhpc1xuICAgICAqL1xuICAgIHdyaXRlVUludDE2TEUodmFsdWUsIG9mZnNldCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd3JpdGVOdW1iZXJWYWx1ZShCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUsIDIsIHZhbHVlLCBvZmZzZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnNlcnRzIGFuIFVJbnQxNkxFIHZhbHVlIGF0IHRoZSBnaXZlbiBvZmZzZXQgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgeyBOdW1iZXIgfSBUaGUgdmFsdWUgdG8gaW5zZXJ0LlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSBUaGUgb2Zmc2V0IHRvIGluc2VydCB0aGUgdmFsdWUgYXQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHRoaXNcbiAgICAgKi9cbiAgICBpbnNlcnRVSW50MTZMRSh2YWx1ZSwgb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnNlcnROdW1iZXJWYWx1ZShCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUsIDIsIHZhbHVlLCBvZmZzZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZXMgYW4gVUludDMyQkUgdmFsdWUgdG8gdGhlIGN1cnJlbnQgd3JpdGUgcG9zaXRpb24gKG9yIGF0IG9wdGlvbmFsIG9mZnNldCkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgeyBOdW1iZXIgfSBUaGUgdmFsdWUgdG8gd3JpdGUuXG4gICAgICogQHBhcmFtIG9mZnNldCB7IE51bWJlciB9IFRoZSBvZmZzZXQgdG8gd3JpdGUgdGhlIHZhbHVlIGF0LlxuICAgICAqXG4gICAgICogQHJldHVybiB0aGlzXG4gICAgICovXG4gICAgd3JpdGVVSW50MzJCRSh2YWx1ZSwgb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93cml0ZU51bWJlclZhbHVlKEJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSwgNCwgdmFsdWUsIG9mZnNldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluc2VydHMgYW4gVUludDMyQkUgdmFsdWUgYXQgdGhlIGdpdmVuIG9mZnNldCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSB7IE51bWJlciB9IFRoZSB2YWx1ZSB0byBpbnNlcnQuXG4gICAgICogQHBhcmFtIG9mZnNldCB7IE51bWJlciB9IFRoZSBvZmZzZXQgdG8gaW5zZXJ0IHRoZSB2YWx1ZSBhdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gdGhpc1xuICAgICAqL1xuICAgIGluc2VydFVJbnQzMkJFKHZhbHVlLCBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luc2VydE51bWJlclZhbHVlKEJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSwgNCwgdmFsdWUsIG9mZnNldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyaXRlcyBhbiBVSW50MzJMRSB2YWx1ZSB0byB0aGUgY3VycmVudCB3cml0ZSBwb3NpdGlvbiAob3IgYXQgb3B0aW9uYWwgb2Zmc2V0KS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSB7IE51bWJlciB9IFRoZSB2YWx1ZSB0byB3cml0ZS5cbiAgICAgKiBAcGFyYW0gb2Zmc2V0IHsgTnVtYmVyIH0gVGhlIG9mZnNldCB0byB3cml0ZSB0aGUgdmFsdWUgYXQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHRoaXNcbiAgICAgKi9cbiAgICB3cml0ZVVJbnQzMkxFKHZhbHVlLCBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dyaXRlTnVtYmVyVmFsdWUoQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFLCA0LCB2YWx1ZSwgb2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5zZXJ0cyBhbiBVSW50MzJMRSB2YWx1ZSBhdCB0aGUgZ2l2ZW4gb2Zmc2V0IHZhbHVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIHsgTnVtYmVyIH0gVGhlIHZhbHVlIHRvIGluc2VydC5cbiAgICAgKiBAcGFyYW0gb2Zmc2V0IHsgTnVtYmVyIH0gVGhlIG9mZnNldCB0byBpbnNlcnQgdGhlIHZhbHVlIGF0LlxuICAgICAqXG4gICAgICogQHJldHVybiB0aGlzXG4gICAgICovXG4gICAgaW5zZXJ0VUludDMyTEUodmFsdWUsIG9mZnNldCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW5zZXJ0TnVtYmVyVmFsdWUoQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFLCA0LCB2YWx1ZSwgb2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGVzIGEgQmlnVUludDY0QkUgdmFsdWUgdG8gdGhlIGN1cnJlbnQgd3JpdGUgcG9zaXRpb24gKG9yIGF0IG9wdGlvbmFsIG9mZnNldCkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgeyBOdW1iZXIgfSBUaGUgdmFsdWUgdG8gd3JpdGUuXG4gICAgICogQHBhcmFtIG9mZnNldCB7IE51bWJlciB9IFRoZSBvZmZzZXQgdG8gd3JpdGUgdGhlIHZhbHVlIGF0LlxuICAgICAqXG4gICAgICogQHJldHVybiB0aGlzXG4gICAgICovXG4gICAgd3JpdGVCaWdVSW50NjRCRSh2YWx1ZSwgb2Zmc2V0KSB7XG4gICAgICAgIHV0aWxzXzEuYmlnSW50QW5kQnVmZmVySW50NjRDaGVjaygnd3JpdGVCaWdVSW50NjRCRScpO1xuICAgICAgICByZXR1cm4gdGhpcy5fd3JpdGVOdW1iZXJWYWx1ZShCdWZmZXIucHJvdG90eXBlLndyaXRlQmlnVUludDY0QkUsIDgsIHZhbHVlLCBvZmZzZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnNlcnRzIGEgQmlnVUludDY0QkUgdmFsdWUgYXQgdGhlIGdpdmVuIG9mZnNldCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSB7IE51bWJlciB9IFRoZSB2YWx1ZSB0byBpbnNlcnQuXG4gICAgICogQHBhcmFtIG9mZnNldCB7IE51bWJlciB9IFRoZSBvZmZzZXQgdG8gaW5zZXJ0IHRoZSB2YWx1ZSBhdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gdGhpc1xuICAgICAqL1xuICAgIGluc2VydEJpZ1VJbnQ2NEJFKHZhbHVlLCBvZmZzZXQpIHtcbiAgICAgICAgdXRpbHNfMS5iaWdJbnRBbmRCdWZmZXJJbnQ2NENoZWNrKCd3cml0ZUJpZ1VJbnQ2NEJFJyk7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnNlcnROdW1iZXJWYWx1ZShCdWZmZXIucHJvdG90eXBlLndyaXRlQmlnVUludDY0QkUsIDgsIHZhbHVlLCBvZmZzZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZXMgYSBCaWdVSW50NjRMRSB2YWx1ZSB0byB0aGUgY3VycmVudCB3cml0ZSBwb3NpdGlvbiAob3IgYXQgb3B0aW9uYWwgb2Zmc2V0KS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSB7IE51bWJlciB9IFRoZSB2YWx1ZSB0byB3cml0ZS5cbiAgICAgKiBAcGFyYW0gb2Zmc2V0IHsgTnVtYmVyIH0gVGhlIG9mZnNldCB0byB3cml0ZSB0aGUgdmFsdWUgYXQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHRoaXNcbiAgICAgKi9cbiAgICB3cml0ZUJpZ1VJbnQ2NExFKHZhbHVlLCBvZmZzZXQpIHtcbiAgICAgICAgdXRpbHNfMS5iaWdJbnRBbmRCdWZmZXJJbnQ2NENoZWNrKCd3cml0ZUJpZ1VJbnQ2NExFJyk7XG4gICAgICAgIHJldHVybiB0aGlzLl93cml0ZU51bWJlclZhbHVlKEJ1ZmZlci5wcm90b3R5cGUud3JpdGVCaWdVSW50NjRMRSwgOCwgdmFsdWUsIG9mZnNldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluc2VydHMgYSBCaWdVSW50NjRMRSB2YWx1ZSBhdCB0aGUgZ2l2ZW4gb2Zmc2V0IHZhbHVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIHsgTnVtYmVyIH0gVGhlIHZhbHVlIHRvIGluc2VydC5cbiAgICAgKiBAcGFyYW0gb2Zmc2V0IHsgTnVtYmVyIH0gVGhlIG9mZnNldCB0byBpbnNlcnQgdGhlIHZhbHVlIGF0LlxuICAgICAqXG4gICAgICogQHJldHVybiB0aGlzXG4gICAgICovXG4gICAgaW5zZXJ0QmlnVUludDY0TEUodmFsdWUsIG9mZnNldCkge1xuICAgICAgICB1dGlsc18xLmJpZ0ludEFuZEJ1ZmZlckludDY0Q2hlY2soJ3dyaXRlQmlnVUludDY0TEUnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luc2VydE51bWJlclZhbHVlKEJ1ZmZlci5wcm90b3R5cGUud3JpdGVCaWdVSW50NjRMRSwgOCwgdmFsdWUsIG9mZnNldCk7XG4gICAgfVxuICAgIC8vIEZsb2F0aW5nIFBvaW50XG4gICAgLyoqXG4gICAgICogUmVhZHMgYW4gRmxvYXRCRSB2YWx1ZSBmcm9tIHRoZSBjdXJyZW50IHJlYWQgcG9zaXRpb24gb3IgYW4gb3B0aW9uYWxseSBwcm92aWRlZCBvZmZzZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb2Zmc2V0IHsgTnVtYmVyIH0gVGhlIG9mZnNldCB0byByZWFkIGRhdGEgZnJvbSAob3B0aW9uYWwpXG4gICAgICogQHJldHVybiB7IE51bWJlciB9XG4gICAgICovXG4gICAgcmVhZEZsb2F0QkUob2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWFkTnVtYmVyVmFsdWUoQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSwgNCwgb2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVhZHMgYW4gRmxvYXRMRSB2YWx1ZSBmcm9tIHRoZSBjdXJyZW50IHJlYWQgcG9zaXRpb24gb3IgYW4gb3B0aW9uYWxseSBwcm92aWRlZCBvZmZzZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb2Zmc2V0IHsgTnVtYmVyIH0gVGhlIG9mZnNldCB0byByZWFkIGRhdGEgZnJvbSAob3B0aW9uYWwpXG4gICAgICogQHJldHVybiB7IE51bWJlciB9XG4gICAgICovXG4gICAgcmVhZEZsb2F0TEUob2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWFkTnVtYmVyVmFsdWUoQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSwgNCwgb2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGVzIGEgRmxvYXRCRSB2YWx1ZSB0byB0aGUgY3VycmVudCB3cml0ZSBwb3NpdGlvbiAob3IgYXQgb3B0aW9uYWwgb2Zmc2V0KS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSB7IE51bWJlciB9IFRoZSB2YWx1ZSB0byB3cml0ZS5cbiAgICAgKiBAcGFyYW0gb2Zmc2V0IHsgTnVtYmVyIH0gVGhlIG9mZnNldCB0byB3cml0ZSB0aGUgdmFsdWUgYXQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHRoaXNcbiAgICAgKi9cbiAgICB3cml0ZUZsb2F0QkUodmFsdWUsIG9mZnNldCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd3JpdGVOdW1iZXJWYWx1ZShCdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSwgNCwgdmFsdWUsIG9mZnNldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluc2VydHMgYSBGbG9hdEJFIHZhbHVlIGF0IHRoZSBnaXZlbiBvZmZzZXQgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgeyBOdW1iZXIgfSBUaGUgdmFsdWUgdG8gaW5zZXJ0LlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSBUaGUgb2Zmc2V0IHRvIGluc2VydCB0aGUgdmFsdWUgYXQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHRoaXNcbiAgICAgKi9cbiAgICBpbnNlcnRGbG9hdEJFKHZhbHVlLCBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luc2VydE51bWJlclZhbHVlKEJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFLCA0LCB2YWx1ZSwgb2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGVzIGEgRmxvYXRMRSB2YWx1ZSB0byB0aGUgY3VycmVudCB3cml0ZSBwb3NpdGlvbiAob3IgYXQgb3B0aW9uYWwgb2Zmc2V0KS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSB7IE51bWJlciB9IFRoZSB2YWx1ZSB0byB3cml0ZS5cbiAgICAgKiBAcGFyYW0gb2Zmc2V0IHsgTnVtYmVyIH0gVGhlIG9mZnNldCB0byB3cml0ZSB0aGUgdmFsdWUgYXQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHRoaXNcbiAgICAgKi9cbiAgICB3cml0ZUZsb2F0TEUodmFsdWUsIG9mZnNldCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd3JpdGVOdW1iZXJWYWx1ZShCdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSwgNCwgdmFsdWUsIG9mZnNldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluc2VydHMgYSBGbG9hdExFIHZhbHVlIGF0IHRoZSBnaXZlbiBvZmZzZXQgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgeyBOdW1iZXIgfSBUaGUgdmFsdWUgdG8gaW5zZXJ0LlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSBUaGUgb2Zmc2V0IHRvIGluc2VydCB0aGUgdmFsdWUgYXQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHRoaXNcbiAgICAgKi9cbiAgICBpbnNlcnRGbG9hdExFKHZhbHVlLCBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luc2VydE51bWJlclZhbHVlKEJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFLCA0LCB2YWx1ZSwgb2Zmc2V0KTtcbiAgICB9XG4gICAgLy8gRG91YmxlIEZsb2F0aW5nIFBvaW50XG4gICAgLyoqXG4gICAgICogUmVhZHMgYW4gRG91YmxFQkUgdmFsdWUgZnJvbSB0aGUgY3VycmVudCByZWFkIHBvc2l0aW9uIG9yIGFuIG9wdGlvbmFsbHkgcHJvdmlkZWQgb2Zmc2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIG9mZnNldCB7IE51bWJlciB9IFRoZSBvZmZzZXQgdG8gcmVhZCBkYXRhIGZyb20gKG9wdGlvbmFsKVxuICAgICAqIEByZXR1cm4geyBOdW1iZXIgfVxuICAgICAqL1xuICAgIHJlYWREb3VibGVCRShvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWROdW1iZXJWYWx1ZShCdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSwgOCwgb2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVhZHMgYW4gRG91YmxlTEUgdmFsdWUgZnJvbSB0aGUgY3VycmVudCByZWFkIHBvc2l0aW9uIG9yIGFuIG9wdGlvbmFsbHkgcHJvdmlkZWQgb2Zmc2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIG9mZnNldCB7IE51bWJlciB9IFRoZSBvZmZzZXQgdG8gcmVhZCBkYXRhIGZyb20gKG9wdGlvbmFsKVxuICAgICAqIEByZXR1cm4geyBOdW1iZXIgfVxuICAgICAqL1xuICAgIHJlYWREb3VibGVMRShvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWROdW1iZXJWYWx1ZShCdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSwgOCwgb2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGVzIGEgRG91YmxlQkUgdmFsdWUgdG8gdGhlIGN1cnJlbnQgd3JpdGUgcG9zaXRpb24gKG9yIGF0IG9wdGlvbmFsIG9mZnNldCkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgeyBOdW1iZXIgfSBUaGUgdmFsdWUgdG8gd3JpdGUuXG4gICAgICogQHBhcmFtIG9mZnNldCB7IE51bWJlciB9IFRoZSBvZmZzZXQgdG8gd3JpdGUgdGhlIHZhbHVlIGF0LlxuICAgICAqXG4gICAgICogQHJldHVybiB0aGlzXG4gICAgICovXG4gICAgd3JpdGVEb3VibGVCRSh2YWx1ZSwgb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93cml0ZU51bWJlclZhbHVlKEJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSwgOCwgdmFsdWUsIG9mZnNldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluc2VydHMgYSBEb3VibGVCRSB2YWx1ZSBhdCB0aGUgZ2l2ZW4gb2Zmc2V0IHZhbHVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIHsgTnVtYmVyIH0gVGhlIHZhbHVlIHRvIGluc2VydC5cbiAgICAgKiBAcGFyYW0gb2Zmc2V0IHsgTnVtYmVyIH0gVGhlIG9mZnNldCB0byBpbnNlcnQgdGhlIHZhbHVlIGF0LlxuICAgICAqXG4gICAgICogQHJldHVybiB0aGlzXG4gICAgICovXG4gICAgaW5zZXJ0RG91YmxlQkUodmFsdWUsIG9mZnNldCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW5zZXJ0TnVtYmVyVmFsdWUoQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFLCA4LCB2YWx1ZSwgb2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGVzIGEgRG91YmxlTEUgdmFsdWUgdG8gdGhlIGN1cnJlbnQgd3JpdGUgcG9zaXRpb24gKG9yIGF0IG9wdGlvbmFsIG9mZnNldCkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgeyBOdW1iZXIgfSBUaGUgdmFsdWUgdG8gd3JpdGUuXG4gICAgICogQHBhcmFtIG9mZnNldCB7IE51bWJlciB9IFRoZSBvZmZzZXQgdG8gd3JpdGUgdGhlIHZhbHVlIGF0LlxuICAgICAqXG4gICAgICogQHJldHVybiB0aGlzXG4gICAgICovXG4gICAgd3JpdGVEb3VibGVMRSh2YWx1ZSwgb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93cml0ZU51bWJlclZhbHVlKEJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSwgOCwgdmFsdWUsIG9mZnNldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluc2VydHMgYSBEb3VibGVMRSB2YWx1ZSBhdCB0aGUgZ2l2ZW4gb2Zmc2V0IHZhbHVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIHsgTnVtYmVyIH0gVGhlIHZhbHVlIHRvIGluc2VydC5cbiAgICAgKiBAcGFyYW0gb2Zmc2V0IHsgTnVtYmVyIH0gVGhlIG9mZnNldCB0byBpbnNlcnQgdGhlIHZhbHVlIGF0LlxuICAgICAqXG4gICAgICogQHJldHVybiB0aGlzXG4gICAgICovXG4gICAgaW5zZXJ0RG91YmxlTEUodmFsdWUsIG9mZnNldCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW5zZXJ0TnVtYmVyVmFsdWUoQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFLCA4LCB2YWx1ZSwgb2Zmc2V0KTtcbiAgICB9XG4gICAgLy8gU3RyaW5nc1xuICAgIC8qKlxuICAgICAqIFJlYWRzIGEgU3RyaW5nIGZyb20gdGhlIGN1cnJlbnQgcmVhZCBwb3NpdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhcmcxIHsgTnVtYmVyIHwgU3RyaW5nIH0gVGhlIG51bWJlciBvZiBieXRlcyB0byByZWFkIGFzIGEgU3RyaW5nLCBvciB0aGUgQnVmZmVyRW5jb2RpbmcgdG8gdXNlIGZvclxuICAgICAqICAgICAgICAgICAgIHRoZSBzdHJpbmcgKERlZmF1bHRzIHRvIGluc3RhbmNlIGxldmVsIGVuY29kaW5nKS5cbiAgICAgKiBAcGFyYW0gZW5jb2RpbmcgeyBTdHJpbmcgfSBUaGUgQnVmZmVyRW5jb2RpbmcgdG8gdXNlIGZvciB0aGUgc3RyaW5nIChEZWZhdWx0cyB0byBpbnN0YW5jZSBsZXZlbCBlbmNvZGluZykuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHsgU3RyaW5nIH1cbiAgICAgKi9cbiAgICByZWFkU3RyaW5nKGFyZzEsIGVuY29kaW5nKSB7XG4gICAgICAgIGxldCBsZW5ndGhWYWw7XG4gICAgICAgIC8vIExlbmd0aCBwcm92aWRlZFxuICAgICAgICBpZiAodHlwZW9mIGFyZzEgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB1dGlsc18xLmNoZWNrTGVuZ3RoVmFsdWUoYXJnMSk7XG4gICAgICAgICAgICBsZW5ndGhWYWwgPSBNYXRoLm1pbihhcmcxLCB0aGlzLmxlbmd0aCAtIHRoaXMuX3JlYWRPZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZW5jb2RpbmcgPSBhcmcxO1xuICAgICAgICAgICAgbGVuZ3RoVmFsID0gdGhpcy5sZW5ndGggLSB0aGlzLl9yZWFkT2Zmc2V0O1xuICAgICAgICB9XG4gICAgICAgIC8vIENoZWNrIGVuY29kaW5nXG4gICAgICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB1dGlsc18xLmNoZWNrRW5jb2RpbmcoZW5jb2RpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5fYnVmZi5zbGljZSh0aGlzLl9yZWFkT2Zmc2V0LCB0aGlzLl9yZWFkT2Zmc2V0ICsgbGVuZ3RoVmFsKS50b1N0cmluZyhlbmNvZGluZyB8fCB0aGlzLl9lbmNvZGluZyk7XG4gICAgICAgIHRoaXMuX3JlYWRPZmZzZXQgKz0gbGVuZ3RoVmFsO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluc2VydHMgYSBTdHJpbmdcbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSB7IFN0cmluZyB9IFRoZSBTdHJpbmcgdmFsdWUgdG8gaW5zZXJ0LlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSBUaGUgb2Zmc2V0IHRvIGluc2VydCB0aGUgc3RyaW5nIGF0LlxuICAgICAqIEBwYXJhbSBlbmNvZGluZyB7IFN0cmluZyB9IFRoZSBCdWZmZXJFbmNvZGluZyB0byB1c2UgZm9yIHdyaXRpbmcgc3RyaW5ncyAoZGVmYXVsdHMgdG8gaW5zdGFuY2UgZW5jb2RpbmcpLlxuICAgICAqXG4gICAgICogQHJldHVybiB0aGlzXG4gICAgICovXG4gICAgaW5zZXJ0U3RyaW5nKHZhbHVlLCBvZmZzZXQsIGVuY29kaW5nKSB7XG4gICAgICAgIHV0aWxzXzEuY2hlY2tPZmZzZXRWYWx1ZShvZmZzZXQpO1xuICAgICAgICByZXR1cm4gdGhpcy5faGFuZGxlU3RyaW5nKHZhbHVlLCB0cnVlLCBvZmZzZXQsIGVuY29kaW5nKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGVzIGEgU3RyaW5nXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgeyBTdHJpbmcgfSBUaGUgU3RyaW5nIHZhbHVlIHRvIHdyaXRlLlxuICAgICAqIEBwYXJhbSBhcmcyIHsgTnVtYmVyIHwgU3RyaW5nIH0gVGhlIG9mZnNldCB0byB3cml0ZSB0aGUgc3RyaW5nIGF0LCBvciB0aGUgQnVmZmVyRW5jb2RpbmcgdG8gdXNlLlxuICAgICAqIEBwYXJhbSBlbmNvZGluZyB7IFN0cmluZyB9IFRoZSBCdWZmZXJFbmNvZGluZyB0byB1c2UgZm9yIHdyaXRpbmcgc3RyaW5ncyAoZGVmYXVsdHMgdG8gaW5zdGFuY2UgZW5jb2RpbmcpLlxuICAgICAqXG4gICAgICogQHJldHVybiB0aGlzXG4gICAgICovXG4gICAgd3JpdGVTdHJpbmcodmFsdWUsIGFyZzIsIGVuY29kaW5nKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oYW5kbGVTdHJpbmcodmFsdWUsIGZhbHNlLCBhcmcyLCBlbmNvZGluZyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlYWRzIGEgbnVsbC10ZXJtaW5hdGVkIFN0cmluZyBmcm9tIHRoZSBjdXJyZW50IHJlYWQgcG9zaXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZW5jb2RpbmcgeyBTdHJpbmcgfSBUaGUgQnVmZmVyRW5jb2RpbmcgdG8gdXNlIGZvciB0aGUgc3RyaW5nIChEZWZhdWx0cyB0byBpbnN0YW5jZSBsZXZlbCBlbmNvZGluZykuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHsgU3RyaW5nIH1cbiAgICAgKi9cbiAgICByZWFkU3RyaW5nTlQoZW5jb2RpbmcpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlbmNvZGluZyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHV0aWxzXzEuY2hlY2tFbmNvZGluZyhlbmNvZGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2V0IG51bGwgY2hhcmFjdGVyIHBvc2l0aW9uIHRvIHRoZSBlbmQgU21hcnRCdWZmZXIgaW5zdGFuY2UuXG4gICAgICAgIGxldCBudWxsUG9zID0gdGhpcy5sZW5ndGg7XG4gICAgICAgIC8vIEZpbmQgbmV4dCBudWxsIGNoYXJhY3RlciAoaWYgb25lIGlzIG5vdCBmb3VuZCwgZGVmYXVsdCBmcm9tIGFib3ZlIGlzIHVzZWQpXG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLl9yZWFkT2Zmc2V0OyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2J1ZmZbaV0gPT09IDB4MDApIHtcbiAgICAgICAgICAgICAgICBudWxsUG9zID0gaTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBSZWFkIHN0cmluZyB2YWx1ZVxuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuX2J1ZmYuc2xpY2UodGhpcy5fcmVhZE9mZnNldCwgbnVsbFBvcyk7XG4gICAgICAgIC8vIEluY3JlbWVudCBpbnRlcm5hbCBCdWZmZXIgcmVhZCBvZmZzZXRcbiAgICAgICAgdGhpcy5fcmVhZE9mZnNldCA9IG51bGxQb3MgKyAxO1xuICAgICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoZW5jb2RpbmcgfHwgdGhpcy5fZW5jb2RpbmcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnNlcnRzIGEgbnVsbC10ZXJtaW5hdGVkIFN0cmluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSB7IFN0cmluZyB9IFRoZSBTdHJpbmcgdmFsdWUgdG8gd3JpdGUuXG4gICAgICogQHBhcmFtIGFyZzIgeyBOdW1iZXIgfCBTdHJpbmcgfSBUaGUgb2Zmc2V0IHRvIHdyaXRlIHRoZSBzdHJpbmcgdG8sIG9yIHRoZSBCdWZmZXJFbmNvZGluZyB0byB1c2UuXG4gICAgICogQHBhcmFtIGVuY29kaW5nIHsgU3RyaW5nIH0gVGhlIEJ1ZmZlckVuY29kaW5nIHRvIHVzZSBmb3Igd3JpdGluZyBzdHJpbmdzIChkZWZhdWx0cyB0byBpbnN0YW5jZSBlbmNvZGluZykuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHRoaXNcbiAgICAgKi9cbiAgICBpbnNlcnRTdHJpbmdOVCh2YWx1ZSwgb2Zmc2V0LCBlbmNvZGluZykge1xuICAgICAgICB1dGlsc18xLmNoZWNrT2Zmc2V0VmFsdWUob2Zmc2V0KTtcbiAgICAgICAgLy8gV3JpdGUgVmFsdWVzXG4gICAgICAgIHRoaXMuaW5zZXJ0U3RyaW5nKHZhbHVlLCBvZmZzZXQsIGVuY29kaW5nKTtcbiAgICAgICAgdGhpcy5pbnNlcnRVSW50OCgweDAwLCBvZmZzZXQgKyB2YWx1ZS5sZW5ndGgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGVzIGEgbnVsbC10ZXJtaW5hdGVkIFN0cmluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSB7IFN0cmluZyB9IFRoZSBTdHJpbmcgdmFsdWUgdG8gd3JpdGUuXG4gICAgICogQHBhcmFtIGFyZzIgeyBOdW1iZXIgfCBTdHJpbmcgfSBUaGUgb2Zmc2V0IHRvIHdyaXRlIHRoZSBzdHJpbmcgdG8sIG9yIHRoZSBCdWZmZXJFbmNvZGluZyB0byB1c2UuXG4gICAgICogQHBhcmFtIGVuY29kaW5nIHsgU3RyaW5nIH0gVGhlIEJ1ZmZlckVuY29kaW5nIHRvIHVzZSBmb3Igd3JpdGluZyBzdHJpbmdzIChkZWZhdWx0cyB0byBpbnN0YW5jZSBlbmNvZGluZykuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHRoaXNcbiAgICAgKi9cbiAgICB3cml0ZVN0cmluZ05UKHZhbHVlLCBhcmcyLCBlbmNvZGluZykge1xuICAgICAgICAvLyBXcml0ZSBWYWx1ZXNcbiAgICAgICAgdGhpcy53cml0ZVN0cmluZyh2YWx1ZSwgYXJnMiwgZW5jb2RpbmcpO1xuICAgICAgICB0aGlzLndyaXRlVUludDgoMHgwMCwgdHlwZW9mIGFyZzIgPT09ICdudW1iZXInID8gYXJnMiArIHZhbHVlLmxlbmd0aCA6IHRoaXMud3JpdGVPZmZzZXQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLy8gQnVmZmVyc1xuICAgIC8qKlxuICAgICAqIFJlYWRzIGEgQnVmZmVyIGZyb20gdGhlIGludGVybmFsIHJlYWQgcG9zaXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbGVuZ3RoIHsgTnVtYmVyIH0gVGhlIGxlbmd0aCBvZiBkYXRhIHRvIHJlYWQgYXMgYSBCdWZmZXIuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHsgQnVmZmVyIH1cbiAgICAgKi9cbiAgICByZWFkQnVmZmVyKGxlbmd0aCkge1xuICAgICAgICBpZiAodHlwZW9mIGxlbmd0aCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHV0aWxzXzEuY2hlY2tMZW5ndGhWYWx1ZShsZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxlbmd0aFZhbCA9IHR5cGVvZiBsZW5ndGggPT09ICdudW1iZXInID8gbGVuZ3RoIDogdGhpcy5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGVuZFBvaW50ID0gTWF0aC5taW4odGhpcy5sZW5ndGgsIHRoaXMuX3JlYWRPZmZzZXQgKyBsZW5ndGhWYWwpO1xuICAgICAgICAvLyBSZWFkIGJ1ZmZlciB2YWx1ZVxuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuX2J1ZmYuc2xpY2UodGhpcy5fcmVhZE9mZnNldCwgZW5kUG9pbnQpO1xuICAgICAgICAvLyBJbmNyZW1lbnQgaW50ZXJuYWwgQnVmZmVyIHJlYWQgb2Zmc2V0XG4gICAgICAgIHRoaXMuX3JlYWRPZmZzZXQgPSBlbmRQb2ludDtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZXMgYSBCdWZmZXIgdG8gdGhlIGN1cnJlbnQgd3JpdGUgcG9zaXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgeyBCdWZmZXIgfSBUaGUgQnVmZmVyIHRvIHdyaXRlLlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSBUaGUgb2Zmc2V0IHRvIHdyaXRlIHRoZSBCdWZmZXIgdG8uXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHRoaXNcbiAgICAgKi9cbiAgICBpbnNlcnRCdWZmZXIodmFsdWUsIG9mZnNldCkge1xuICAgICAgICB1dGlsc18xLmNoZWNrT2Zmc2V0VmFsdWUob2Zmc2V0KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hhbmRsZUJ1ZmZlcih2YWx1ZSwgdHJ1ZSwgb2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGVzIGEgQnVmZmVyIHRvIHRoZSBjdXJyZW50IHdyaXRlIHBvc2l0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIHsgQnVmZmVyIH0gVGhlIEJ1ZmZlciB0byB3cml0ZS5cbiAgICAgKiBAcGFyYW0gb2Zmc2V0IHsgTnVtYmVyIH0gVGhlIG9mZnNldCB0byB3cml0ZSB0aGUgQnVmZmVyIHRvLlxuICAgICAqXG4gICAgICogQHJldHVybiB0aGlzXG4gICAgICovXG4gICAgd3JpdGVCdWZmZXIodmFsdWUsIG9mZnNldCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faGFuZGxlQnVmZmVyKHZhbHVlLCBmYWxzZSwgb2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVhZHMgYSBudWxsLXRlcm1pbmF0ZWQgQnVmZmVyIGZyb20gdGhlIGN1cnJlbnQgcmVhZCBwb2lzaXRvbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm4geyBCdWZmZXIgfVxuICAgICAqL1xuICAgIHJlYWRCdWZmZXJOVCgpIHtcbiAgICAgICAgLy8gU2V0IG51bGwgY2hhcmFjdGVyIHBvc2l0aW9uIHRvIHRoZSBlbmQgU21hcnRCdWZmZXIgaW5zdGFuY2UuXG4gICAgICAgIGxldCBudWxsUG9zID0gdGhpcy5sZW5ndGg7XG4gICAgICAgIC8vIEZpbmQgbmV4dCBudWxsIGNoYXJhY3RlciAoaWYgb25lIGlzIG5vdCBmb3VuZCwgZGVmYXVsdCBmcm9tIGFib3ZlIGlzIHVzZWQpXG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLl9yZWFkT2Zmc2V0OyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2J1ZmZbaV0gPT09IDB4MDApIHtcbiAgICAgICAgICAgICAgICBudWxsUG9zID0gaTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBSZWFkIHZhbHVlXG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5fYnVmZi5zbGljZSh0aGlzLl9yZWFkT2Zmc2V0LCBudWxsUG9zKTtcbiAgICAgICAgLy8gSW5jcmVtZW50IGludGVybmFsIEJ1ZmZlciByZWFkIG9mZnNldFxuICAgICAgICB0aGlzLl9yZWFkT2Zmc2V0ID0gbnVsbFBvcyArIDE7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5zZXJ0cyBhIG51bGwtdGVybWluYXRlZCBCdWZmZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgeyBCdWZmZXIgfSBUaGUgQnVmZmVyIHRvIHdyaXRlLlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSBUaGUgb2Zmc2V0IHRvIHdyaXRlIHRoZSBCdWZmZXIgdG8uXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHRoaXNcbiAgICAgKi9cbiAgICBpbnNlcnRCdWZmZXJOVCh2YWx1ZSwgb2Zmc2V0KSB7XG4gICAgICAgIHV0aWxzXzEuY2hlY2tPZmZzZXRWYWx1ZShvZmZzZXQpO1xuICAgICAgICAvLyBXcml0ZSBWYWx1ZXNcbiAgICAgICAgdGhpcy5pbnNlcnRCdWZmZXIodmFsdWUsIG9mZnNldCk7XG4gICAgICAgIHRoaXMuaW5zZXJ0VUludDgoMHgwMCwgb2Zmc2V0ICsgdmFsdWUubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyaXRlcyBhIG51bGwtdGVybWluYXRlZCBCdWZmZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgeyBCdWZmZXIgfSBUaGUgQnVmZmVyIHRvIHdyaXRlLlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSBUaGUgb2Zmc2V0IHRvIHdyaXRlIHRoZSBCdWZmZXIgdG8uXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHRoaXNcbiAgICAgKi9cbiAgICB3cml0ZUJ1ZmZlck5UKHZhbHVlLCBvZmZzZXQpIHtcbiAgICAgICAgLy8gQ2hlY2tzIGZvciB2YWxpZCBudW1iZXJpYyB2YWx1ZTtcbiAgICAgICAgaWYgKHR5cGVvZiBvZmZzZXQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB1dGlsc18xLmNoZWNrT2Zmc2V0VmFsdWUob2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXcml0ZSBWYWx1ZXNcbiAgICAgICAgdGhpcy53cml0ZUJ1ZmZlcih2YWx1ZSwgb2Zmc2V0KTtcbiAgICAgICAgdGhpcy53cml0ZVVJbnQ4KDB4MDAsIHR5cGVvZiBvZmZzZXQgPT09ICdudW1iZXInID8gb2Zmc2V0ICsgdmFsdWUubGVuZ3RoIDogdGhpcy5fd3JpdGVPZmZzZXQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xlYXJzIHRoZSBTbWFydEJ1ZmZlciBpbnN0YW5jZSB0byBpdHMgb3JpZ2luYWwgZW1wdHkgc3RhdGUuXG4gICAgICovXG4gICAgY2xlYXIoKSB7XG4gICAgICAgIHRoaXMuX3dyaXRlT2Zmc2V0ID0gMDtcbiAgICAgICAgdGhpcy5fcmVhZE9mZnNldCA9IDA7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHJlbWFpbmluZyBkYXRhIGxlZnQgdG8gYmUgcmVhZCBmcm9tIHRoZSBTbWFydEJ1ZmZlciBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4geyBOdW1iZXIgfVxuICAgICAqL1xuICAgIHJlbWFpbmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGVuZ3RoIC0gdGhpcy5fcmVhZE9mZnNldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgY3VycmVudCByZWFkIG9mZnNldCB2YWx1ZSBvZiB0aGUgU21hcnRCdWZmZXIgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHsgTnVtYmVyIH1cbiAgICAgKi9cbiAgICBnZXQgcmVhZE9mZnNldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWRPZmZzZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHJlYWQgb2Zmc2V0IHZhbHVlIG9mIHRoZSBTbWFydEJ1ZmZlciBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSAtIFRoZSBvZmZzZXQgdmFsdWUgdG8gc2V0LlxuICAgICAqL1xuICAgIHNldCByZWFkT2Zmc2V0KG9mZnNldCkge1xuICAgICAgICB1dGlsc18xLmNoZWNrT2Zmc2V0VmFsdWUob2Zmc2V0KTtcbiAgICAgICAgLy8gQ2hlY2sgZm9yIGJvdW5kcy5cbiAgICAgICAgdXRpbHNfMS5jaGVja1RhcmdldE9mZnNldChvZmZzZXQsIHRoaXMpO1xuICAgICAgICB0aGlzLl9yZWFkT2Zmc2V0ID0gb2Zmc2V0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBjdXJyZW50IHdyaXRlIG9mZnNldCB2YWx1ZSBvZiB0aGUgU21hcnRCdWZmZXIgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHsgTnVtYmVyIH1cbiAgICAgKi9cbiAgICBnZXQgd3JpdGVPZmZzZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93cml0ZU9mZnNldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgd3JpdGUgb2Zmc2V0IHZhbHVlIG9mIHRoZSBTbWFydEJ1ZmZlciBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSAtIFRoZSBvZmZzZXQgdmFsdWUgdG8gc2V0LlxuICAgICAqL1xuICAgIHNldCB3cml0ZU9mZnNldChvZmZzZXQpIHtcbiAgICAgICAgdXRpbHNfMS5jaGVja09mZnNldFZhbHVlKG9mZnNldCk7XG4gICAgICAgIC8vIENoZWNrIGZvciBib3VuZHMuXG4gICAgICAgIHV0aWxzXzEuY2hlY2tUYXJnZXRPZmZzZXQob2Zmc2V0LCB0aGlzKTtcbiAgICAgICAgdGhpcy5fd3JpdGVPZmZzZXQgPSBvZmZzZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGN1cnJlbnRseSBzZXQgc3RyaW5nIGVuY29kaW5nIG9mIHRoZSBTbWFydEJ1ZmZlciBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4geyBCdWZmZXJFbmNvZGluZyB9IFRoZSBzdHJpbmcgQnVmZmVyIGVuY29kaW5nIGN1cnJlbnRseSBzZXQuXG4gICAgICovXG4gICAgZ2V0IGVuY29kaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZW5jb2Rpbmc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHN0cmluZyBlbmNvZGluZyBvZiB0aGUgU21hcnRCdWZmZXIgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZW5jb2RpbmcgeyBCdWZmZXJFbmNvZGluZyB9IFRoZSBzdHJpbmcgQnVmZmVyIGVuY29kaW5nIHRvIHNldC5cbiAgICAgKi9cbiAgICBzZXQgZW5jb2RpbmcoZW5jb2RpbmcpIHtcbiAgICAgICAgdXRpbHNfMS5jaGVja0VuY29kaW5nKGVuY29kaW5nKTtcbiAgICAgICAgdGhpcy5fZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgdW5kZXJseWluZyBpbnRlcm5hbCBCdWZmZXIuIChUaGlzIGluY2x1ZGVzIHVubWFuYWdlZCBkYXRhIGluIHRoZSBCdWZmZXIpXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHsgQnVmZmVyIH0gVGhlIEJ1ZmZlciB2YWx1ZS5cbiAgICAgKi9cbiAgICBnZXQgaW50ZXJuYWxCdWZmZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9idWZmO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSB2YWx1ZSBvZiB0aGUgaW50ZXJuYWwgbWFuYWdlZCBCdWZmZXIgKEluY2x1ZGVzIG1hbmFnZWQgZGF0YSBvbmx5KVxuICAgICAqXG4gICAgICogQHBhcmFtIHsgQnVmZmVyIH1cbiAgICAgKi9cbiAgICB0b0J1ZmZlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2J1ZmYuc2xpY2UoMCwgdGhpcy5sZW5ndGgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBTdHJpbmcgdmFsdWUgb2YgdGhlIGludGVybmFsIG1hbmFnZWQgQnVmZmVyXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZW5jb2RpbmcgeyBTdHJpbmcgfSBUaGUgQnVmZmVyRW5jb2RpbmcgdG8gZGlzcGxheSB0aGUgQnVmZmVyIGFzIChkZWZhdWx0cyB0byBpbnN0YW5jZSBsZXZlbCBlbmNvZGluZykuXG4gICAgICovXG4gICAgdG9TdHJpbmcoZW5jb2RpbmcpIHtcbiAgICAgICAgY29uc3QgZW5jb2RpbmdWYWwgPSB0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnID8gZW5jb2RpbmcgOiB0aGlzLl9lbmNvZGluZztcbiAgICAgICAgLy8gQ2hlY2sgZm9yIGludmFsaWQgZW5jb2RpbmcuXG4gICAgICAgIHV0aWxzXzEuY2hlY2tFbmNvZGluZyhlbmNvZGluZ1ZhbCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9idWZmLnRvU3RyaW5nKGVuY29kaW5nVmFsLCAwLCB0aGlzLmxlbmd0aCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlc3Ryb3lzIHRoZSBTbWFydEJ1ZmZlciBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIGluc2VydGluZyBhbmQgd3JpdGluZyBzdHJpbmdzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIHsgU3RyaW5nIH0gVGhlIFN0cmluZyB2YWx1ZSB0byBpbnNlcnQuXG4gICAgICogQHBhcmFtIGlzSW5zZXJ0IHsgQm9vbGVhbiB9IFRydWUgaWYgaW5zZXJ0aW5nIGEgc3RyaW5nLCBmYWxzZSBpZiB3cml0aW5nLlxuICAgICAqIEBwYXJhbSBhcmcyIHsgTnVtYmVyIHwgU3RyaW5nIH0gVGhlIG9mZnNldCB0byBpbnNlcnQgdGhlIHN0cmluZyBhdCwgb3IgdGhlIEJ1ZmZlckVuY29kaW5nIHRvIHVzZS5cbiAgICAgKiBAcGFyYW0gZW5jb2RpbmcgeyBTdHJpbmcgfSBUaGUgQnVmZmVyRW5jb2RpbmcgdG8gdXNlIGZvciB3cml0aW5nIHN0cmluZ3MgKGRlZmF1bHRzIHRvIGluc3RhbmNlIGVuY29kaW5nKS5cbiAgICAgKi9cbiAgICBfaGFuZGxlU3RyaW5nKHZhbHVlLCBpc0luc2VydCwgYXJnMywgZW5jb2RpbmcpIHtcbiAgICAgICAgbGV0IG9mZnNldFZhbCA9IHRoaXMuX3dyaXRlT2Zmc2V0O1xuICAgICAgICBsZXQgZW5jb2RpbmdWYWwgPSB0aGlzLl9lbmNvZGluZztcbiAgICAgICAgLy8gQ2hlY2sgZm9yIG9mZnNldFxuICAgICAgICBpZiAodHlwZW9mIGFyZzMgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBvZmZzZXRWYWwgPSBhcmczO1xuICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIGVuY29kaW5nXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGFyZzMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB1dGlsc18xLmNoZWNrRW5jb2RpbmcoYXJnMyk7XG4gICAgICAgICAgICBlbmNvZGluZ1ZhbCA9IGFyZzM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hlY2sgZm9yIGVuY29kaW5nICh0aGlyZCBwYXJhbSlcbiAgICAgICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHV0aWxzXzEuY2hlY2tFbmNvZGluZyhlbmNvZGluZyk7XG4gICAgICAgICAgICBlbmNvZGluZ1ZhbCA9IGVuY29kaW5nO1xuICAgICAgICB9XG4gICAgICAgIC8vIENhbGN1bGF0ZSBieXRlbGVuZ3RoIG9mIHN0cmluZy5cbiAgICAgICAgY29uc3QgYnl0ZUxlbmd0aCA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbHVlLCBlbmNvZGluZ1ZhbCk7XG4gICAgICAgIC8vIEVuc3VyZSB0aGVyZSBpcyBlbm91Z2ggaW50ZXJuYWwgQnVmZmVyIGNhcGFjaXR5LlxuICAgICAgICBpZiAoaXNJbnNlcnQpIHtcbiAgICAgICAgICAgIHRoaXMuZW5zdXJlSW5zZXJ0YWJsZShieXRlTGVuZ3RoLCBvZmZzZXRWYWwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fZW5zdXJlV3JpdGVhYmxlKGJ5dGVMZW5ndGgsIG9mZnNldFZhbCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV3JpdGUgdmFsdWVcbiAgICAgICAgdGhpcy5fYnVmZi53cml0ZSh2YWx1ZSwgb2Zmc2V0VmFsLCBieXRlTGVuZ3RoLCBlbmNvZGluZ1ZhbCk7XG4gICAgICAgIC8vIEluY3JlbWVudCBpbnRlcm5hbCBCdWZmZXIgd3JpdGUgb2Zmc2V0O1xuICAgICAgICBpZiAoaXNJbnNlcnQpIHtcbiAgICAgICAgICAgIHRoaXMuX3dyaXRlT2Zmc2V0ICs9IGJ5dGVMZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBJZiBhbiBvZmZzZXQgd2FzIGdpdmVuLCBjaGVjayB0byBzZWUgaWYgd2Ugd3JvdGUgYmV5b25kIHRoZSBjdXJyZW50IHdyaXRlT2Zmc2V0LlxuICAgICAgICAgICAgaWYgKHR5cGVvZiBhcmczID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3dyaXRlT2Zmc2V0ID0gTWF0aC5tYXgodGhpcy5fd3JpdGVPZmZzZXQsIG9mZnNldFZhbCArIGJ5dGVMZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgbm8gb2Zmc2V0IHdhcyBnaXZlbiwgd2Ugd3JvdGUgdG8gdGhlIGVuZCBvZiB0aGUgU21hcnRCdWZmZXIgc28gaW5jcmVtZW50IHdyaXRlT2Zmc2V0LlxuICAgICAgICAgICAgICAgIHRoaXMuX3dyaXRlT2Zmc2V0ICs9IGJ5dGVMZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgd3JpdGluZyBvciBpbnNlcnQgb2YgYSBCdWZmZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgeyBCdWZmZXIgfSBUaGUgQnVmZmVyIHRvIHdyaXRlLlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSBUaGUgb2Zmc2V0IHRvIHdyaXRlIHRoZSBCdWZmZXIgdG8uXG4gICAgICovXG4gICAgX2hhbmRsZUJ1ZmZlcih2YWx1ZSwgaXNJbnNlcnQsIG9mZnNldCkge1xuICAgICAgICBjb25zdCBvZmZzZXRWYWwgPSB0eXBlb2Ygb2Zmc2V0ID09PSAnbnVtYmVyJyA/IG9mZnNldCA6IHRoaXMuX3dyaXRlT2Zmc2V0O1xuICAgICAgICAvLyBFbnN1cmUgdGhlcmUgaXMgZW5vdWdoIGludGVybmFsIEJ1ZmZlciBjYXBhY2l0eS5cbiAgICAgICAgaWYgKGlzSW5zZXJ0KSB7XG4gICAgICAgICAgICB0aGlzLmVuc3VyZUluc2VydGFibGUodmFsdWUubGVuZ3RoLCBvZmZzZXRWYWwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fZW5zdXJlV3JpdGVhYmxlKHZhbHVlLmxlbmd0aCwgb2Zmc2V0VmFsKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXcml0ZSBidWZmZXIgdmFsdWVcbiAgICAgICAgdmFsdWUuY29weSh0aGlzLl9idWZmLCBvZmZzZXRWYWwpO1xuICAgICAgICAvLyBJbmNyZW1lbnQgaW50ZXJuYWwgQnVmZmVyIHdyaXRlIG9mZnNldDtcbiAgICAgICAgaWYgKGlzSW5zZXJ0KSB7XG4gICAgICAgICAgICB0aGlzLl93cml0ZU9mZnNldCArPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBJZiBhbiBvZmZzZXQgd2FzIGdpdmVuLCBjaGVjayB0byBzZWUgaWYgd2Ugd3JvdGUgYmV5b25kIHRoZSBjdXJyZW50IHdyaXRlT2Zmc2V0LlxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvZmZzZXQgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fd3JpdGVPZmZzZXQgPSBNYXRoLm1heCh0aGlzLl93cml0ZU9mZnNldCwgb2Zmc2V0VmFsICsgdmFsdWUubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIElmIG5vIG9mZnNldCB3YXMgZ2l2ZW4sIHdlIHdyb3RlIHRvIHRoZSBlbmQgb2YgdGhlIFNtYXJ0QnVmZmVyIHNvIGluY3JlbWVudCB3cml0ZU9mZnNldC5cbiAgICAgICAgICAgICAgICB0aGlzLl93cml0ZU9mZnNldCArPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuc3VyZXMgdGhhdCB0aGUgaW50ZXJuYWwgQnVmZmVyIGlzIGxhcmdlIGVub3VnaCB0byByZWFkIGRhdGEuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbGVuZ3RoIHsgTnVtYmVyIH0gVGhlIGxlbmd0aCBvZiB0aGUgZGF0YSB0aGF0IG5lZWRzIHRvIGJlIHJlYWQuXG4gICAgICogQHBhcmFtIG9mZnNldCB7IE51bWJlciB9IFRoZSBvZmZzZXQgb2YgdGhlIGRhdGEgdGhhdCBuZWVkcyB0byBiZSByZWFkLlxuICAgICAqL1xuICAgIGVuc3VyZVJlYWRhYmxlKGxlbmd0aCwgb2Zmc2V0KSB7XG4gICAgICAgIC8vIE9mZnNldCB2YWx1ZSBkZWZhdWx0cyB0byBtYW5hZ2VkIHJlYWQgb2Zmc2V0LlxuICAgICAgICBsZXQgb2Zmc2V0VmFsID0gdGhpcy5fcmVhZE9mZnNldDtcbiAgICAgICAgLy8gSWYgYW4gb2Zmc2V0IHdhcyBwcm92aWRlZCwgdXNlIGl0LlxuICAgICAgICBpZiAodHlwZW9mIG9mZnNldCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIC8vIENoZWNrcyBmb3IgdmFsaWQgbnVtYmVyaWMgdmFsdWU7XG4gICAgICAgICAgICB1dGlsc18xLmNoZWNrT2Zmc2V0VmFsdWUob2Zmc2V0KTtcbiAgICAgICAgICAgIC8vIE92ZXJpZGUgd2l0aCBjdXN0b20gb2Zmc2V0LlxuICAgICAgICAgICAgb2Zmc2V0VmFsID0gb2Zmc2V0O1xuICAgICAgICB9XG4gICAgICAgIC8vIENoZWNrcyBpZiBvZmZzZXQgaXMgYmVsb3cgemVybywgb3IgdGhlIG9mZnNldCtsZW5ndGggb2Zmc2V0IGlzIGJleW9uZCB0aGUgdG90YWwgbGVuZ3RoIG9mIHRoZSBtYW5hZ2VkIGRhdGEuXG4gICAgICAgIGlmIChvZmZzZXRWYWwgPCAwIHx8IG9mZnNldFZhbCArIGxlbmd0aCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IodXRpbHNfMS5FUlJPUlMuSU5WQUxJRF9SRUFEX0JFWU9ORF9CT1VORFMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuc3VyZXMgdGhhdCB0aGUgaW50ZXJuYWwgQnVmZmVyIGlzIGxhcmdlIGVub3VnaCB0byBpbnNlcnQgZGF0YS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBkYXRhTGVuZ3RoIHsgTnVtYmVyIH0gVGhlIGxlbmd0aCBvZiB0aGUgZGF0YSB0aGF0IG5lZWRzIHRvIGJlIHdyaXR0ZW4uXG4gICAgICogQHBhcmFtIG9mZnNldCB7IE51bWJlciB9IFRoZSBvZmZzZXQgb2YgdGhlIGRhdGEgdG8gYmUgd3JpdHRlbi5cbiAgICAgKi9cbiAgICBlbnN1cmVJbnNlcnRhYmxlKGRhdGFMZW5ndGgsIG9mZnNldCkge1xuICAgICAgICAvLyBDaGVja3MgZm9yIHZhbGlkIG51bWJlcmljIHZhbHVlO1xuICAgICAgICB1dGlsc18xLmNoZWNrT2Zmc2V0VmFsdWUob2Zmc2V0KTtcbiAgICAgICAgLy8gRW5zdXJlIHRoZXJlIGlzIGVub3VnaCBpbnRlcm5hbCBCdWZmZXIgY2FwYWNpdHkuXG4gICAgICAgIHRoaXMuX2Vuc3VyZUNhcGFjaXR5KHRoaXMubGVuZ3RoICsgZGF0YUxlbmd0aCk7XG4gICAgICAgIC8vIElmIGFuIG9mZnNldCB3YXMgcHJvdmlkZWQgYW5kIGl0cyBub3QgdGhlIHZlcnkgZW5kIG9mIHRoZSBidWZmZXIsIGNvcHkgZGF0YSBpbnRvIGFwcHJvcHJpYXRlIGxvY2F0aW9uIGluIHJlZ2FyZHMgdG8gdGhlIG9mZnNldC5cbiAgICAgICAgaWYgKG9mZnNldCA8IHRoaXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLl9idWZmLmNvcHkodGhpcy5fYnVmZiwgb2Zmc2V0ICsgZGF0YUxlbmd0aCwgb2Zmc2V0LCB0aGlzLl9idWZmLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRqdXN0IHRyYWNrZWQgc21hcnQgYnVmZmVyIGxlbmd0aFxuICAgICAgICBpZiAob2Zmc2V0ICsgZGF0YUxlbmd0aCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmxlbmd0aCA9IG9mZnNldCArIGRhdGFMZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmxlbmd0aCArPSBkYXRhTGVuZ3RoO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuc3VyZXMgdGhhdCB0aGUgaW50ZXJuYWwgQnVmZmVyIGlzIGxhcmdlIGVub3VnaCB0byB3cml0ZSBkYXRhLlxuICAgICAqXG4gICAgICogQHBhcmFtIGRhdGFMZW5ndGggeyBOdW1iZXIgfSBUaGUgbGVuZ3RoIG9mIHRoZSBkYXRhIHRoYXQgbmVlZHMgdG8gYmUgd3JpdHRlbi5cbiAgICAgKiBAcGFyYW0gb2Zmc2V0IHsgTnVtYmVyIH0gVGhlIG9mZnNldCBvZiB0aGUgZGF0YSB0byBiZSB3cml0dGVuIChkZWZhdWx0cyB0byB3cml0ZU9mZnNldCkuXG4gICAgICovXG4gICAgX2Vuc3VyZVdyaXRlYWJsZShkYXRhTGVuZ3RoLCBvZmZzZXQpIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0VmFsID0gdHlwZW9mIG9mZnNldCA9PT0gJ251bWJlcicgPyBvZmZzZXQgOiB0aGlzLl93cml0ZU9mZnNldDtcbiAgICAgICAgLy8gRW5zdXJlIGVub3VnaCBjYXBhY2l0eSB0byB3cml0ZSBkYXRhLlxuICAgICAgICB0aGlzLl9lbnN1cmVDYXBhY2l0eShvZmZzZXRWYWwgKyBkYXRhTGVuZ3RoKTtcbiAgICAgICAgLy8gQWRqdXN0IFNtYXJ0QnVmZmVyIGxlbmd0aCAoaWYgb2Zmc2V0ICsgbGVuZ3RoIGlzIGxhcmdlciB0aGFuIG1hbmFnZWQgbGVuZ3RoLCBhZGp1c3QgbGVuZ3RoKVxuICAgICAgICBpZiAob2Zmc2V0VmFsICsgZGF0YUxlbmd0aCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmxlbmd0aCA9IG9mZnNldFZhbCArIGRhdGFMZW5ndGg7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5zdXJlcyB0aGF0IHRoZSBpbnRlcm5hbCBCdWZmZXIgaXMgbGFyZ2UgZW5vdWdoIHRvIHdyaXRlIGF0IGxlYXN0IHRoZSBnaXZlbiBhbW91bnQgb2YgZGF0YS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBtaW5MZW5ndGggeyBOdW1iZXIgfSBUaGUgbWluaW11bSBsZW5ndGggb2YgdGhlIGRhdGEgbmVlZHMgdG8gYmUgd3JpdHRlbi5cbiAgICAgKi9cbiAgICBfZW5zdXJlQ2FwYWNpdHkobWluTGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IG9sZExlbmd0aCA9IHRoaXMuX2J1ZmYubGVuZ3RoO1xuICAgICAgICBpZiAobWluTGVuZ3RoID4gb2xkTGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgZGF0YSA9IHRoaXMuX2J1ZmY7XG4gICAgICAgICAgICBsZXQgbmV3TGVuZ3RoID0gKG9sZExlbmd0aCAqIDMpIC8gMiArIDE7XG4gICAgICAgICAgICBpZiAobmV3TGVuZ3RoIDwgbWluTGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbmV3TGVuZ3RoID0gbWluTGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fYnVmZiA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuZXdMZW5ndGgpO1xuICAgICAgICAgICAgZGF0YS5jb3B5KHRoaXMuX2J1ZmYsIDAsIDAsIG9sZExlbmd0aCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVhZHMgYSBudW1lcmljIG51bWJlciB2YWx1ZSB1c2luZyB0aGUgcHJvdmlkZWQgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAdHlwZXBhcmFtIFQgeyBudW1iZXIgfCBiaWdpbnQgfSBUaGUgdHlwZSBvZiB0aGUgdmFsdWUgdG8gYmUgcmVhZFxuICAgICAqXG4gICAgICogQHBhcmFtIGZ1bmMgeyBGdW5jdGlvbihvZmZzZXQ6IG51bWJlcikgPT4gbnVtYmVyIH0gVGhlIGZ1bmN0aW9uIHRvIHJlYWQgZGF0YSBvbiB0aGUgaW50ZXJuYWwgQnVmZmVyIHdpdGguXG4gICAgICogQHBhcmFtIGJ5dGVTaXplIHsgTnVtYmVyIH0gVGhlIG51bWJlciBvZiBieXRlcyByZWFkLlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSBUaGUgb2Zmc2V0IHRvIHJlYWQgZnJvbSAob3B0aW9uYWwpLiBXaGVuIHRoaXMgaXMgbm90IHByb3ZpZGVkLCB0aGUgbWFuYWdlZCByZWFkT2Zmc2V0IGlzIHVzZWQgaW5zdGVhZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHsgVCB9IHRoZSBudW1iZXIgdmFsdWVcbiAgICAgKi9cbiAgICBfcmVhZE51bWJlclZhbHVlKGZ1bmMsIGJ5dGVTaXplLCBvZmZzZXQpIHtcbiAgICAgICAgdGhpcy5lbnN1cmVSZWFkYWJsZShieXRlU2l6ZSwgb2Zmc2V0KTtcbiAgICAgICAgLy8gQ2FsbCBCdWZmZXIucmVhZFhYWFgoKTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBmdW5jLmNhbGwodGhpcy5fYnVmZiwgdHlwZW9mIG9mZnNldCA9PT0gJ251bWJlcicgPyBvZmZzZXQgOiB0aGlzLl9yZWFkT2Zmc2V0KTtcbiAgICAgICAgLy8gQWRqdXN0IGludGVybmFsIHJlYWQgb2Zmc2V0IGlmIGFuIG9wdGlvbmFsIHJlYWQgb2Zmc2V0IHdhcyBub3QgcHJvdmlkZWQuXG4gICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhpcy5fcmVhZE9mZnNldCArPSBieXRlU2l6ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluc2VydHMgYSBudW1lcmljIG51bWJlciB2YWx1ZSBiYXNlZCBvbiB0aGUgZ2l2ZW4gb2Zmc2V0IGFuZCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEB0eXBlcGFyYW0gVCB7IG51bWJlciB8IGJpZ2ludCB9IFRoZSB0eXBlIG9mIHRoZSB2YWx1ZSB0byBiZSB3cml0dGVuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZnVuYyB7IEZ1bmN0aW9uKG9mZnNldDogVCwgb2Zmc2V0PykgPT4gbnVtYmVyfSBUaGUgZnVuY3Rpb24gdG8gd3JpdGUgZGF0YSBvbiB0aGUgaW50ZXJuYWwgQnVmZmVyIHdpdGguXG4gICAgICogQHBhcmFtIGJ5dGVTaXplIHsgTnVtYmVyIH0gVGhlIG51bWJlciBvZiBieXRlcyB3cml0dGVuLlxuICAgICAqIEBwYXJhbSB2YWx1ZSB7IFQgfSBUaGUgbnVtYmVyIHZhbHVlIHRvIHdyaXRlLlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSB0aGUgb2Zmc2V0IHRvIHdyaXRlIHRoZSBudW1iZXIgYXQgKFJFUVVJUkVEKS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFNtYXJ0QnVmZmVyIHRoaXMgYnVmZmVyXG4gICAgICovXG4gICAgX2luc2VydE51bWJlclZhbHVlKGZ1bmMsIGJ5dGVTaXplLCB2YWx1ZSwgb2Zmc2V0KSB7XG4gICAgICAgIC8vIENoZWNrIGZvciBpbnZhbGlkIG9mZnNldCB2YWx1ZXMuXG4gICAgICAgIHV0aWxzXzEuY2hlY2tPZmZzZXRWYWx1ZShvZmZzZXQpO1xuICAgICAgICAvLyBFbnN1cmUgdGhlcmUgaXMgZW5vdWdoIGludGVybmFsIEJ1ZmZlciBjYXBhY2l0eS4gKHJhdyBvZmZzZXQgaXMgcGFzc2VkKVxuICAgICAgICB0aGlzLmVuc3VyZUluc2VydGFibGUoYnl0ZVNpemUsIG9mZnNldCk7XG4gICAgICAgIC8vIENhbGwgYnVmZmVyLndyaXRlWFhYWCgpO1xuICAgICAgICBmdW5jLmNhbGwodGhpcy5fYnVmZiwgdmFsdWUsIG9mZnNldCk7XG4gICAgICAgIC8vIEFkanVzdHMgaW50ZXJuYWxseSBtYW5hZ2VkIHdyaXRlIG9mZnNldC5cbiAgICAgICAgdGhpcy5fd3JpdGVPZmZzZXQgKz0gYnl0ZVNpemU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZXMgYSBudW1lcmljIG51bWJlciB2YWx1ZSBiYXNlZCBvbiB0aGUgZ2l2ZW4gb2Zmc2V0IGFuZCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEB0eXBlcGFyYW0gVCB7IG51bWJlciB8IGJpZ2ludCB9IFRoZSB0eXBlIG9mIHRoZSB2YWx1ZSB0byBiZSB3cml0dGVuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZnVuYyB7IEZ1bmN0aW9uKG9mZnNldDogVCwgb2Zmc2V0PykgPT4gbnVtYmVyfSBUaGUgZnVuY3Rpb24gdG8gd3JpdGUgZGF0YSBvbiB0aGUgaW50ZXJuYWwgQnVmZmVyIHdpdGguXG4gICAgICogQHBhcmFtIGJ5dGVTaXplIHsgTnVtYmVyIH0gVGhlIG51bWJlciBvZiBieXRlcyB3cml0dGVuLlxuICAgICAqIEBwYXJhbSB2YWx1ZSB7IFQgfSBUaGUgbnVtYmVyIHZhbHVlIHRvIHdyaXRlLlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSB0aGUgb2Zmc2V0IHRvIHdyaXRlIHRoZSBudW1iZXIgYXQgKFJFUVVJUkVEKS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFNtYXJ0QnVmZmVyIHRoaXMgYnVmZmVyXG4gICAgICovXG4gICAgX3dyaXRlTnVtYmVyVmFsdWUoZnVuYywgYnl0ZVNpemUsIHZhbHVlLCBvZmZzZXQpIHtcbiAgICAgICAgLy8gSWYgYW4gb2Zmc2V0IHdhcyBwcm92aWRlZCwgdmFsaWRhdGUgaXQuXG4gICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgd2UncmUgd3JpdGluZyBiZXlvbmQgdGhlIGJvdW5kcyBvZiB0aGUgbWFuYWdlZCBkYXRhLlxuICAgICAgICAgICAgaWYgKG9mZnNldCA8IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IodXRpbHNfMS5FUlJPUlMuSU5WQUxJRF9XUklURV9CRVlPTkRfQk9VTkRTKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHV0aWxzXzEuY2hlY2tPZmZzZXRWYWx1ZShvZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIERlZmF1bHQgdG8gd3JpdGVPZmZzZXQgaWYgbm8gb2Zmc2V0IHZhbHVlIHdhcyBnaXZlbi5cbiAgICAgICAgY29uc3Qgb2Zmc2V0VmFsID0gdHlwZW9mIG9mZnNldCA9PT0gJ251bWJlcicgPyBvZmZzZXQgOiB0aGlzLl93cml0ZU9mZnNldDtcbiAgICAgICAgLy8gRW5zdXJlIHRoZXJlIGlzIGVub3VnaCBpbnRlcm5hbCBCdWZmZXIgY2FwYWNpdHkuIChyYXcgb2Zmc2V0IGlzIHBhc3NlZClcbiAgICAgICAgdGhpcy5fZW5zdXJlV3JpdGVhYmxlKGJ5dGVTaXplLCBvZmZzZXRWYWwpO1xuICAgICAgICBmdW5jLmNhbGwodGhpcy5fYnVmZiwgdmFsdWUsIG9mZnNldFZhbCk7XG4gICAgICAgIC8vIElmIGFuIG9mZnNldCB3YXMgZ2l2ZW4sIGNoZWNrIHRvIHNlZSBpZiB3ZSB3cm90ZSBiZXlvbmQgdGhlIGN1cnJlbnQgd3JpdGVPZmZzZXQuXG4gICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdGhpcy5fd3JpdGVPZmZzZXQgPSBNYXRoLm1heCh0aGlzLl93cml0ZU9mZnNldCwgb2Zmc2V0VmFsICsgYnl0ZVNpemUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gSWYgbm8gbnVtZXJpYyBvZmZzZXQgd2FzIGdpdmVuLCB3ZSB3cm90ZSB0byB0aGUgZW5kIG9mIHRoZSBTbWFydEJ1ZmZlciBzbyBpbmNyZW1lbnQgd3JpdGVPZmZzZXQuXG4gICAgICAgICAgICB0aGlzLl93cml0ZU9mZnNldCArPSBieXRlU2l6ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG5leHBvcnRzLlNtYXJ0QnVmZmVyID0gU21hcnRCdWZmZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zbWFydGJ1ZmZlci5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/smart-buffer/build/smartbuffer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/smart-buffer/build/utils.js":
/*!**************************************************!*\
  !*** ./node_modules/smart-buffer/build/utils.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst buffer_1 = __webpack_require__(/*! buffer */ \"buffer\");\n/**\n * Error strings\n */\nconst ERRORS = {\n    INVALID_ENCODING: 'Invalid encoding provided. Please specify a valid encoding the internal Node.js Buffer supports.',\n    INVALID_SMARTBUFFER_SIZE: 'Invalid size provided. Size must be a valid integer greater than zero.',\n    INVALID_SMARTBUFFER_BUFFER: 'Invalid Buffer provided in SmartBufferOptions.',\n    INVALID_SMARTBUFFER_OBJECT: 'Invalid SmartBufferOptions object supplied to SmartBuffer constructor or factory methods.',\n    INVALID_OFFSET: 'An invalid offset value was provided.',\n    INVALID_OFFSET_NON_NUMBER: 'An invalid offset value was provided. A numeric value is required.',\n    INVALID_LENGTH: 'An invalid length value was provided.',\n    INVALID_LENGTH_NON_NUMBER: 'An invalid length value was provived. A numeric value is required.',\n    INVALID_TARGET_OFFSET: 'Target offset is beyond the bounds of the internal SmartBuffer data.',\n    INVALID_TARGET_LENGTH: 'Specified length value moves cursor beyong the bounds of the internal SmartBuffer data.',\n    INVALID_READ_BEYOND_BOUNDS: 'Attempted to read beyond the bounds of the managed data.',\n    INVALID_WRITE_BEYOND_BOUNDS: 'Attempted to write beyond the bounds of the managed data.'\n};\nexports.ERRORS = ERRORS;\n/**\n * Checks if a given encoding is a valid Buffer encoding. (Throws an exception if check fails)\n *\n * @param { String } encoding The encoding string to check.\n */\nfunction checkEncoding(encoding) {\n    if (!buffer_1.Buffer.isEncoding(encoding)) {\n        throw new Error(ERRORS.INVALID_ENCODING);\n    }\n}\nexports.checkEncoding = checkEncoding;\n/**\n * Checks if a given number is a finite integer. (Throws an exception if check fails)\n *\n * @param { Number } value The number value to check.\n */\nfunction isFiniteInteger(value) {\n    return typeof value === 'number' && isFinite(value) && isInteger(value);\n}\nexports.isFiniteInteger = isFiniteInteger;\n/**\n * Checks if an offset/length value is valid. (Throws an exception if check fails)\n *\n * @param value The value to check.\n * @param offset True if checking an offset, false if checking a length.\n */\nfunction checkOffsetOrLengthValue(value, offset) {\n    if (typeof value === 'number') {\n        // Check for non finite/non integers\n        if (!isFiniteInteger(value) || value < 0) {\n            throw new Error(offset ? ERRORS.INVALID_OFFSET : ERRORS.INVALID_LENGTH);\n        }\n    }\n    else {\n        throw new Error(offset ? ERRORS.INVALID_OFFSET_NON_NUMBER : ERRORS.INVALID_LENGTH_NON_NUMBER);\n    }\n}\n/**\n * Checks if a length value is valid. (Throws an exception if check fails)\n *\n * @param { Number } length The value to check.\n */\nfunction checkLengthValue(length) {\n    checkOffsetOrLengthValue(length, false);\n}\nexports.checkLengthValue = checkLengthValue;\n/**\n * Checks if a offset value is valid. (Throws an exception if check fails)\n *\n * @param { Number } offset The value to check.\n */\nfunction checkOffsetValue(offset) {\n    checkOffsetOrLengthValue(offset, true);\n}\nexports.checkOffsetValue = checkOffsetValue;\n/**\n * Checks if a target offset value is out of bounds. (Throws an exception if check fails)\n *\n * @param { Number } offset The offset value to check.\n * @param { SmartBuffer } buff The SmartBuffer instance to check against.\n */\nfunction checkTargetOffset(offset, buff) {\n    if (offset < 0 || offset > buff.length) {\n        throw new Error(ERRORS.INVALID_TARGET_OFFSET);\n    }\n}\nexports.checkTargetOffset = checkTargetOffset;\n/**\n * Determines whether a given number is a integer.\n * @param value The number to check.\n */\nfunction isInteger(value) {\n    return typeof value === 'number' && isFinite(value) && Math.floor(value) === value;\n}\n/**\n * Throws if Node.js version is too low to support bigint\n */\nfunction bigIntAndBufferInt64Check(bufferMethod) {\n    if (typeof BigInt === 'undefined') {\n        throw new Error('Platform does not support JS BigInt type.');\n    }\n    if (typeof buffer_1.Buffer.prototype[bufferMethod] === 'undefined') {\n        throw new Error(`Platform does not support Buffer.prototype.${bufferMethod}.`);\n    }\n}\nexports.bigIntAndBufferInt64Check = bigIntAndBufferInt64Check;\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc21hcnQtYnVmZmVyL2J1aWxkL3V0aWxzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGlCQUFpQixtQkFBTyxDQUFDLHNCQUFRO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCLFlBQVksY0FBYztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLGFBQWE7QUFDbkY7QUFDQTtBQUNBLGlDQUFpQztBQUNqQyIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxTaW1wbGVcXERvd25sb2Fkc1xcUHJveWVjdG9FeHRyYWN0b3JEZUZpbGFtZW50b1xcZXh0cmFjdG9yLXNlcnZlclxcbm9kZV9tb2R1bGVzXFxzbWFydC1idWZmZXJcXGJ1aWxkXFx1dGlscy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGJ1ZmZlcl8xID0gcmVxdWlyZShcImJ1ZmZlclwiKTtcbi8qKlxuICogRXJyb3Igc3RyaW5nc1xuICovXG5jb25zdCBFUlJPUlMgPSB7XG4gICAgSU5WQUxJRF9FTkNPRElORzogJ0ludmFsaWQgZW5jb2RpbmcgcHJvdmlkZWQuIFBsZWFzZSBzcGVjaWZ5IGEgdmFsaWQgZW5jb2RpbmcgdGhlIGludGVybmFsIE5vZGUuanMgQnVmZmVyIHN1cHBvcnRzLicsXG4gICAgSU5WQUxJRF9TTUFSVEJVRkZFUl9TSVpFOiAnSW52YWxpZCBzaXplIHByb3ZpZGVkLiBTaXplIG11c3QgYmUgYSB2YWxpZCBpbnRlZ2VyIGdyZWF0ZXIgdGhhbiB6ZXJvLicsXG4gICAgSU5WQUxJRF9TTUFSVEJVRkZFUl9CVUZGRVI6ICdJbnZhbGlkIEJ1ZmZlciBwcm92aWRlZCBpbiBTbWFydEJ1ZmZlck9wdGlvbnMuJyxcbiAgICBJTlZBTElEX1NNQVJUQlVGRkVSX09CSkVDVDogJ0ludmFsaWQgU21hcnRCdWZmZXJPcHRpb25zIG9iamVjdCBzdXBwbGllZCB0byBTbWFydEJ1ZmZlciBjb25zdHJ1Y3RvciBvciBmYWN0b3J5IG1ldGhvZHMuJyxcbiAgICBJTlZBTElEX09GRlNFVDogJ0FuIGludmFsaWQgb2Zmc2V0IHZhbHVlIHdhcyBwcm92aWRlZC4nLFxuICAgIElOVkFMSURfT0ZGU0VUX05PTl9OVU1CRVI6ICdBbiBpbnZhbGlkIG9mZnNldCB2YWx1ZSB3YXMgcHJvdmlkZWQuIEEgbnVtZXJpYyB2YWx1ZSBpcyByZXF1aXJlZC4nLFxuICAgIElOVkFMSURfTEVOR1RIOiAnQW4gaW52YWxpZCBsZW5ndGggdmFsdWUgd2FzIHByb3ZpZGVkLicsXG4gICAgSU5WQUxJRF9MRU5HVEhfTk9OX05VTUJFUjogJ0FuIGludmFsaWQgbGVuZ3RoIHZhbHVlIHdhcyBwcm92aXZlZC4gQSBudW1lcmljIHZhbHVlIGlzIHJlcXVpcmVkLicsXG4gICAgSU5WQUxJRF9UQVJHRVRfT0ZGU0VUOiAnVGFyZ2V0IG9mZnNldCBpcyBiZXlvbmQgdGhlIGJvdW5kcyBvZiB0aGUgaW50ZXJuYWwgU21hcnRCdWZmZXIgZGF0YS4nLFxuICAgIElOVkFMSURfVEFSR0VUX0xFTkdUSDogJ1NwZWNpZmllZCBsZW5ndGggdmFsdWUgbW92ZXMgY3Vyc29yIGJleW9uZyB0aGUgYm91bmRzIG9mIHRoZSBpbnRlcm5hbCBTbWFydEJ1ZmZlciBkYXRhLicsXG4gICAgSU5WQUxJRF9SRUFEX0JFWU9ORF9CT1VORFM6ICdBdHRlbXB0ZWQgdG8gcmVhZCBiZXlvbmQgdGhlIGJvdW5kcyBvZiB0aGUgbWFuYWdlZCBkYXRhLicsXG4gICAgSU5WQUxJRF9XUklURV9CRVlPTkRfQk9VTkRTOiAnQXR0ZW1wdGVkIHRvIHdyaXRlIGJleW9uZCB0aGUgYm91bmRzIG9mIHRoZSBtYW5hZ2VkIGRhdGEuJ1xufTtcbmV4cG9ydHMuRVJST1JTID0gRVJST1JTO1xuLyoqXG4gKiBDaGVja3MgaWYgYSBnaXZlbiBlbmNvZGluZyBpcyBhIHZhbGlkIEJ1ZmZlciBlbmNvZGluZy4gKFRocm93cyBhbiBleGNlcHRpb24gaWYgY2hlY2sgZmFpbHMpXG4gKlxuICogQHBhcmFtIHsgU3RyaW5nIH0gZW5jb2RpbmcgVGhlIGVuY29kaW5nIHN0cmluZyB0byBjaGVjay5cbiAqL1xuZnVuY3Rpb24gY2hlY2tFbmNvZGluZyhlbmNvZGluZykge1xuICAgIGlmICghYnVmZmVyXzEuQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihFUlJPUlMuSU5WQUxJRF9FTkNPRElORyk7XG4gICAgfVxufVxuZXhwb3J0cy5jaGVja0VuY29kaW5nID0gY2hlY2tFbmNvZGluZztcbi8qKlxuICogQ2hlY2tzIGlmIGEgZ2l2ZW4gbnVtYmVyIGlzIGEgZmluaXRlIGludGVnZXIuIChUaHJvd3MgYW4gZXhjZXB0aW9uIGlmIGNoZWNrIGZhaWxzKVxuICpcbiAqIEBwYXJhbSB7IE51bWJlciB9IHZhbHVlIFRoZSBudW1iZXIgdmFsdWUgdG8gY2hlY2suXG4gKi9cbmZ1bmN0aW9uIGlzRmluaXRlSW50ZWdlcih2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIGlzRmluaXRlKHZhbHVlKSAmJiBpc0ludGVnZXIodmFsdWUpO1xufVxuZXhwb3J0cy5pc0Zpbml0ZUludGVnZXIgPSBpc0Zpbml0ZUludGVnZXI7XG4vKipcbiAqIENoZWNrcyBpZiBhbiBvZmZzZXQvbGVuZ3RoIHZhbHVlIGlzIHZhbGlkLiAoVGhyb3dzIGFuIGV4Y2VwdGlvbiBpZiBjaGVjayBmYWlscylcbiAqXG4gKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIG9mZnNldCBUcnVlIGlmIGNoZWNraW5nIGFuIG9mZnNldCwgZmFsc2UgaWYgY2hlY2tpbmcgYSBsZW5ndGguXG4gKi9cbmZ1bmN0aW9uIGNoZWNrT2Zmc2V0T3JMZW5ndGhWYWx1ZSh2YWx1ZSwgb2Zmc2V0KSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgLy8gQ2hlY2sgZm9yIG5vbiBmaW5pdGUvbm9uIGludGVnZXJzXG4gICAgICAgIGlmICghaXNGaW5pdGVJbnRlZ2VyKHZhbHVlKSB8fCB2YWx1ZSA8IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihvZmZzZXQgPyBFUlJPUlMuSU5WQUxJRF9PRkZTRVQgOiBFUlJPUlMuSU5WQUxJRF9MRU5HVEgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3Iob2Zmc2V0ID8gRVJST1JTLklOVkFMSURfT0ZGU0VUX05PTl9OVU1CRVIgOiBFUlJPUlMuSU5WQUxJRF9MRU5HVEhfTk9OX05VTUJFUik7XG4gICAgfVxufVxuLyoqXG4gKiBDaGVja3MgaWYgYSBsZW5ndGggdmFsdWUgaXMgdmFsaWQuIChUaHJvd3MgYW4gZXhjZXB0aW9uIGlmIGNoZWNrIGZhaWxzKVxuICpcbiAqIEBwYXJhbSB7IE51bWJlciB9IGxlbmd0aCBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKi9cbmZ1bmN0aW9uIGNoZWNrTGVuZ3RoVmFsdWUobGVuZ3RoKSB7XG4gICAgY2hlY2tPZmZzZXRPckxlbmd0aFZhbHVlKGxlbmd0aCwgZmFsc2UpO1xufVxuZXhwb3J0cy5jaGVja0xlbmd0aFZhbHVlID0gY2hlY2tMZW5ndGhWYWx1ZTtcbi8qKlxuICogQ2hlY2tzIGlmIGEgb2Zmc2V0IHZhbHVlIGlzIHZhbGlkLiAoVGhyb3dzIGFuIGV4Y2VwdGlvbiBpZiBjaGVjayBmYWlscylcbiAqXG4gKiBAcGFyYW0geyBOdW1iZXIgfSBvZmZzZXQgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICovXG5mdW5jdGlvbiBjaGVja09mZnNldFZhbHVlKG9mZnNldCkge1xuICAgIGNoZWNrT2Zmc2V0T3JMZW5ndGhWYWx1ZShvZmZzZXQsIHRydWUpO1xufVxuZXhwb3J0cy5jaGVja09mZnNldFZhbHVlID0gY2hlY2tPZmZzZXRWYWx1ZTtcbi8qKlxuICogQ2hlY2tzIGlmIGEgdGFyZ2V0IG9mZnNldCB2YWx1ZSBpcyBvdXQgb2YgYm91bmRzLiAoVGhyb3dzIGFuIGV4Y2VwdGlvbiBpZiBjaGVjayBmYWlscylcbiAqXG4gKiBAcGFyYW0geyBOdW1iZXIgfSBvZmZzZXQgVGhlIG9mZnNldCB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSB7IFNtYXJ0QnVmZmVyIH0gYnVmZiBUaGUgU21hcnRCdWZmZXIgaW5zdGFuY2UgdG8gY2hlY2sgYWdhaW5zdC5cbiAqL1xuZnVuY3Rpb24gY2hlY2tUYXJnZXRPZmZzZXQob2Zmc2V0LCBidWZmKSB7XG4gICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ID4gYnVmZi5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKEVSUk9SUy5JTlZBTElEX1RBUkdFVF9PRkZTRVQpO1xuICAgIH1cbn1cbmV4cG9ydHMuY2hlY2tUYXJnZXRPZmZzZXQgPSBjaGVja1RhcmdldE9mZnNldDtcbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIGEgZ2l2ZW4gbnVtYmVyIGlzIGEgaW50ZWdlci5cbiAqIEBwYXJhbSB2YWx1ZSBUaGUgbnVtYmVyIHRvIGNoZWNrLlxuICovXG5mdW5jdGlvbiBpc0ludGVnZXIodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiBpc0Zpbml0ZSh2YWx1ZSkgJiYgTWF0aC5mbG9vcih2YWx1ZSkgPT09IHZhbHVlO1xufVxuLyoqXG4gKiBUaHJvd3MgaWYgTm9kZS5qcyB2ZXJzaW9uIGlzIHRvbyBsb3cgdG8gc3VwcG9ydCBiaWdpbnRcbiAqL1xuZnVuY3Rpb24gYmlnSW50QW5kQnVmZmVySW50NjRDaGVjayhidWZmZXJNZXRob2QpIHtcbiAgICBpZiAodHlwZW9mIEJpZ0ludCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQbGF0Zm9ybSBkb2VzIG5vdCBzdXBwb3J0IEpTIEJpZ0ludCB0eXBlLicpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGJ1ZmZlcl8xLkJ1ZmZlci5wcm90b3R5cGVbYnVmZmVyTWV0aG9kXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQbGF0Zm9ybSBkb2VzIG5vdCBzdXBwb3J0IEJ1ZmZlci5wcm90b3R5cGUuJHtidWZmZXJNZXRob2R9LmApO1xuICAgIH1cbn1cbmV4cG9ydHMuYmlnSW50QW5kQnVmZmVySW50NjRDaGVjayA9IGJpZ0ludEFuZEJ1ZmZlckludDY0Q2hlY2s7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/smart-buffer/build/utils.js\n");

/***/ })

};
;